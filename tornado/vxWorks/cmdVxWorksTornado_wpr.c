
/*  ----------------------------------------------------------
 *   File: cmdVxWorksTornado_wpr.c VxWorks Target interface thru target server
 *   This file was automatically generated with
 *   jWrap (C)FRIDU a Free Software Company 97-98
 *   the Mon Mar 22 11:40:11 1999


 *   jWrap --cc2tornado /home/solo/Fulup/Vues/Fridu/Exe/linux86/etc/headerVxWorksTornado.h.cpp
 *
 *   WARNING: Except if you really know what you are doing
 *   you should not edit this file by hand.
 *
 *   In order finding jWrap check: http://www.fridu.bzh
 + ------------------------------------------------------------ */

#ifndef EASYC_PROTO_ONLY
#define EASYC_PROTO_ONLY
#endif
#define JWRAP_CC2TORNADO

#include "libRuntimeTornado.h"
#include "headerVxWorksTornado.h"

#define JWRAP_CC2JTCL
#ifndef VxWorks_CUSTOM_STAMP
 #ifdef FRIDU
 #define VxWorks_CUSTOM_STAMP &vStamp_libVxWorks[12]
 #else
 #define VxWorks_CUSTOM_STAMP NULL
 #endif
#endif

// Special Tornado-Tornado defines for overloading jWrap type translation
 #define jWrapTypeTcl2Cc(P1,P2,P3,P4) tornadoTypeTcl2Cc(&tornadoInfo,P1,P2,P3,P4)
 #define jWrapTypeUpdate(P1,P2,P3,P4)  tornadoTypeUpdate(&tornadoInfo,P1,P2,P3,P4)
 #define jWrapTypeCc2Tcl(P1,P2)       tornadoTypeCc2Tcl(&tornadoInfo,P1,P2)
 #define jWrapTypeClean               tornadoTypeClean
 #define jWrapTypeFree                freeTornadoLocal
 #define JWRAP_CREATE_FUNC            createTornadoLocal
 #define JWRAP_FREE_FUNC              freeTornadoLocal
 #define JWRAP_CGET_FUNC              cGetTornadoLocal
 #define jWrapVarRegister(P1,P2,P3,P4,P5,P6) tornadoVarRegister(&tornadoInfo,P1,P2,P3,P5,P6)
 // do we use wtx or VxWorks malloc ?
 #ifdef USE_TARGET_MALLOC
 #define tornadoTypeFree     tornadoTargetTypeFree
 #define tornadoStringFree   tornadoTargetStringFree
 #define tornadoTypeTcl2Cc   tornadoTargetTypeTcl2Cc
 #define tornadoStringTcl2Cc tornadoTargetStringTcl2Cc
 #endif

 // Build module static informations
 static JWRAP_modules module;
 static int initDone=0;
 static TORNADO_infos tornadoInfo;
 static TORNADO_id    tornadoId;
 static char *errTypeFmt="param:%d type [%s] not equivalent to [%s]\n";

// Build string convertion routine
LOCAL int Put_String (Tcl_Interp *interp, Tcl_Obj *tclObj) {
  return (tornadoStringTcl2Cc (&tornadoInfo, interp, tclObj));
}
LOCAL void Get_String (Tcl_Obj *tclObj) {
  tornadoStringCc2Tcl (&tornadoInfo, tclObj);
}
LOCAL void Free_String (Tcl_Obj *tclObj) {
  tornadoStringFree (&tornadoInfo, tclObj);
}
// make Manual Alloc/Free Tornado string a Tcl type
static Tcl_ObjType stringType = {
  "VxWorks_string",
  (Tcl_FreeInternalRepProc *)NULL,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_String,
  (Tcl_SetFromAnyProc*)      Put_String
  };

// make Automatic Alloc/free Tornado string a Tcl type
static Tcl_ObjType stringPtrType = {
  "VxWorks_string_Ptr",
  (Tcl_FreeInternalRepProc *)Free_String,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_String,
  (Tcl_SetFromAnyProc*)      Put_String
  };


// Build a free wrapper in order Tcl to find Tornado->wtx handle
LOCAL void freeTornadoLocal (Tcl_Obj *objPtr) {
  tornadoTypeFree (&tornadoInfo, objPtr);
}

// Build a create wrapper in order Tcl to find Tornado->wtx handle
LOCAL void createTornadoLocal (Tcl_Interp *interp
           ,JWRAP_structs *structure,Tcl_Obj *srcObj, Tcl_Obj *destObj) {
  tornadoTypeTcl2Cc (&tornadoInfo, interp,structure,srcObj,destObj);
}

// Build a cget wrapper in order Tcl to find Tornado->wtx handle
LOCAL void cGetTornadoLocal (Tcl_Interp *interp
  ,JWRAP_structs *structure,Tcl_Obj *tclObj,Tcl_Obj *slot) {
  tornadoTypeCget (&tornadoInfo, interp,structure,tclObj,slot);
}
 static JWRAP_types usedType [175];

 // Build used type enumeration
 enum enumType {
   JTYPE_Define_VxWorks            = 0
  ,JTYPE_CACHE_LIB                 = 1
  ,JTYPE_CACHE_FUNCS               = 2
  ,JTYPE_void_Ptr                  = 3
  ,JTYPE_CACHE_MODE                = 4
  ,JTYPE_int                       = 5
  ,JTYPE_char                      = 6
  ,JTYPE_Struct_VxWorks_0          = 7
  ,JTYPE_aiocb                     = 8
  ,JTYPE_vx_off_t                  = 9
  ,JTYPE_size_t                    = 10
  ,JTYPE_vx_SigVect                = 11
  ,JTYPE_vx_AIO_SYS                = 12
  ,JTYPE_utimbuf                   = 13
  ,JTYPE_long                      = 14
  ,JTYPE_tm                        = 15
  ,JTYPE_vx_timespec               = 16
  ,JTYPE_itimerspec                = 17
  ,JTYPE_sigevent                  = 18
  ,JTYPE_sigval                    = 19
  ,JTYPE_siginfo                   = 20
  ,JTYPE_sigaction                 = 21
  ,JTYPE_Union_VxWorks_0           = 22
  ,JTYPE_sigset_t                  = 23
  ,JTYPE_node                      = 24
  ,JTYPE_node_Ptr                  = 25
  ,JTYPE_Struct_VxWorks_1          = 26
  ,JTYPE_NODE                      = 27
  ,JTYPE_Struct_VxWorks_2          = 28
  ,JTYPE_in_addr                   = 29
  ,JTYPE_u_long                    = 30
  ,JTYPE_sockaddr_in               = 31
  ,JTYPE_short                     = 32
  ,JTYPE_u_short                   = 33
  ,JTYPE_hostname_struct           = 34
  ,JTYPE_hostname_struct_Ptr       = 35
  ,JTYPE_char_Ptr                  = 36
  ,JTYPE_Struct_VxWorks_3          = 37
  ,JTYPE_HOSTNAME                  = 38
  ,JTYPE_bootp_msg                 = 39
  ,JTYPE_Struct_VxWorks_4          = 40
  ,JTYPE_Struct_VxWorks_5          = 41
  ,JTYPE_dirent                    = 42
  ,JTYPE_slnode                    = 43
  ,JTYPE_slnode_Ptr                = 44
  ,JTYPE_Struct_VxWorks_6          = 45
  ,JTYPE_HASH_NODE                 = 46
  ,JTYPE_Struct_VxWorks_7          = 47
  ,JTYPE_dlnode                    = 48
  ,JTYPE_dlnode_Ptr                = 49
  ,JTYPE_Struct_VxWorks_8          = 50
  ,JTYPE_DL_NODE                   = 51
  ,JTYPE_Struct_VxWorks_9          = 52
  ,JTYPE_UINT8                     = 53
  ,JTYPE_ULONG                     = 54
  ,JTYPE_Struct_VxWorks_10         = 55
  ,JTYPE_USHORT                    = 56
  ,JTYPE_Struct_VxWorks_11         = 57
  ,JTYPE_Struct_VxWorks_12         = 58
  ,JTYPE_UINT16                    = 59
  ,JTYPE_UINT                      = 60
  ,JTYPE_Struct_VxWorks_13         = 61
  ,JTYPE_DEV_HDR                   = 62
  ,JTYPE_SEM_ID                    = 63
  ,JTYPE_UINT8_Ptr                 = 64
  ,JTYPE_DOS_DIR_ENT_Ptr           = 65
  ,JTYPE_HASH_ID                   = 66
  ,JTYPE_Struct_VxWorks_14         = 67
  ,JTYPE_buffers                   = 68
  ,JTYPE_excfaultTab               = 69
  ,JTYPE_Struct_VxWorks_15         = 70
  ,JTYPE_Struct_VxWorks_16         = 71
  ,JTYPE_Struct_VxWorks_17         = 72
  ,JTYPE_Struct_VxWorks_18         = 73
  ,JTYPE_Struct_VxWorks_19         = 74
  ,JTYPE_MODULE_SEG_INFO           = 75
  ,JTYPE_Struct_VxWorks_20         = 76
  ,JTYPE_Struct_VxWorks_21         = 77
  ,JTYPE_int_Ptr                   = 78
  ,JTYPE_Struct_VxWorks_22         = 79
  ,JTYPE_INT8                      = 80
  ,JTYPE_Struct_VxWorks_23         = 81
  ,JTYPE_Struct_VxWorks_24         = 82
  ,JTYPE_Struct_VxWorks_25         = 83
  ,JTYPE_Struct_VxWorks_26         = 84
  ,JTYPE_taskVar                   = 85
  ,JTYPE_taskVar_Ptr               = 86
  ,JTYPE_Struct_VxWorks_27         = 87
  ,JTYPE_Union_VxWorks_1           = 88
  ,JTYPE_Enum_VxWorks_0            = 89
  ,JTYPE_Enum_VxWorks_1            = 90
  ,JTYPE_utimbuf_Ptr               = 91
  ,JTYPE_sigset_t_Ptr              = 92
  ,JTYPE_sigaction_Ptr             = 93
  ,JTYPE_siginfo_Ptr               = 94
  ,JTYPE_vx_timespec_Ptr           = 95
  ,JTYPE_tm_Ptr                    = 96
  ,JTYPE_long_Ptr                  = 97
  ,JTYPE_double                    = 98
  ,JTYPE_clockid_t                 = 99
  ,JTYPE_sigevent_Ptr              = 100
  ,JTYPE_timer_t_Ptr               = 101
  ,JTYPE_timer_t                   = 102
  ,JTYPE_itimerspec_Ptr            = 103
  ,JTYPE_aiocb_Ptr                 = 104
  ,JTYPE_aiocb_Ptr_Ptr             = 105
  ,JTYPE_agiocb_Ptr                = 106
  ,JTYPE_FILE_Ptr                  = 107
  ,JTYPE_fpos_t_Ptr                = 108
  ,JTYPE_div_t                     = 109
  ,JTYPE_in_addr_Ptr               = 110
  ,JTYPE_u_char_Ptr                = 111
  ,JTYPE_BOOT_PARAMS_Ptr           = 112
  ,JTYPE_u_int                     = 113
  ,JTYPE_BOOTP_MSG_Ptr             = 114
  ,JTYPE_NODE_Ptr                  = 115
  ,JTYPE_LIST_Ptr                  = 116
  ,JTYPE_CACHE_TYPE                = 117
  ,JTYPE_CACHE_FUNCS_Ptr           = 118
  ,JTYPE_INSTR_Ptr                 = 119
  ,JTYPE_event_t                   = 120
  ,JTYPE_DIR_Ptr                   = 121
  ,JTYPE_dirent_Ptr                = 122
  ,JTYPE_DOS_VOL_DESC_Ptr          = 123
  ,JTYPE_DOS_VOL_CONFIG_Ptr        = 124
  ,JTYPE_BLK_DEV_Ptr               = 125
  ,JTYPE_UINT_Ptr                  = 126
  ,JTYPE_SL_LIST_Ptr               = 127
  ,JTYPE_SL_NODE_Ptr               = 128
  ,JTYPE_H_NODE_INT_Ptr            = 129
  ,JTYPE_H_NODE_STRING_Ptr         = 130
  ,JTYPE_HASH_NODE_Ptr             = 131
  ,JTYPE_HASH_TBL_Ptr              = 132
  ,JTYPE_DEV_HDR_Ptr               = 133
  ,JTYPE_DL_LIST_Ptr               = 134
  ,JTYPE_DL_NODE_Ptr               = 135
  ,JTYPE_Q_FIFO_HEAD_Ptr           = 136
  ,JTYPE_Q_FIFO_NODE_Ptr           = 137
  ,JTYPE_SEM_B_STATE               = 138
  ,JTYPE_ifnet_Ptr                 = 139
  ,JTYPE_ether_header_Ptr          = 140
  ,JTYPE_VOIDFUNCPTR               = 141
  ,JTYPE_void_Ptr_Ptr              = 142
  ,JTYPE_MODULE_ID                 = 143
  ,JTYPE_SYMTAB_ID                 = 144
  ,JTYPE_SEG_INFO_Ptr              = 145
  ,JTYPE_PART_ID                   = 146
  ,JTYPE_MEM_PART_STATS_Ptr        = 147
  ,JTYPE_SEGMENT_ID                = 148
  ,JTYPE_MODULE_ID_Ptr             = 149
  ,JTYPE_MODULE_INFO_Ptr           = 150
  ,JTYPE_NFS_EXPORT_ENTRY_Ptr      = 151
  ,JTYPE_mqd_t                     = 152
  ,JTYPE_mq_attr_Ptr               = 153
  ,JTYPE_MSG_Q_ID                  = 154
  ,JTYPE_MSG_Q_INFO_Ptr            = 155
  ,JTYPE_NFS_SERVER_STATUS_Ptr     = 156
  ,JTYPE_NFS_FILE_HANDLE_Ptr       = 157
  ,JTYPE_fattr_Ptr                 = 158
  ,JTYPE_NFS_DEV_INFO_Ptr          = 159
  ,JTYPE_sockaddr_in_Ptr           = 160
  ,JTYPE_RING_ID                   = 161
  ,JTYPE_sockaddr_Ptr              = 162
  ,JTYPE_timeval_Ptr               = 163
  ,JTYPE_msghdr_Ptr                = 164
  ,JTYPE_caddr_t                   = 165
  ,JTYPE_SYMBOL_Ptr                = 166
  ,JTYPE_SYM_TYPE                  = 167
  ,JTYPE_SYMBOL_Ptr_Ptr            = 168
  ,JTYPE_SYM_TYPE_Ptr              = 169
  ,JTYPE_WIND_TCB_ID               = 170
  ,JTYPE_TASK_DESC_Ptr             = 171
  ,JTYPE_TASK_VAR_Ptr              = 172
  ,JTYPE_WDOG_ID                   = 173
  ,JTYPE_Tcl_Interp_Ptr            = 174
 }; // end of usedType enumeration

 // Build used commands arrays
 static WTX_CONTEXT_DESC wtxCtx [807];
 static char *helpCmd[] = {
   "int = utime (char * file, struct utimbuf * newTimes);",
   "int = raise (int __signo);",
   "int = kill (int __tid, int __signo);",
   "int = sigemptyset (sigset_t * __set);",
   "int = sigfillset (sigset_t * __set);",
   "int = sigaddset (sigset_t * __set, int __signo);",
   "int = sigdelset (sigset_t * __set, int __signo);",
   "int = sigismember (sigset_t * __set, int __signo);",
   "int = sigaction (int __sig, struct sigaction * __act, struct sigaction * __oact);",
   "int = sigprocmask (int __how, sigset_t * __set, sigset_t * __oset);",
   "int = sigpending (sigset_t * __set);",
   "int = sigsuspend (sigset_t * __sigmask);",
   "int = sigwait (sigset_t * __set);",
   "int = sigwaitinfo (sigset_t * __set, struct siginfo * __value);",
   "int = sigtimedwait (sigset_t * __set, struct siginfo * __value, struct vx_timespec * NoName);",
   "int = sigqueue (int tid, int signo, union sigval value);",
   "unsigned int = _clocks_per_sec ();",
   "char* = asctime (struct tm * _tptr);",
   "long = clock ();",
   "char* = ctime (long * _cal);",
   "double = difftime (long _t1, long _t0);",
   "struct tm* = gmtime (long * _tod);",
   "struct tm* = localtime (long * _tod);",
   "long = mktime (struct tm * _tptr);",
   "size_t = strftime (char * _s, size_t _n, char * _format, struct tm * _tptr);",
   "long = time (long * _tod);",
   "int = clock_gettime (clockid_t clock_id, struct vx_timespec * tp);",
   "int = clock_settime (clockid_t clock_id, struct vx_timespec * tp);",
   "int = clock_getres (clockid_t clock_id, struct vx_timespec * res);",
   "int = timer_create (clockid_t clock_id, struct sigevent * evp, timer_t * ptimer);",
   "int = timer_delete (timer_t timerid);",
   "int = timer_gettime (timer_t timerid, struct itimerspec * value);",
   "int = timer_settime (timer_t timerid, int flags, struct itimerspec * value, struct itimerspec * ovalue);",
   "int = timer_getoverrun (timer_t timerid);",
   "int = timer_connect (timer_t timerid, void * routine, int arg);",
   "int = timer_cancel (timer_t timerid);",
   "int = timer_show (timer_t timerid);",
   "int = nanosleep (struct vx_timespec * rqtp, struct vx_timespec * rmtp);",
   "int = aio_read (struct aiocb * NoName);",
   "int = aio_write (struct aiocb * NoName);",
   "int = lio_listio (int NoName, struct aiocb ** NoName, int NoName, struct sigevent * NoName);",
   "int = aio_error (struct aiocb * NoName);",
   "size_t = aio_return (struct agiocb * NoName);",
   "int = aio_cancel (int NoName, struct aiocb * NoName);",
   "int = aio_suspend (struct aiocb ** NoName, int NoName, struct vx_timespec * NoName);",
   "int = aioPxLibInit (int lioMax);",
   "int = aioShow (int drvNum);",
   "void = clearerr (FILE * NoName);",
   "int = fclose (FILE * NoName);",
   "int = feof (FILE * NoName);",
   "int = ferror (FILE * NoName);",
   "int = fflush (FILE * NoName);",
   "int = fgetc (FILE * NoName);",
   "int = fgetpos (FILE * NoName, fpos_t * NoName);",
   "char* = fgets (char * NoName, size_t NoName, FILE * NoName);",
   "FILE* = fopen (const char * NoName, const char * NoName);",
   "int = fputc (int NoName, FILE * NoName);",
   "int = fputs (const char * NoName, FILE * NoName);",
   "int = fread (void * NoName, size_t NoName, size_t NoName, FILE * NoName);",
   "FILE* = freopen (const char * NoName, const char * NoName, FILE * NoName);",
   "int = fseek (FILE * NoName, long NoName, int NoName);",
   "int = fsetpos (FILE * NoName, const fpos_t * NoName);",
   "long = ftell (FILE * NoName);",
   "int = fwrite (const void * NoName, size_t NoName, size_t NoName, FILE * NoName);",
   "int = getc (FILE * NoName);",
   "int = getchar ();",
   "char* = gets (char * NoName);",
   "void = perror (const char * NoName);",
   "int = putc (int NoName, FILE * NoName);",
   "int = putchar (int NoName);",
   "int = puts (const char * NoName);",
   "int = remove (const char * NoName);",
   "int = rename (const char * NoName, const char * NoName);",
   "void = rewind (FILE * NoName);",
   "void = setbuf (FILE * NoName, char * NoName);",
   "int = setvbuf (FILE * NoName, char * NoName, int NoName, size_t NoName);",
   "FILE* = tmpfile ();",
   "char* = tmpnam (char * NoName);",
   "int = ungetc (int NoName, FILE * NoName);",
   "int = vfprintf (FILE * NoName, const char * NoName, void * NoName);",
   "int = vprintf (const char * NoName, void * NoName);",
   "int = vsprintf (char * NoName, const char * NoName, void * NoName);",
   "FILE* = fdopen (int NoName, const char * NoName);",
   "int = fileno (FILE * NoName);",
   "void = abort ();",
   "int = abs (int __i);",
   "int = atexit (void * exit_handler);",
   "double = atof (char * __s);",
   "int = atoi (char * __s);",
   "long = atol (char * __s);",
   "void* = bsearch (void * __key, void * __base, size_t __nelem, size_t __size, void * compare_function);",
   "div_t = div (int __numer, int __denom);",
   "long = labs (long __i);",
   "div_t = ldiv (long __numer, long __denom);",
   "int = mblen (char * __s, size_t __n);",
   "size_t = mbstowcs (char * __wcs, char * __s, size_t __n);",
   "int = mbtowc (char * __pwc, char * __s, size_t __n);",
   "int = rand ();",
   "void* = srand (unsigned int __seed);",
   "int = system (char * __s);",
   "size_t = wcstombs (char * __s, char * __wcs, size_t __n);",
   "int = wctomb (char * __s, char __wchar);",
   "void* = calloc (size_t __nelem, size_t __size);",
   "void = exit (int __status);",
   "void = free (void * __ptr);",
   "char* = getenv (char * __name);",
   "void* = malloc (size_t __size);",
   "void* = realloc (void * __ptr, size_t __size);",
   "void* = memchr (void * __s, int __c, size_t __n);",
   "int = memcmp (void * __s1, void * __s2, size_t __n);",
   "void* = memcpy (void * __s1, void * __s2, size_t __n);",
   "void* = memmove (void * __s1, void * __s2, size_t __n);",
   "void* = memset (void * __s, int __c, size_t __n);",
   "char* = strcat (char * __s1, char * __s2);",
   "char* = strchr (char * __s, int __c);",
   "int = strcmp (char * __s1, char * __s2);",
   "int = strcoll (char * __s1, char * __s2);",
   "char* = strcpy (char * __s1, char * __s2);",
   "size_t = strcspn (char * __s1, char * __s2);",
   "size_t = strlen (char * __s);",
   "char* = strncat (char * __s1, char * __s2, size_t __n);",
   "int = strncmp (char * __s1, char * __s2, size_t __n);",
   "char* = strncpy (char * __s1, char * __s2, size_t __n);",
   "char* = strpbrk (char * __s1, char * __s2);",
   "char* = strrchr (char * __s, int __c);",
   "size_t = strspn (char * __s1, char * __s2);",
   "char* = strstr (char * __s1, char * __s2);",
   "char* = strtok (char * __s, char * __sep);",
   "size_t = strxfrm (char * __s1, char * __s2, size_t __n);",
   "char* = strerror (int __errcode);",
   "int = strerror_r (int __errcode, char * __buf);",
   "void = bcopy (const char * source, char * dest, int nbytes);",
   "void = bcopyBytes (char * source, char * dest, int nbytes);",
   "void = bcopyWords (char * source, char * dest, int nwords);",
   "void = bcopyLongs (char * source, char * dest, int nlongs);",
   "void = bfill (char * buf, int nbytes, int ch);",
   "void = bfillBytes (char * buf, int nbytes, int ch);",
   "void = bzero (char * buffer, int nbytes);",
   "int = bcmp (char * buf1, char * buf2, int nbytes);",
   "void = binvert (char * buf, int nbytes);",
   "void = bswap (char * buf1, char * buf2, int nbytes);",
   "void = uswab (char * source, char * destination, int nbytes);",
   "void = swab (char * source, char * dest, int nbytes);",
   "char* = index (const char * s, int c);",
   "char* = rindex (const char * s, int c);",
   "int = arpAdd (char * host, char * eaddr, int flags);",
   "int = arpDelete (char * host);",
   "int = arpCmd (int cmd, struct in_addr * pIpAddr, u_char * pHwAddr, int * pFlags);",
   "void = arpFlush ();",
   "int = bootNetmaskExtract (char * string, int * pNetmask);",
   "int = bootStructToString (char * paramString, BOOT_PARAMS * pBootParams);",
   "char* = bootStringToStruct (char * bootString, BOOT_PARAMS * pBootParams);",
   "void = bootParamsErrorPrint (char * bootString, char * pError);",
   "void = bootParamsPrompt (char * string);",
   "void = bootParamsShow (char * paramString);",
   "int = bootpParamsGet (char * ifName, int port, char * pInetAddr, char * pHostAddr, char * pBootFile, int * pSizeFile, int * pSubnet, char * pGateway, u_int timeOut);",
   "int = bootpMsgSend (char * ifName, struct in_addr * pIpDest, int port, BOOTP_MSG * pBootpMsg, u_int timeOut);",
   "u_char* = bootpTagFind (u_char * pVend, int tag, int * pSize);",
   "int = hostAdd (char * hostName, char * hostAddr);",
   "int = hostDelete (char * name, char * addr);",
   "int = hostGetByAddr (int addr, char * name);",
   "int = gethostname (char * name, int nameLen);",
   "int = hostGetByName (char * name);",
   "int = sethostname (char * name, int nameLen);",
   "void = hostTblInit ();",
   "unsigned long = inet_addr ();",
   "char* = inet_ntoa ();",
   "struct in_addr = inet_makeaddr ();",
   "unsigned long = inet_network ();",
   "NODE* = lstFirst (LIST * pList);",
   "NODE* = lstGet (LIST * pList);",
   "NODE* = lstLast (LIST * pList);",
   "NODE* = lstNStep (NODE * pNode, int nStep);",
   "NODE* = lstNext (NODE * pNode);",
   "NODE* = lstNth (LIST * pList, int nodenum);",
   "NODE* = lstPrevious (NODE * pNode);",
   "int = lstCount (LIST * pList);",
   "int = lstFind (LIST * pList, NODE * pNode);",
   "void = lstAdd (LIST * pList, NODE * pNode);",
   "void = lstConcat (LIST * pDstList, LIST * pAddList);",
   "void = lstDelete (LIST * pList, NODE * pNode);",
   "void = lstExtract (LIST * pSrcList, NODE * pStartNode, NODE * pEndNode, LIST * pDstList);",
   "void = lstFree (LIST * pList);",
   "void = lstInit (LIST * pList);",
   "void = lstInsert (LIST * pList, NODE * pPrev, NODE * pNode);",
   "int = cacheLibInit (CACHE_MODE inst, CACHE_MODE data);",
   "int = cacheArchLibInit (CACHE_MODE inst, CACHE_MODE data);",
   "int = cacheEnable (CACHE_TYPE cache);",
   "int = cacheDisable (CACHE_TYPE cache);",
   "int = cacheLock (CACHE_TYPE cache, void * adrs, size_t bytes);",
   "int = cacheUnlock (CACHE_TYPE cache, void * adrs, size_t bytes);",
   "int = cacheFlush (CACHE_TYPE cache, void * adrs, size_t bytes);",
   "int = cacheInvalidate (CACHE_TYPE cache, void * adrs, size_t bytes);",
   "int = cacheClear (CACHE_TYPE cache, void * adrs, size_t bytes);",
   "int = cacheTextUpdate (void * adrs, size_t bytes);",
   "int = cachePipeFlush ();",
   "void* = cacheDmaMalloc (size_t bytes);",
   "int = cacheDmaFree (void * pBuf);",
   "int = cacheDrvFlush (CACHE_FUNCS * pFuncs, void * adrs, size_t bytes);",
   "int = cacheDrvInvalidate (CACHE_FUNCS * pFuncs, void * adrs, size_t bytes);",
   "void* = cacheDrvVirtToPhys (CACHE_FUNCS * pFuncs, void * adrs);",
   "void* = cacheDrvPhysToVirt (CACHE_FUNCS * pFuncs, void * adrs);",
   "void = cacheFuncsSet ();",
   "int = c (int taskNameOrId, INSTR * addr, INSTR * addr1);",
   "int = s (int taskNameOrId, INSTR * addr, INSTR * addr1);",
   "void = dbgHelp ();",
   "int = dbgInit ();",
   "int = b (INSTR * addr, int taskNameOrId, int count, int quiet);",
   "int = e (INSTR * addr, event_t eventId, int taskNameOrId, void * evtRtn, int arg);",
   "int = bd (INSTR * addr, int taskNameOrId);",
   "int = bdall (int taskNameOrId);",
   "int = cret (int taskNameOrId);",
   "int = so (int taskNameOrId);",
   "void = l (INSTR * addr, int count);",
   "int = tt (int taskNameOrId);",
   "void = dbgPrintCall (INSTR * callAdrs, int funcAdrs, int nargs, int * pArgs);",
   "int = dbgBrkExists (INSTR * addr, int task);",
   "void = dbgBreakNotifyInstall (void * breakpointRtn);",
   "int = dbgStepQuiet (int task);",
   "int = bdTask (int task);",
   "DIR* = opendir (char * dirName);",
   "int = closedir (DIR * pDir);",
   "struct dirent* = readdir (DIR * pDir);",
   "void = rewinddir (DIR * pDir);",
   "int = dosFsConfigGet (DOS_VOL_DESC * vdptr, DOS_VOL_CONFIG * pConfig);",
   "int = dosFsConfigInit (DOS_VOL_CONFIG * pConfig, char mediaByte, UINT8 secPerClust, short nResrvd, char nFats, UINT16 secPerFat, short maxRootEnts, UINT nHidden, UINT options);",
   "int = dosFsConfigShow (char * devName);",
   "int = dosFsDateSet (int year, int month, int day);",
   "void = dosFsDateTimeInstall (void * pDateTimeFunc);",
   "DOS_VOL_DESC* = dosFsDevInit (char * devName, BLK_DEV * pBlkDev, DOS_VOL_CONFIG * pConfig);",
   "int = dosFsDevInitOptionsSet (UINT options);",
   "int = dosFsInit (int maxFiles);",
   "DOS_VOL_DESC* = dosFsMkfs (char * volName, BLK_DEV * pBlkDev);",
   "int = dosFsMkfsOptionsSet (UINT options);",
   "void = dosFsModeChange (DOS_VOL_DESC * vdptr, int newMode);",
   "void = dosFsReadyChange (DOS_VOL_DESC * vdptr);",
   "int = dosFsTimeSet (int hour, int minute, int second);",
   "int = dosFsVolOptionsGet (DOS_VOL_DESC * vdptr, UINT * pOptions);",
   "int = dosFsVolOptionsSet (DOS_VOL_DESC * vdptr, UINT options);",
   "int = dosFsVolUnmount (DOS_VOL_DESC * vdptr);",
   "SL_LIST* = sllCreate ();",
   "SL_NODE* = sllEach (SL_LIST * pList, void * routine, int routineArg);",
   "SL_NODE* = sllGet (SL_LIST * pList);",
   "SL_NODE* = sllPrevious (SL_LIST * pList, SL_NODE * pNode);",
   "int = sllDelete (SL_LIST * pList);",
   "int = sllInit (SL_LIST * pList);",
   "int = sllTerminate (SL_LIST * pList);",
   "int = sllCount (SL_LIST * pList);",
   "void = sllPutAtHead (SL_LIST * pList, SL_NODE * pNode);",
   "void = sllPutAtTail (SL_LIST * pList, SL_NODE * pNode);",
   "void = sllRemove (SL_LIST * pList, SL_NODE * pDeleteNode, SL_NODE * pPrevNode);",
   "int = hashKeyCmp (H_NODE_INT * pMatchHNode, H_NODE_INT * pHNode, int keyCmpArg);",
   "int = hashKeyStrCmp (H_NODE_STRING * pMatchHNode, H_NODE_STRING * pHNode, int keyCmpArg);",
   "HASH_ID = hashTblCreate (int sizeLog2, void * keyCmpRtn, void * keyRtn, int keyArg);",
   "HASH_NODE* = hashTblEach (HASH_ID hashId, void * routine, int routineArg);",
   "HASH_NODE* = hashTblFind (HASH_ID hashId, HASH_NODE * pMatchNode, int keyCmpArg);",
   "int = hashLibInit ();",
   "int = hashTblDelete (HASH_ID hashId);",
   "int = hashTblDestroy (HASH_ID hashId, int dealloc);",
   "int = hashTblInit (HASH_TBL * pHashTbl, SL_LIST * pTblMem, int sizeLog2, void * keyCmpRtn, void * keyRtn, int keyArg);",
   "int = hashTblPut (HASH_ID hashId, HASH_NODE * pHashNode);",
   "int = hashTblRemove (HASH_ID hashId, HASH_NODE * pHashNode);",
   "int = hashTblTerminate (HASH_ID hashId);",
   "int = hashFuncIterScale (int elements, H_NODE_STRING * pHNode, int seed);",
   "int = hashFuncModulo (int elements, H_NODE_INT * pHNode, int divisor);",
   "int = hashFuncMultiply (int elements, H_NODE_INT * pHNode, int multiplier);",
   "int = iosInit (int max_drivers, int max_files, char * nullDevName);",
   "void = iosShowInit ();",
   "DEV_HDR* = iosFdDevFind (int fd);",
   "DEV_HDR* = iosNextDevGet (DEV_HDR * pDev);",
   "int = iosClose (int fd);",
   "int = iosDevAdd (DEV_HDR * pDevHdr, char * name, int drvnum);",
   "int = iosDrvRemove (int drvnum, int forceClose);",
   "int = iosCreate (DEV_HDR * pDevHdr, char * fileName, int mode);",
   "int = iosDelete (DEV_HDR * pDevHdr, char * fileName);",
   "int = iosDrvInstall (void * pCreate, void * pDelete, void * pOpen, void * pClose, void * pRead, void * pWrite, void * pIoctl);",
   "int = iosFdNew (DEV_HDR * pDevHdr, char * name, int value);",
   "int = iosFdValue (int fd);",
   "int = iosIoctl (int fd, int function, int arg);",
   "int = iosOpen (DEV_HDR * pDevHdr, char * fileName, int flags, int mode);",
   "int = iosRead (int fd, char * buffer, int maxbytes);",
   "int = iosWrite (int fd, char * buffer, int nbytes);",
   "void = iosDevDelete (DEV_HDR * pDevHdr);",
   "void = iosDevShow ();",
   "void = iosDrvShow ();",
   "void = iosFdFree (int fd);",
   "void = iosFdSet (int fd, DEV_HDR * pDevHdr, char * name, int value);",
   "void = iosFdShow ();",
   "DL_LIST* = dllCreate ();",
   "DL_NODE* = dllEach (DL_LIST * pList, void * routine, int routineArg);",
   "DL_NODE* = dllGet (DL_LIST * pList);",
   "int = dllDelete (DL_LIST * pList);",
   "int = dllInit (DL_LIST * pList);",
   "int = dllTerminate (DL_LIST * pList);",
   "int = dllCount (DL_LIST * pList);",
   "void = dllAdd (DL_LIST * pList, DL_NODE * pNode);",
   "void = dllInsert (DL_LIST * pList, DL_NODE * pPrev, DL_NODE * pNode);",
   "void = dllRemove (DL_LIST * pList, DL_NODE * pNode);",
   "Q_FIFO_HEAD* = qFifoCreate ();",
   "Q_FIFO_NODE* = qFifoGet (Q_FIFO_HEAD * pQFifoHead);",
   "int = qFifoDelete (Q_FIFO_HEAD * pQFifoHead);",
   "int = qFifoInit (Q_FIFO_HEAD * pQFifoHead);",
   "int = qFifoInfo (Q_FIFO_HEAD * pQFifoHead, int * nodeArray, int maxNodes);",
   "void = qFifoPut (Q_FIFO_HEAD * pQFifoHead, Q_FIFO_NODE * pQFifoNode, ULONG key);",
   "int = qFifoRemove (Q_FIFO_HEAD * pQFifoHead, Q_FIFO_NODE * pQFifoNode);",
   "Q_FIFO_NODE* = qFifoEach (Q_FIFO_HEAD * pQHead, void * routine, int routineArg);",
   "int = semGive (SEM_ID semId);",
   "int = semTake (SEM_ID semId, int timeout);",
   "int = semFlush (SEM_ID semId);",
   "int = semDelete (SEM_ID semId);",
   "int = semInfo (SEM_ID semId, int * idList, int maxTasks);",
   "int = semBLibInit ();",
   "SEM_ID = semBCreate (int options, SEM_B_STATE initialState);",
   "int = semCLibInit ();",
   "SEM_ID = semCCreate (int options, int initialCount);",
   "int = semMLibInit ();",
   "SEM_ID = semMCreate (int options);",
   "int = semMGiveForce (SEM_ID semId);",
   "int = semOLibInit ();",
   "SEM_ID = semCreate ();",
   "void = semShowInit ();",
   "int = semShow (SEM_ID semId, int level);",
   "int = envLibInit ();",
   "int = envPrivateCreate ();",
   "int = envPrivateDestroy ();",
   "int = putenv ();",
   "void = envShow ();",
   "int = errnoOfTaskSet (int taskId, int errorValue);",
   "int = errnoSet (int errorValue);",
   "int = errnoGet ();",
   "int = errnoOfTaskGet (int taskId);",
   "int = etherAddrResolve (struct ifnet * pIf, char * targetAddr, char * eHdr, int numTries, int numTicks);",
   "int = etherInputHookAdd (void * inputHook);",
   "int = etherOutput (struct ifnet * pIf, struct ether_header * pEtherHeader, char * pData, int dataLength);",
   "int = etherOutputHookAdd (void * outputHook);",
   "void = etherInputHookDelete ();",
   "void = etherOutputHookDelete ();",
   "int = evtBufferIsEmpty ();",
   "char* = evtBufferAddress ();",
   "int = evtBufferToFile (char * filename);",
   "void = evtBufferUpLoad ();",
   "int = excVecInit ();",
   "int = excShowInit ();",
   "int = excInit ();",
   "void = excHookAdd (void * excepHook);",
   "void = excTask ();",
   "int = excJobAdd (VOIDFUNCPTR func, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6);",
   "int = ftpLogin (int ctrlSock, char * user, char * passwd, char * account);",
   "int = ftpXfer (char * host, char * user, char * passwd, char * acct, char * cmd, char * dirname, char * filename, int * pCtrlSock, int * pDataSock);",
   "int = ftpCommand (int ctrlSock, char * fmt, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6);",
   "int = ftpDataConnGet (int dataSock);",
   "int = ftpDataConnInit (int ctrlSock);",
   "int = ftpHookup (char * host);",
   "int = ftpReplyGet (int ctrlSock, int expecteof);",
   "int = ftpdInit (int stackSize);",
   "int = ftpdTask ();",
   "void = ftpdDelete ();",
   "int = ifAddrSet (char * interfaceName, char * interfaceAddress);",
   "int = ifAddrGet (char * interfaceName, char * interfaceAddress);",
   "int = ifBroadcastSet (char * interfaceName, char * broadcastAddress);",
   "int = ifBroadcastGet (char * interfaceName, char * broadcastAddress);",
   "int = ifDstAddrSet (char * interfaceName, char * dstAddress);",
   "int = ifDstAddrGet (char * interfaceName, char * dstAddress);",
   "int = ifMaskSet (char * interfaceName, int netMask);",
   "int = ifMaskGet (char * interfaceName, int * netMask);",
   "int = ifFlagChange (char * interfaceName, int flags, int on);",
   "int = ifFlagSet (char * interfaceName, int flags);",
   "int = ifFlagGet (char * interfaceName, int * flags);",
   "int = ifMetricSet (char * interfaceName, int metric);",
   "int = ifMetricGet (char * interfaceName, int * pMetric);",
   "int = ifRouteDelete (char * ifName, int unit);",
   "struct ifnet* = ifunit (char * ifname);",
   "int = bpattach (int unit, char * pAnchor, int procNum, int intType, int intArg1, int intArg2, int intArg3);",
   "int = bpInit (char * pAnchor, char * pMem, int memSize, int tasOK);",
   "void = bpShow (char * bpName, int zero);",
   "int = slipInit (int unit, char * devName, char * myAddr, char * peerAddr, int baud, int compressEnable, int compressAllow, int mtu);",
   "int = slipBaudSet (int unit, int baud);",
   "int = intConnect (void ** vector, void * routine, int parameter);",
   "void* = intHandlerCreate (void * routine, int parameter);",
   "void = intLockLevelSet (int newLevel);",
   "int = intLockLevelGet ();",
   "int = intContext ();",
   "int = intCount ();",
   "void = intVecBaseSet (void ** baseAddr);",
   "void** = intVecBaseGet ();",
   "void = intVecSet (void ** vector, void * function);",
   "void* = intVecGet (void ** vector);",
   "int = intLevelSet (int level);",
   "int = intLock ();",
   "int = intUnlock (int oldSR);",
   "int = intVecTableWriteProtect ();",
   "int = intCRGet ();",
   "void = intCRSet (int value);",
   "int = intSRGet ();",
   "int = intSRSet (int value);",
   "void = intAckConfig ();",
   "void = intTBRSet (void ** baseAddr);",
   "int = intVecTableWriteEnable ();",
   "void* = intHandlerCreateAm29k (void ** vector, void * routine, int parameter);",
   "int = am29200Intr3DeMuxConnect (VOIDFUNCPTR deMuxFct, int parameter);",
   "int = intDisable (int NoName);",
   "int = intEnable (int NoName);",
   "MODULE_ID = loadModule (int fd, int symFlag);",
   "MODULE_ID = loadModuleGet (char * fileName, int format, int * symFlag);",
   "void = addSegNames (int fd, char * pText, char * pData, char * pBss, SYMTAB_ID symTbl, UINT16 group);",
   "int = loadSegmentsAllocate (SEG_INFO * pSeg);",
   "int = loginDefaultEncrypt (char * in, char * out);",
   "int = loginPrompt (char * userName);",
   "int = loginUserAdd (char * name, char * passwd);",
   "int = loginUserDelete (char * name, char * passwd);",
   "int = loginUserVerify (char * name, char * passwd);",
   "void = loginEncryptInstall (void * rtn, int var);",
   "void = loginInit ();",
   "void = loginStringSet (char * newString);",
   "void = loginUserShow ();",
   "int = logFdAdd (int fd);",
   "int = logFdDelete (int fd);",
   "int = logInit (int fd, int maxMsgs);",
   "int = logMsg (char * fmt, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6);",
   "void = logFdSet (int fd);",
   "void = logShow ();",
   "void = logTask ();",
   "int = memDrv ();",
   "int = memDevCreate (char * name, char * base, int length);",
   "int = memInit (char * pPool, unsigned int poolSize);",
   "int = memPartLibInit (char * pPool, unsigned int poolSize);",
   "PART_ID = memPartCreate (char * pPool, unsigned int poolSize);",
   "void = memPartInit (PART_ID partId, char * pPool, unsigned int poolSize);",
   "int = memPartAddToPool (PART_ID partId, char * pPool, unsigned int poolSize);",
   "void = memAddToPool (char * pPool, unsigned int poolSize);",
   "void* = memPartAlloc (PART_ID partId, unsigned int nBytes);",
   "void* = memPartAlignedAlloc (PART_ID partId, unsigned int nBytes, unsigned int alignment);",
   "void* = memalign (unsigned int alignment, unsigned int size);",
   "void* = valloc (unsigned int size);",
   "int = memPartFree (PART_ID partId, char * pBlock);",
   "int = memPartOptionsSet (PART_ID partId, unsigned int options);",
   "int = memFindMax ();",
   "int = memPartFindMax (PART_ID partId);",
   "void* = memPartRealloc (PART_ID partId, char * pBlock, unsigned int nBytes);",
   "void = memOptionsSet (unsigned int options);",
   "int = cfree (char * pBlock);",
   "void = memShowInit ();",
   "void = memShow (int type);",
   "int = memPartShow (PART_ID partId, int type);",
   "int = memPartInfoGet (PART_ID partId, MEM_PART_STATS * ppartStats);",
   "int = moduleLibInit ();",
   "MODULE_ID = moduleCreate (char * name, int format, int flags);",
   "int = moduleInit (MODULE_ID moduleId, char * name, int format, int flags);",
   "int = moduleTerminate (MODULE_ID moduleId);",
   "int = moduleDelete (MODULE_ID moduleId);",
   "MODULE_ID = moduleIdFigure (void * moduleNameOrId);",
   "int = moduleShow (char * moduleNameOrId, int options);",
   "int = moduleSegAdd (MODULE_ID moduleId, int type, void * location, int length, int flags);",
   "SEGMENT_ID = moduleSegGet (MODULE_ID moduleId);",
   "SEGMENT_ID = moduleSegFirst (MODULE_ID moduleId);",
   "SEGMENT_ID = moduleSegNext (SEGMENT_ID segmentId);",
   "SEGMENT_ID = moduleSegEach (MODULE_ID moduleId, void * routine, int userArg);",
   "int = moduleCreateHookAdd (void * moduleCreateHookRtn);",
   "int = moduleCreateHookDelete (void * moduleCreateHookRtn);",
   "MODULE_ID = moduleFindByName (char * moduleName);",
   "MODULE_ID = moduleFindByNameAndPath (char * moduleName, char * pathName);",
   "MODULE_ID = moduleFindByGroup (int groupNumber);",
   "MODULE_ID = moduleEach (void * routine, int userArg);",
   "int = moduleIdListGet (MODULE_ID * idList, int maxModules);",
   "int = moduleInfoGet (MODULE_ID moduleId, MODULE_INFO * pModuleInfo);",
   "char* = moduleNameGet (MODULE_ID moduleId);",
   "int = moduleFlagsGet (MODULE_ID moduleId);",
   "int = moduleCheck (int options);",
   "int = mountdInit (int priority, int stackSize, void * authHook, int nExports, int options);",
   "void = mountd ();",
   "int = nfsExport (char * directory, int id, int mode, int options);",
   "int = nfsUnexport (char * dirName);",
   "NFS_EXPORT_ENTRY* = nfsExportFindByName (char * dirName);",
   "NFS_EXPORT_ENTRY* = nfsExportFindById (int volumeId);",
   "int = fdToInode (int fd);",
   "int = nameToInode (char * fileName);",
   "int = mq_close (mqd_t NoName);",
   "int = mq_unlink (const char * NoName);",
   "int = mq_send (mqd_t handle, const void * NoName, size_t NoName, int NoName);",
   "int = mq_receive (mqd_t handle, void * NoName, size_t NoName, int * NoName);",
   "int = mq_notify (mqd_t handle, struct sigevent * NoName);",
   "int = mq_setattr (mqd_t handle, struct mq_attr * NoName, struct mq_attr * NoName);",
   "int = mq_getattr (mqd_t handle, struct mq_attr * NoName);",
   "int = msgQLibInit ();",
   "MSG_Q_ID = msgQCreate (int maxMsgs, int maxMsgLength, int options);",
   "int = msgQDelete (MSG_Q_ID msgQId);",
   "int = msgQSend (MSG_Q_ID msgQId, char * buffer, UINT nBytes, int timeout, int priority);",
   "int = msgQReceive (MSG_Q_ID msgQId, char * buffer, UINT maxNBytes, int timeout);",
   "int = msgQInfoGet (MSG_Q_ID msgQId, MSG_Q_INFO * pInfo);",
   "int = msgQNumMsgs (MSG_Q_ID msgQId);",
   "void = msgQShowInit ();",
   "int = msgQShow (MSG_Q_ID msgQId, int level);",
   "MSG_Q_ID = msgQSmCreate (int maxMsgs, int maxMsgLength, int options);",
   "void = msgQSmShowInit ();",
   "void = arptabShow ();",
   "void = arpShow ();",
   "void = icmpstatShow ();",
   "void = ifShow (char * ifName);",
   "void = inetstatShow ();",
   "void = ipstatShow (int zero);",
   "void = mbufShow ();",
   "void = netShowInit ();",
   "void = tcpDebugShow (int numPrint, int verbose);",
   "void = tcpstatShow ();",
   "void = udpstatShow ();",
   "void = routeShow ();",
   "void = hostShow ();",
   "int = nfsdInit (int nServers, int nExportedFs, int priority, void * authHook, void * mountAuthHook, int options);",
   "void = nfsdRequestProcess ();",
   "void = nfsd ();",
   "int = nfsdStatusGet (NFS_SERVER_STATUS * serverStats);",
   "int = nfsdStatusShow (int options);",
   "int = nfsdFhCreate (NFS_FILE_HANDLE * parentDir, char * fileName, NFS_FILE_HANDLE * fh);",
   "int = nfsdFhToName (NFS_FILE_HANDLE * fh, char * fileName);",
   "int = nfsdFattrGet (NFS_FILE_HANDLE * fh, struct fattr * fileAttributes);",
   "void = nfsdFhHton (NFS_FILE_HANDLE * fh);",
   "void = nfsdFhNtoh (NFS_FILE_HANDLE * fh);",
   "int = nfsExportShow (char * hostName);",
   "void = nfsAuthUnixGet (char * machname, int * pUid, int * pGid, int * pNgids, int * gids);",
   "void = nfsAuthUnixSet (char * machname, int uid, int gid, int ngids, int * aup_gids);",
   "void = nfsAuthUnixPrompt ();",
   "void = nfsAuthUnixShow ();",
   "void = nfsHelp ();",
   "void = nfsIdSet (int uid);",
   "int = nfsDrv ();",
   "int = nfsMount (char * host, char * fileSystem, char * localName);",
   "int = nfsMountAll (char * host, char * clientName, int quiet);",
   "void = nfsDevShow ();",
   "int = nfsUnmount (char * localName);",
   "int = nfsDevListGet (unsigned long * nfsDevList, int listSize);",
   "int = nfsDevInfoGet (unsigned long nfsDevHandle, NFS_DEV_INFO * pnfsInfo);",
   "int = pingLibInit ();",
   "int = ping (char * host, int numPackets, ULONG options);",
   "int = pipeDevCreate (char * name, int nMessages, int nBytes);",
   "int = pipeDrv ();",
   "int = proxyArpLibInit (int clientSizeLog2, int portSizeLog2);",
   "void = proxyPortShow ();",
   "int = proxyPortFwdOn (int port);",
   "int = proxyPortFwdOff (int port);",
   "int = proxyNetCreate (char * proxyAddr, char * mainAddr);",
   "int = proxyNetDelete (char * proxyAddr);",
   "int = proxyClientAdd (struct in_addr * pProxyNetAddr, struct in_addr * pClientAddr);",
   "int = proxyClientDelete (struct in_addr * pClientAddr);",
   "int = proxyReg (char * ifName, char * proxyAddr);",
   "int = proxyUnreg (char * ifName, char * proxyAddr);",
   "int = ramDrv ();",
   "BLK_DEV* = ramDevCreate (char * ramAddr, int bytesPerSec, int secPerTrack, int nSectors, int secOffset);",
   "int = rebootHookAdd (void * rebootHook);",
   "void = reboot (int startType);",
   "int = bindresvport (int sd, struct sockaddr_in * sin);",
   "int = iam (char * newUser, char * newPasswd);",
   "int = remCurIdSet (char * newUser, char * newPasswd);",
   "int = rcmd (char * host, int remotePort, char * localUser, char * remoteUser, char * cmd, int * fd2p);",
   "int = rresvport (int * alport);",
   "void = remCurIdGet (char * user, char * passwd);",
   "void = whoami ();",
   "int = rlogInit ();",
   "int = rlogin (char * host);",
   "void = rlogChildTask ();",
   "void = rlogInTask (int sock, int ptyMfd);",
   "void = rlogOutTask (int sock, int ptyMfd);",
   "void = rlogind ();",
   "int = rngIsEmpty (RING_ID ringId);",
   "int = rngIsFull (RING_ID ringId);",
   "RING_ID = rngCreate (int nbytes);",
   "int = rngBufGet (RING_ID rngId, char * buffer, int maxbytes);",
   "int = rngBufPut (RING_ID rngId, char * buffer, int nbytes);",
   "int = rngFreeBytes (RING_ID ringId);",
   "int = rngNBytes (RING_ID ringId);",
   "void = rngDelete (RING_ID ringId);",
   "void = rngFlush (RING_ID ringId);",
   "void = rngMoveAhead (RING_ID ringId, int n);",
   "void = rngPutAhead (RING_ID ringId, char byte, int offset);",
   "int = routeAdd (char * destination, char * gateway);",
   "int = routeDelete (char * destination, char * gateway);",
   "int = routeNetAdd (char * destination, char * gateway);",
   "int = routeCmd (int destInetAddr, int gateInetAddr, int ioctlCmd);",
   "SEM_ID = semBSmCreate (int options, SEM_B_STATE initialState);",
   "SEM_ID = semCSmCreate (int options, int initialCount);",
   "void = semSmShowInit ();",
   "PART_ID = memPartSmCreate (char * pPool, unsigned int poolSize);",
   "int = smMemFree (void * ptr);",
   "int = smMemFindMax ();",
   "void* = smMemMalloc (unsigned int nBytes);",
   "void* = smMemCalloc (int elemNum, int elemSize);",
   "void* = smMemRealloc (void * pBlock, unsigned int newSize);",
   "int = smMemAddToPool (char * pPool, unsigned int poolSize);",
   "int = smMemOptionsSet (unsigned int options);",
   "void = smMemShowInit ();",
   "void = smMemShow (int type);",
   "int = smNameAdd (char * name, void * value, int type);",
   "int = smNameFind (char * name, void ** pValue, int * pType, int waitType);",
   "int = smNameFindByValue (void * value, char * name, int * pType, int waitType);",
   "int = smNameRemove (char * name);",
   "void = smNameShowInit ();",
   "int = smNameShow (int level);",
   "int = smObjLibInit ();",
   "void* = smObjLocalToGlobal (void * localAdrs);",
   "void* = smObjGlobalToLocal (void * globalAdrs);",
   "void = smObjTimeoutLogEnable (int timeoutLogEnable);",
   "void = smObjShowInit ();",
   "int = smObjShow ();",
   "int = sockLibInit (int fdMax);",
   "int = sockLibAdd (void * sockLibInitRtn, int domainMap, int domainReal);",
   "int = bind (int s, struct sockaddr * name, int namelen);",
   "int = connect (int s, struct sockaddr * name, int namelen);",
   "int = connectWithTimeout (int sock, struct sockaddr * adrs, int adrsLen, struct timeval * timeVal);",
   "int = getpeername (int s, struct sockaddr * name, int * namelen);",
   "int = getsockname (int s, struct sockaddr * name, int * namelen);",
   "int = getsockopt (int s, int level, int optname, char * optval, int * optlen);",
   "int = listen (int s, int backlog);",
   "int = setsockopt (int s, int level, int optname, char * optval, int optlen);",
   "int = shutdown (int s, int how);",
   "int = accept (int s, struct sockaddr * addr, int * addrlen);",
   "int = recv (int s, char * buf, int bufLen, int flags);",
   "int = recvfrom (int s, char * buf, int bufLen, int flags, struct sockaddr * from, int * pFromLen);",
   "int = recvmsg (int sd, struct msghdr * mp, int flags);",
   "int = send (int s, char * buf, int bufLen, int flags);",
   "int = sendmsg (int sd, struct msghdr * mp, int flags);",
   "int = sendto (int s, caddr_t buf, int bufLen, int flags, struct sockaddr * to, int tolen);",
   "int = socket (int domain, int type, int protocol);",
   "void = spyLibInit ();",
   "int = spyClkStartCommon (int intsPerSec, void * printRtn);",
   "void = spyCommon (int freq, int ticksPerSec, void * printRtn);",
   "void = spyClkStopCommon ();",
   "void = spyReportCommon (void * printRtn);",
   "void = spyStopCommon ();",
   "void = spyComTask (int freq, void * printRtn);",
   "int = symLibInit ();",
   "SYMBOL* = symEach (SYMTAB_ID symTblId, void * routine, int routineArg);",
   "char* = symName (SYMTAB_ID symTbl, char * value);",
   "void = symShowInit ();",
   "int = symShow (SYMTAB_ID pSymTbl, char * substr);",
   "int = symTblDelete (SYMTAB_ID symTblId);",
   "int = symTblTerminate (SYMTAB_ID symTblId);",
   "int = symTblDestroy (SYMTAB_ID symTblId, int dealloc);",
   "int = symFree (SYMTAB_ID symTblId, SYMBOL * pSymbol);",
   "int = symSAdd (SYMTAB_ID symTblId, char * name, char * value, SYM_TYPE type, UINT16 group);",
   "int = symAdd (SYMTAB_ID symTblId, char * name, char * value, SYM_TYPE type, UINT16 group);",
   "int = symTblAdd (SYMTAB_ID symTblId, SYMBOL * pSymbol);",
   "int = symRemove (SYMTAB_ID symTblId, char * name, SYM_TYPE type);",
   "int = symTblRemove (SYMTAB_ID symTblId, SYMBOL * pSymbol);",
   "int = symInit (SYMBOL * pSymbol, char * name, char * value, SYM_TYPE type, UINT16 group);",
   "SYMBOL* = symAlloc (SYMTAB_ID symTblId, char * name, char * value, SYM_TYPE type, UINT16 group);",
   "int = symTblInit (SYMTAB_ID pSymTbl, int sameNameOk, PART_ID symPartId, HASH_ID symHashTblId);",
   "SYMTAB_ID = symTblCreate (int hashSizeLog2, int sameNameOk, PART_ID symPartId);",
   "int = symFindSymbol (SYMTAB_ID symTblId, char * name, SYM_TYPE type, SYM_TYPE mask, SYMBOL ** ppSymbol);",
   "int = symFindByValue (SYMTAB_ID symTblId, UINT value, char * name, int * pValue, SYM_TYPE * pType);",
   "int = symFindByValueAndType (SYMTAB_ID symTblId, UINT value, char * name, int * pValue, SYM_TYPE * pType, SYM_TYPE sType, SYM_TYPE mask);",
   "char* = sysModel ();",
   "char* = sysBspRev ();",
   "char* = sysMemTop ();",
   "char* = sysPhysMemTop ();",
   "int = sysToMonitor (int startType);",
   "int = sysProcNumGet ();",
   "void = sysProcNumSet (int procNum);",
   "int = sysBusTas (char * adrs);",
   "int = sysNvRamGet (char * string, int strLen, int offset);",
   "int = sysNvRamSet (char * string, int strLen, int offset);",
   "void = sysSerialReset ();",
   "int = sysBusIntAck (int intLevel);",
   "int = sysBusIntGen (int level, int vector);",
   "int = sysMailboxConnect (void * routine, int arg);",
   "int = sysMailboxEnable (char * mailboxAdrs);",
   "void = taskHookInit ();",
   "int = taskCreateHookAdd (void * createHook);",
   "int = taskCreateHookDelete (void * createHook);",
   "int = taskDeleteHookAdd (void * deleteHook);",
   "int = taskDeleteHookDelete (void * deleteHook);",
   "int = taskSwapHookAdd (void * swapHook);",
   "int = taskSwapHookAttach (void * swapHook, int tid, int in, int out);",
   "int = taskSwapHookDelete (void * swapHook);",
   "int = taskSwapHookDetach (void * swapHook, int tid, int in, int out);",
   "int = taskSwitchHookAdd (void * switchHook);",
   "int = taskSwitchHookDelete (void * switchHook);",
   "void = taskHookShowInit ();",
   "void = taskCreateHookShow ();",
   "void = taskDeleteHookShow ();",
   "void = taskSwapHookShow ();",
   "void = taskSwitchHookShow ();",
   "int = taskSpawn (char * name, int priority, int options, int stackSize, void * entryPt, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10);",
   "int = taskInit (WIND_TCB_ID pTcb, char * name, int priority, int options, char * pStackBase, int stackSize, void * entryPt, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8, int arg9, int arg10);",
   "int = taskActivate (int tid);",
   "int = taskDelete (int tid);",
   "int = taskDeleteForce (int tid);",
   "int = taskSuspend (int tid);",
   "int = taskResume (int tid);",
   "int = taskRestart (int tid);",
   "int = taskPrioritySet (int tid, int newPriority);",
   "int = taskPriorityGet (int tid, int * pPriority);",
   "int = taskLock ();",
   "int = taskUnlock ();",
   "int = taskSafe ();",
   "int = taskUnsafe ();",
   "int = taskDelay (int ticks);",
   "int = taskOptionsSet (int tid, int mask, int newOptions);",
   "int = taskOptionsGet (int tid, int * pOptions);",
   "char* = taskName (int tid);",
   "int = taskNameToId (char * name);",
   "int = taskIdVerify (int tid);",
   "int = taskIdSelf ();",
   "int = taskIdDefault (int tid);",
   "int = taskIsReady (int tid);",
   "int = taskIsSuspended (int tid);",
   "WIND_TCB_ID = taskTcb (int tid);",
   "int = taskIdListGet (int * idList, int maxTasks);",
   "int = taskInfoGet (int tid, TASK_DESC * pTaskDesc);",
   "int = taskStatusString (int tid, char * pString);",
   "int = taskOptionsString (int tid, char * pString);",
   "void = taskRegsShow (int tid);",
   "void* = taskStackAllot (int tid, unsigned int nBytes);",
   "void = taskShowInit ();",
   "int = taskShow (int tid, int level);",
   "int = taskVarAdd (int tid, int * pVar);",
   "int = taskVarDelete (int tid, int * pVar);",
   "int = taskVarInit ();",
   "int = taskVarSet (int tid, int * pVar, int value);",
   "int = taskVarGet (int tid, int * pVar);",
   "int = taskVarInfo (int tid, TASK_VAR * varList, int maxVars);",
   "void = tickAnnounce ();",
   "void = tickSet (ULONG ticks);",
   "ULONG = tickGet ();",
   "void = timex (void * func, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);",
   "void = timexClear ();",
   "void = timexFunc (int i, void * func, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);",
   "void = timexHelp ();",
   "void = timexInit ();",
   "void = timexN (void * func, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);",
   "void = timexPost (int i, void * func, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);",
   "void = timexPre (int i, void * func, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);",
   "void = timexShow ();",
   "int = unld (void * name, int options);",
   "int = unldByNameAndPath (char * name, char * path, int options);",
   "int = unldByGroup (UINT16 group, int options);",
   "int = unldByModuleId (MODULE_ID moduleId, int options);",
   "MODULE_ID = reld (void * nameOrId, int options);",
   "void = help ();",
   "void = netHelp ();",
   "void = bootChange ();",
   "void = periodRun (int sec, void * rtn, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName);",
   "int = period (int secs, void * func, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName);",
   "void = repeatRun (int n, void * func, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName);",
   "int = repeat (int n, void * func, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName);",
   "int = sp (void * func, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName, int NoName);",
   "int = taskIdFigure (int taskNameOrId);",
   "void = checkStack (int taskNameOrId);",
   "void = i (int taskNameOrId);",
   "void = ts (int taskNameOrId);",
   "void = tr (int taskNameOrId);",
   "void = td (int taskNameOrId);",
   "void = ti (int taskNameOrId);",
   "void = version ();",
   "void = m (void * adrs, int width);",
   "void = d (void * adrs, int nwords, int width);",
   "int = cd (char * name);",
   "void = pwd ();",
   "int = copy (char * in, char * out);",
   "int = copyStreams (int inFd, int outFd);",
   "int = diskFormat (char * devName);",
   "int = diskInit (char * devName);",
   "int = squeeze (char * devName);",
   "MODULE_ID = ld (int syms, int noAbort, char * name);",
   "int = ls (char * dirName, int doLong);",
   "int = ll (char * dirName);",
   "int = lsOld (char * dirName);",
   "int = rm (char * fileName);",
   "void = devs ();",
   "void = lkup (char * substr);",
   "void = lkAddr (unsigned int addr);",
   "int = mRegs (char * regName, int taskNameOrId);",
   "void = printErrno (int errNo);",
   "void = printLogo ();",
   "void = logout ();",
   "void = h (int size);",
   "int = pc (int task);",
   "void = show (int objId, int level);",
   "int = spyClkStart (int intsPerSec);",
   "void = spyClkStop ();",
   "void = spy (int freq, int ticksPerSec);",
   "void = spyStop ();",
   "void = spyHelp ();",
   "void = spyReport ();",
   "void = spyTask (int freq);",
   "int = sysMemProbe (char * adrs);",
   "int = vxMemProbe (char * adrs, int mode, int length, char * pVal);",
   "int = vxTas (void * address);",
   "int = wdLibInit ();",
   "WDOG_ID = wdCreate ();",
   "int = wdDelete (WDOG_ID wdId);",
   "int = wdStart (WDOG_ID wdId, int delay, void * pRoutine, int parameter);",
   "int = wdCancel (WDOG_ID wdId);",
   "void = wdShowInit ();",
   "int = wdShow (WDOG_ID wdId);",
   "int = wvEvtLogEnable (int category);",
   "int = wvEvtLogDisable ();",
   "void = wvOn (int category);",
   "void = wvOff ();",
   "void = wvEvtLogStop ();",
   "void = wvEvtTaskInit (int stackSize, int priority);",
   "void* = wvInstInit (char * buffer, size_t bufferSize, int option);",
   "void = wvLibInit ();",
   "int = wvObjInstModeSet (int mode);",
   "int = wvObjInst (int objType, void * objId, int evtLoggingOn);",
   "int = wvSigInst (int mode);",
   "int = wvHostInfoInit (char * ipAddress, unsigned int port);",
   "int = wvServerInit (int serverStackSize, int serverPriority);",
   "int = customInit (Tcl_Interp * interp);",
 NULL
 }; // end of helpCmd array
 static char *nameCmd[] = {
   "utime",
   "raise",
   "kill",
   "sigemptyset",
   "sigfillset",
   "sigaddset",
   "sigdelset",
   "sigismember",
   "sigaction",
   "sigprocmask",
   "sigpending",
   "sigsuspend",
   "sigwait",
   "sigwaitinfo",
   "sigtimedwait",
   "sigqueue",
   "_clocks_per_sec",
   "asctime",
   "clock",
   "ctime",
   "difftime",
   "gmtime",
   "localtime",
   "mktime",
   "strftime",
   "time",
   "clock_gettime",
   "clock_settime",
   "clock_getres",
   "timer_create",
   "timer_delete",
   "timer_gettime",
   "timer_settime",
   "timer_getoverrun",
   "timer_connect",
   "timer_cancel",
   "timer_show",
   "nanosleep",
   "aio_read",
   "aio_write",
   "lio_listio",
   "aio_error",
   "aio_return",
   "aio_cancel",
   "aio_suspend",
   "aioPxLibInit",
   "aioShow",
   "clearerr",
   "fclose",
   "feof",
   "ferror",
   "fflush",
   "fgetc",
   "fgetpos",
   "fgets",
   "fopen",
   "fputc",
   "fputs",
   "fread",
   "freopen",
   "fseek",
   "fsetpos",
   "ftell",
   "fwrite",
   "getc",
   "getchar",
   "gets",
   "perror",
   "putc",
   "putchar",
   "puts",
   "remove",
   "rename",
   "rewind",
   "setbuf",
   "setvbuf",
   "tmpfile",
   "tmpnam",
   "ungetc",
   "vfprintf",
   "vprintf",
   "vsprintf",
   "fdopen",
   "fileno",
   "abort",
   "abs",
   "atexit",
   "atof",
   "atoi",
   "atol",
   "bsearch",
   "div",
   "labs",
   "ldiv",
   "mblen",
   "mbstowcs",
   "mbtowc",
   "rand",
   "srand",
   "system",
   "wcstombs",
   "wctomb",
   "calloc",
   "exit",
   "free",
   "getenv",
   "malloc",
   "realloc",
   "memchr",
   "memcmp",
   "memcpy",
   "memmove",
   "memset",
   "strcat",
   "strchr",
   "strcmp",
   "strcoll",
   "strcpy",
   "strcspn",
   "strlen",
   "strncat",
   "strncmp",
   "strncpy",
   "strpbrk",
   "strrchr",
   "strspn",
   "strstr",
   "strtok",
   "strxfrm",
   "strerror",
   "strerror_r",
   "bcopy",
   "bcopyBytes",
   "bcopyWords",
   "bcopyLongs",
   "bfill",
   "bfillBytes",
   "bzero",
   "bcmp",
   "binvert",
   "bswap",
   "uswab",
   "swab",
   "index",
   "rindex",
   "arpAdd",
   "arpDelete",
   "arpCmd",
   "arpFlush",
   "bootNetmaskExtract",
   "bootStructToString",
   "bootStringToStruct",
   "bootParamsErrorPrint",
   "bootParamsPrompt",
   "bootParamsShow",
   "bootpParamsGet",
   "bootpMsgSend",
   "bootpTagFind",
   "hostAdd",
   "hostDelete",
   "hostGetByAddr",
   "gethostname",
   "hostGetByName",
   "sethostname",
   "hostTblInit",
   "inet_addr",
   "inet_ntoa",
   "inet_makeaddr",
   "inet_network",
   "lstFirst",
   "lstGet",
   "lstLast",
   "lstNStep",
   "lstNext",
   "lstNth",
   "lstPrevious",
   "lstCount",
   "lstFind",
   "lstAdd",
   "lstConcat",
   "lstDelete",
   "lstExtract",
   "lstFree",
   "lstInit",
   "lstInsert",
   "cacheLibInit",
   "cacheArchLibInit",
   "cacheEnable",
   "cacheDisable",
   "cacheLock",
   "cacheUnlock",
   "cacheFlush",
   "cacheInvalidate",
   "cacheClear",
   "cacheTextUpdate",
   "cachePipeFlush",
   "cacheDmaMalloc",
   "cacheDmaFree",
   "cacheDrvFlush",
   "cacheDrvInvalidate",
   "cacheDrvVirtToPhys",
   "cacheDrvPhysToVirt",
   "cacheFuncsSet",
   "c",
   "s",
   "dbgHelp",
   "dbgInit",
   "b",
   "e",
   "bd",
   "bdall",
   "cret",
   "so",
   "l",
   "tt",
   "dbgPrintCall",
   "dbgBrkExists",
   "dbgBreakNotifyInstall",
   "dbgStepQuiet",
   "bdTask",
   "opendir",
   "closedir",
   "readdir",
   "rewinddir",
   "dosFsConfigGet",
   "dosFsConfigInit",
   "dosFsConfigShow",
   "dosFsDateSet",
   "dosFsDateTimeInstall",
   "dosFsDevInit",
   "dosFsDevInitOptionsSet",
   "dosFsInit",
   "dosFsMkfs",
   "dosFsMkfsOptionsSet",
   "dosFsModeChange",
   "dosFsReadyChange",
   "dosFsTimeSet",
   "dosFsVolOptionsGet",
   "dosFsVolOptionsSet",
   "dosFsVolUnmount",
   "sllCreate",
   "sllEach",
   "sllGet",
   "sllPrevious",
   "sllDelete",
   "sllInit",
   "sllTerminate",
   "sllCount",
   "sllPutAtHead",
   "sllPutAtTail",
   "sllRemove",
   "hashKeyCmp",
   "hashKeyStrCmp",
   "hashTblCreate",
   "hashTblEach",
   "hashTblFind",
   "hashLibInit",
   "hashTblDelete",
   "hashTblDestroy",
   "hashTblInit",
   "hashTblPut",
   "hashTblRemove",
   "hashTblTerminate",
   "hashFuncIterScale",
   "hashFuncModulo",
   "hashFuncMultiply",
   "iosInit",
   "iosShowInit",
   "iosFdDevFind",
   "iosNextDevGet",
   "iosClose",
   "iosDevAdd",
   "iosDrvRemove",
   "iosCreate",
   "iosDelete",
   "iosDrvInstall",
   "iosFdNew",
   "iosFdValue",
   "iosIoctl",
   "iosOpen",
   "iosRead",
   "iosWrite",
   "iosDevDelete",
   "iosDevShow",
   "iosDrvShow",
   "iosFdFree",
   "iosFdSet",
   "iosFdShow",
   "dllCreate",
   "dllEach",
   "dllGet",
   "dllDelete",
   "dllInit",
   "dllTerminate",
   "dllCount",
   "dllAdd",
   "dllInsert",
   "dllRemove",
   "qFifoCreate",
   "qFifoGet",
   "qFifoDelete",
   "qFifoInit",
   "qFifoInfo",
   "qFifoPut",
   "qFifoRemove",
   "qFifoEach",
   "semGive",
   "semTake",
   "semFlush",
   "semDelete",
   "semInfo",
   "semBLibInit",
   "semBCreate",
   "semCLibInit",
   "semCCreate",
   "semMLibInit",
   "semMCreate",
   "semMGiveForce",
   "semOLibInit",
   "semCreate",
   "semShowInit",
   "semShow",
   "envLibInit",
   "envPrivateCreate",
   "envPrivateDestroy",
   "putenv",
   "envShow",
   "errnoOfTaskSet",
   "errnoSet",
   "errnoGet",
   "errnoOfTaskGet",
   "etherAddrResolve",
   "etherInputHookAdd",
   "etherOutput",
   "etherOutputHookAdd",
   "etherInputHookDelete",
   "etherOutputHookDelete",
   "evtBufferIsEmpty",
   "evtBufferAddress",
   "evtBufferToFile",
   "evtBufferUpLoad",
   "excVecInit",
   "excShowInit",
   "excInit",
   "excHookAdd",
   "excTask",
   "excJobAdd",
   "ftpLogin",
   "ftpXfer",
   "ftpCommand",
   "ftpDataConnGet",
   "ftpDataConnInit",
   "ftpHookup",
   "ftpReplyGet",
   "ftpdInit",
   "ftpdTask",
   "ftpdDelete",
   "ifAddrSet",
   "ifAddrGet",
   "ifBroadcastSet",
   "ifBroadcastGet",
   "ifDstAddrSet",
   "ifDstAddrGet",
   "ifMaskSet",
   "ifMaskGet",
   "ifFlagChange",
   "ifFlagSet",
   "ifFlagGet",
   "ifMetricSet",
   "ifMetricGet",
   "ifRouteDelete",
   "ifunit",
   "bpattach",
   "bpInit",
   "bpShow",
   "slipInit",
   "slipBaudSet",
   "intConnect",
   "intHandlerCreate",
   "intLockLevelSet",
   "intLockLevelGet",
   "intContext",
   "intCount",
   "intVecBaseSet",
   "intVecBaseGet",
   "intVecSet",
   "intVecGet",
   "intLevelSet",
   "intLock",
   "intUnlock",
   "intVecTableWriteProtect",
   "intCRGet",
   "intCRSet",
   "intSRGet",
   "intSRSet",
   "intAckConfig",
   "intTBRSet",
   "intVecTableWriteEnable",
   "intHandlerCreateAm29k",
   "am29200Intr3DeMuxConnect",
   "intDisable",
   "intEnable",
   "loadModule",
   "loadModuleGet",
   "addSegNames",
   "loadSegmentsAllocate",
   "loginDefaultEncrypt",
   "loginPrompt",
   "loginUserAdd",
   "loginUserDelete",
   "loginUserVerify",
   "loginEncryptInstall",
   "loginInit",
   "loginStringSet",
   "loginUserShow",
   "logFdAdd",
   "logFdDelete",
   "logInit",
   "logMsg",
   "logFdSet",
   "logShow",
   "logTask",
   "memDrv",
   "memDevCreate",
   "memInit",
   "memPartLibInit",
   "memPartCreate",
   "memPartInit",
   "memPartAddToPool",
   "memAddToPool",
   "memPartAlloc",
   "memPartAlignedAlloc",
   "memalign",
   "valloc",
   "memPartFree",
   "memPartOptionsSet",
   "memFindMax",
   "memPartFindMax",
   "memPartRealloc",
   "memOptionsSet",
   "cfree",
   "memShowInit",
   "memShow",
   "memPartShow",
   "memPartInfoGet",
   "moduleLibInit",
   "moduleCreate",
   "moduleInit",
   "moduleTerminate",
   "moduleDelete",
   "moduleIdFigure",
   "moduleShow",
   "moduleSegAdd",
   "moduleSegGet",
   "moduleSegFirst",
   "moduleSegNext",
   "moduleSegEach",
   "moduleCreateHookAdd",
   "moduleCreateHookDelete",
   "moduleFindByName",
   "moduleFindByNameAndPath",
   "moduleFindByGroup",
   "moduleEach",
   "moduleIdListGet",
   "moduleInfoGet",
   "moduleNameGet",
   "moduleFlagsGet",
   "moduleCheck",
   "mountdInit",
   "mountd",
   "nfsExport",
   "nfsUnexport",
   "nfsExportFindByName",
   "nfsExportFindById",
   "fdToInode",
   "nameToInode",
   "mq_close",
   "mq_unlink",
   "mq_send",
   "mq_receive",
   "mq_notify",
   "mq_setattr",
   "mq_getattr",
   "msgQLibInit",
   "msgQCreate",
   "msgQDelete",
   "msgQSend",
   "msgQReceive",
   "msgQInfoGet",
   "msgQNumMsgs",
   "msgQShowInit",
   "msgQShow",
   "msgQSmCreate",
   "msgQSmShowInit",
   "arptabShow",
   "arpShow",
   "icmpstatShow",
   "ifShow",
   "inetstatShow",
   "ipstatShow",
   "mbufShow",
   "netShowInit",
   "tcpDebugShow",
   "tcpstatShow",
   "udpstatShow",
   "routeShow",
   "hostShow",
   "nfsdInit",
   "nfsdRequestProcess",
   "nfsd",
   "nfsdStatusGet",
   "nfsdStatusShow",
   "nfsdFhCreate",
   "nfsdFhToName",
   "nfsdFattrGet",
   "nfsdFhHton",
   "nfsdFhNtoh",
   "nfsExportShow",
   "nfsAuthUnixGet",
   "nfsAuthUnixSet",
   "nfsAuthUnixPrompt",
   "nfsAuthUnixShow",
   "nfsHelp",
   "nfsIdSet",
   "nfsDrv",
   "nfsMount",
   "nfsMountAll",
   "nfsDevShow",
   "nfsUnmount",
   "nfsDevListGet",
   "nfsDevInfoGet",
   "pingLibInit",
   "ping",
   "pipeDevCreate",
   "pipeDrv",
   "proxyArpLibInit",
   "proxyPortShow",
   "proxyPortFwdOn",
   "proxyPortFwdOff",
   "proxyNetCreate",
   "proxyNetDelete",
   "proxyClientAdd",
   "proxyClientDelete",
   "proxyReg",
   "proxyUnreg",
   "ramDrv",
   "ramDevCreate",
   "rebootHookAdd",
   "reboot",
   "bindresvport",
   "iam",
   "remCurIdSet",
   "rcmd",
   "rresvport",
   "remCurIdGet",
   "whoami",
   "rlogInit",
   "rlogin",
   "rlogChildTask",
   "rlogInTask",
   "rlogOutTask",
   "rlogind",
   "rngIsEmpty",
   "rngIsFull",
   "rngCreate",
   "rngBufGet",
   "rngBufPut",
   "rngFreeBytes",
   "rngNBytes",
   "rngDelete",
   "rngFlush",
   "rngMoveAhead",
   "rngPutAhead",
   "routeAdd",
   "routeDelete",
   "routeNetAdd",
   "routeCmd",
   "semBSmCreate",
   "semCSmCreate",
   "semSmShowInit",
   "memPartSmCreate",
   "smMemFree",
   "smMemFindMax",
   "smMemMalloc",
   "smMemCalloc",
   "smMemRealloc",
   "smMemAddToPool",
   "smMemOptionsSet",
   "smMemShowInit",
   "smMemShow",
   "smNameAdd",
   "smNameFind",
   "smNameFindByValue",
   "smNameRemove",
   "smNameShowInit",
   "smNameShow",
   "smObjLibInit",
   "smObjLocalToGlobal",
   "smObjGlobalToLocal",
   "smObjTimeoutLogEnable",
   "smObjShowInit",
   "smObjShow",
   "sockLibInit",
   "sockLibAdd",
   "bind",
   "connect",
   "connectWithTimeout",
   "getpeername",
   "getsockname",
   "getsockopt",
   "listen",
   "setsockopt",
   "shutdown",
   "accept",
   "recv",
   "recvfrom",
   "recvmsg",
   "send",
   "sendmsg",
   "sendto",
   "socket",
   "spyLibInit",
   "spyClkStartCommon",
   "spyCommon",
   "spyClkStopCommon",
   "spyReportCommon",
   "spyStopCommon",
   "spyComTask",
   "symLibInit",
   "symEach",
   "symName",
   "symShowInit",
   "symShow",
   "symTblDelete",
   "symTblTerminate",
   "symTblDestroy",
   "symFree",
   "symSAdd",
   "symAdd",
   "symTblAdd",
   "symRemove",
   "symTblRemove",
   "symInit",
   "symAlloc",
   "symTblInit",
   "symTblCreate",
   "symFindSymbol",
   "symFindByValue",
   "symFindByValueAndType",
   "sysModel",
   "sysBspRev",
   "sysMemTop",
   "sysPhysMemTop",
   "sysToMonitor",
   "sysProcNumGet",
   "sysProcNumSet",
   "sysBusTas",
   "sysNvRamGet",
   "sysNvRamSet",
   "sysSerialReset",
   "sysBusIntAck",
   "sysBusIntGen",
   "sysMailboxConnect",
   "sysMailboxEnable",
   "taskHookInit",
   "taskCreateHookAdd",
   "taskCreateHookDelete",
   "taskDeleteHookAdd",
   "taskDeleteHookDelete",
   "taskSwapHookAdd",
   "taskSwapHookAttach",
   "taskSwapHookDelete",
   "taskSwapHookDetach",
   "taskSwitchHookAdd",
   "taskSwitchHookDelete",
   "taskHookShowInit",
   "taskCreateHookShow",
   "taskDeleteHookShow",
   "taskSwapHookShow",
   "taskSwitchHookShow",
   "taskSpawn",
   "taskInit",
   "taskActivate",
   "taskDelete",
   "taskDeleteForce",
   "taskSuspend",
   "taskResume",
   "taskRestart",
   "taskPrioritySet",
   "taskPriorityGet",
   "taskLock",
   "taskUnlock",
   "taskSafe",
   "taskUnsafe",
   "taskDelay",
   "taskOptionsSet",
   "taskOptionsGet",
   "taskName",
   "taskNameToId",
   "taskIdVerify",
   "taskIdSelf",
   "taskIdDefault",
   "taskIsReady",
   "taskIsSuspended",
   "taskTcb",
   "taskIdListGet",
   "taskInfoGet",
   "taskStatusString",
   "taskOptionsString",
   "taskRegsShow",
   "taskStackAllot",
   "taskShowInit",
   "taskShow",
   "taskVarAdd",
   "taskVarDelete",
   "taskVarInit",
   "taskVarSet",
   "taskVarGet",
   "taskVarInfo",
   "tickAnnounce",
   "tickSet",
   "tickGet",
   "timex",
   "timexClear",
   "timexFunc",
   "timexHelp",
   "timexInit",
   "timexN",
   "timexPost",
   "timexPre",
   "timexShow",
   "unld",
   "unldByNameAndPath",
   "unldByGroup",
   "unldByModuleId",
   "reld",
   "help",
   "netHelp",
   "bootChange",
   "periodRun",
   "period",
   "repeatRun",
   "repeat",
   "sp",
   "taskIdFigure",
   "checkStack",
   "i",
   "ts",
   "tr",
   "td",
   "ti",
   "version",
   "m",
   "d",
   "cd",
   "pwd",
   "copy",
   "copyStreams",
   "diskFormat",
   "diskInit",
   "squeeze",
   "ld",
   "ls",
   "ll",
   "lsOld",
   "rm",
   "devs",
   "lkup",
   "lkAddr",
   "mRegs",
   "printErrno",
   "printLogo",
   "logout",
   "h",
   "pc",
   "show",
   "spyClkStart",
   "spyClkStop",
   "spy",
   "spyStop",
   "spyHelp",
   "spyReport",
   "spyTask",
   "sysMemProbe",
   "vxMemProbe",
   "vxTas",
   "wdLibInit",
   "wdCreate",
   "wdDelete",
   "wdStart",
   "wdCancel",
   "wdShowInit",
   "wdShow",
   "wvEvtLogEnable",
   "wvEvtLogDisable",
   "wvOn",
   "wvOff",
   "wvEvtLogStop",
   "wvEvtTaskInit",
   "wvInstInit",
   "wvLibInit",
   "wvObjInstModeSet",
   "wvObjInst",
   "wvSigInst",
   "wvHostInfoInit",
   "wvServerInit",
   "customInit",
 NULL
 }; // end of nameCmd array


/* *** Define Section *** */


 // build define enumeration
 typedef long Define_VxWorks;
 static char *Define_VxWorks_slotNames [] = {
   "_PARM_BUFSIZ",
   "_PARM_EXIT_FAILURE",
   "_PARM_EXIT_SUCCESS",
   "_PARM_FILENAME_MAX",
   "_PARM_FOPEN_MAX",
   "_PARM_L_ctermid",
   "_PARM_L_cuserid",
   "_PARM_L_tmpnam",
   "_PARM_MB_CUR_MAX",
   "_PARM_NAME_MAX",
   "_PARM_PATH_MAX",
   "_PARM_RAND_MAX",
   "_PARM_TMP_MAX",
   "_PARM_UTS_MACHINE_MAX",
   "_PARM_UTS_NODENAME_MAX",
   "_PARM_UTS_RELEASE_MAX",
   "_PARM_UTS_SYSNAME_MAX",
   "_PARM_UTS_VERSION_MAX",
   "_PARM_BIG_ENDIAN",
   "_PARM_LITTLE_ENDIAN",
   "_PARM_STACK_GROWS_UP",
   "AIO_CANCELED",
   "AIO_NOTCANCELED",
   "AIO_ALLDONE",
   "LIO_WAIT",
   "LIO_NOWAIT",
   "LIO_READ",
   "LIO_WRITE",
   "LIO_NOP",
   "CLOCK_REALTIME",
   "TIMER_ABSTIME",
   "_POSIX_CLOCKRES_MIN",
   "_POSIX_INTERVAL_MAX",
   "_POSIX_TIMER_MAX",
   "_POSIX_DELAYTIMER_MAX",
   "SIGEV_NONE",
   "SIGEV_SIGNAL",
   "SIGHUP",
   "SIGINT",
   "SIGQUIT",
   "SIGILL",
   "SIGTRAP",
   "SIGABRT",
   "SIGEMT",
   "SIGFPE",
   "SIGKILL",
   "SIGBUS",
   "SIGSEGV",
   "SIGFMT",
   "SIGPIPE",
   "SIGALRM",
   "SIGTERM",
   "SIGSTOP",
   "SIGTSTP",
   "SIGCONT",
   "SIGCHLD",
   "SIGTTIN",
   "SIGTTOU",
   "SIGUSR1",
   "SIGUSR2",
   "SIGRTMIN",
   "SIGRTMAX",
   "SA_NOCLDSTOP",
   "SA_SIGINFO",
   "SA_ONSTACK",
   "SA_INTERRUPT",
   "SA_RESETHAND",
   "SIG_BLOCK",
   "SIG_UNBLOCK",
   "SIG_SETMASK",
   "SI_SYNC",
   "SI_KILL",
   "SI_QUEUE",
   "SI_TIMER",
   "SI_ASYNCIO",
   "SI_MESGQ",
   "BOOT_DEV_LEN",
   "BOOT_HOST_LEN",
   "BOOT_ADDR_LEN",
   "BOOT_FILE_LEN",
   "BOOT_USR_LEN",
   "BOOT_PASSWORD_LEN",
   "BOOT_OTHER_LEN",
   "BOOT_FIELD_LEN",
   "IPPROTO_IP",
   "IPPROTO_ICMP",
   "IPPROTO_GGP",
   "IPPROTO_TCP",
   "IPPROTO_EGP",
   "IPPROTO_PUP",
   "IPPROTO_UDP",
   "IPPROTO_IDP",
   "IPPROTO_RAW",
   "IPPROTO_MAX",
   "IPPORT_RESERVED",
   "IPPORT_USERRESERVED",
   "IMPLINK_IP",
   "IMPLINK_LOWEXPER",
   "IMPLINK_HIGHEXPER",
   "INADDR_ANY",
   "INADDR_BROADCAST",
   "INADDR_NONE",
   "IN_LOOPBACKNET",
   "IP_OPTIONS",
   "MAXHOSTNAMELEN",
   "IPPORT_BOOTPS",
   "IPPORT_BOOTPC",
   "BOOTREQUEST",
   "BOOTREPLY",
   "SIZE_VEND",
   "SIZE_FILE",
   "TAG_PAD",
   "TAG_SUBNET_MASK",
   "TAG_TIME_OFFSET",
   "TAG_GATEWAY",
   "TAG_TIME_SERVER",
   "TAG_NAME_SERVER",
   "TAG_DOMAIN_SERVER",
   "TAG_LOG_SERVER",
   "TAG_COOKIE_SERVER",
   "TAG_LPR_SERVER",
   "TAG_IMPRESS_SERVER",
   "TAG_RLP_SERVER",
   "TAG_HOSTNAME",
   "TAG_BOOTSIZE",
   "TAG_END",
   "_INSTRUCTION_CACHE",
   "_DATA_CACHE",
   "_BRANCH_CACHE",
   "CACHE_DISABLED",
   "CACHE_WRITETHROUGH",
   "CACHE_COPYBACK",
   "CACHE_WRITEALLOCATE",
   "CACHE_NO_WRITEALLOCATE",
   "CACHE_SNOOP_ENABLE",
   "CACHE_SNOOP_DISABLE",
   "CACHE_BURST_ENABLE",
   "CACHE_BURST_DISABLE",
   "FIFO_KEY_HEAD",
   "FIFO_KEY_TAIL",
   "SEM_Q_MASK",
   "SEM_Q_FIFO",
   "SEM_Q_PRIORITY",
   "SEM_DELETE_SAFE",
   "SEM_INVERSION_SAFE",
   "DOS_BOOT_SEC_NUM",
   "DOS_MIN_CLUST",
   "DOS_MAX_CLUSTERS",
   "DOS_SYS_ID_LEN",
   "DOS_LONG_NAME_LEN",
   "DOS_NAME_LEN",
   "DOS_EXT_LEN",
   "DOS_RESERVED_LEN",
   "DOS_LONG_RESERVED_LEN",
   "DOS_DEL_MARK",
   "DOS_NAME_E5",
   "DOS_MAX_NFATS",
   "DOS_MAX_DIR_LEVELS",
   "DOS_FAT_AVAIL",
   "DOS_FAT_BAD",
   "DOS_FAT16_BAD",
   "DOS_FAT_EOF",
   "DOS_FAT16_EOF",
   "DOS_FAT_12BIT_MAX",
   "DOS_BOOT_JMP",
   "DOS_BOOT_SYS_ID",
   "DOS_BOOT_BYTES_PER_SEC",
   "DOS_BOOT_SEC_PER_CLUST",
   "DOS_BOOT_NRESRVD_SECS",
   "DOS_BOOT_NFATS",
   "DOS_BOOT_MAX_ROOT_ENTS",
   "DOS_BOOT_NSECTORS",
   "DOS_BOOT_MEDIA_BYTE",
   "DOS_BOOT_SEC_PER_FAT",
   "DOS_BOOT_SEC_PER_TRACK",
   "DOS_BOOT_NHEADS",
   "DOS_BOOT_NHIDDEN_SECS",
   "DOS_BOOT_LONG_NSECTORS",
   "DOS_BOOT_DRIVE_NUM",
   "DOS_BOOT_SIG_REC",
   "DOS_BOOT_VOL_ID",
   "DOS_BOOT_VOL_LABEL",
   "DOS_BOOT_PART_TBL",
   "DOS_EXT_BOOT_SIG",
   "DOS_PTYPE_FAT12",
   "DOS_PTYPE_FAT16",
   "DOS_PTYPE_EXTENDED",
   "DOS_ATTR_RDONLY",
   "DOS_ATTR_HIDDEN",
   "DOS_ATTR_SYSTEM",
   "DOS_ATTR_VOL_LABEL",
   "DOS_ATTR_DIRECTORY",
   "DOS_ATTR_ARCHIVE",
   "DOS_VD_READY_CHANGED",
   "DOS_VD_RESET",
   "DOS_VD_MOUNTED",
   "DOS_VD_CANT_RESET",
   "DOS_VD_CANT_MOUNT",
   "DOS_OPT_CHANGENOWARN",
   "DOS_OPT_AUTOSYNC",
   "DOS_OPT_LONGNAMES",
   "DOS_OPT_EXPORT",
   "DOS_OPT_LOWERCASE",
   "FTP_PRELIM",
   "FTP_COMPLETE",
   "FTP_CONTINUE",
   "FTP_TRANSIENT",
   "FTP_ERROR",
   "FTP_NOACTION",
   "TYPE_A",
   "TYPE_E",
   "TYPE_I",
   "TYPE_L",
   "FORM_N",
   "FORM_T",
   "FORM_C",
   "STRU_F",
   "STRU_R",
   "STRU_P",
   "MODE_S",
   "MODE_B",
   "MODE_C",
   "BLK_EOR",
   "BLK_EOF",
   "BLK_ERRORS",
   "BLK_RESTART",
   "BLK_BYTECOUNT",
   "BP_INT_NONE",
   "BP_INT_MAILBOX_1",
   "BP_INT_MAILBOX_2",
   "BP_INT_MAILBOX_4",
   "BP_INT_BUS",
   "BP_INT_MAILBOX_R1",
   "BP_INT_MAILBOX_R2",
   "BP_INT_MAILBOX_R4",
   "NO_SYMBOLS",
   "GLOBAL_SYMBOLS",
   "ALL_SYMBOLS",
   "LOAD_NO_SYMBOLS",
   "LOAD_LOCAL_SYMBOLS",
   "LOAD_GLOBAL_SYMBOLS",
   "HIDDEN_MODULE",
   "LOAD_MODULE_INFO_ONLY",
   "LOAD_LOADED_BY_TGTSVR",
   "MAX_LOGIN_NAME_LEN",
   "MAX_LOGIN_ENTRY",
   "MEM_BLOCK_CHECK",
   "MEM_ALLOC_ERROR_LOG_FLAG",
   "MEM_ALLOC_ERROR_SUSPEND_FLAG",
   "MEM_BLOCK_ERROR_LOG_FLAG",
   "MEM_BLOCK_ERROR_SUSPEND_FLAG",
   "MEM_ALLOC_ERROR_MASK",
   "MEM_ALLOC_ERROR_RETURN",
   "MEM_ALLOC_ERROR_LOG_MSG",
   "MEM_ALLOC_ERROR_LOG_AND_SUSPEND",
   "MEM_BLOCK_ERROR_MASK",
   "MEM_BLOCK_ERROR_RETURN",
   "MEM_BLOCK_ERROR_LOG_MSG",
   "MEM_BLOCK_ERROR_LOG_AND_SUSPEND",
   "MODULE_GROUP_MAX",
   "MODULE_A_OUT",
   "MODULE_B_OUT",
   "MODULE_ECOFF",
   "MODULE_ELF",
   "SEGMENT_TEXT",
   "SEGMENT_DATA",
   "SEGMENT_BSS",
   "SEGMENT_UNWIND",
   "SEGMENT_STUB",
   "SEG_FREE_MEMORY",
   "SEG_WRITE_PROTECTION",
   "MODDISPLAY_CODESIZE",
   "MODDISPLAY_IS_DLL_NODE",
   "MODCHECK_NOPRINT",
   "MODULE_REPLACED",
   "MAX_EXPORTED_FILESYSTEMS",
   "MOUNTD_PRIORITY_DEFAULT",
   "MOUNTD_STACKSIZE_DEFAULT",
   "MSG_Q_TYPE_MASK",
   "MSG_Q_FIFO",
   "MSG_Q_PRIORITY",
   "MSG_PRI_NORMAL",
   "MSG_PRI_URGENT",
   "NFS_FSTAT_DIR",
   "NFS_FSTAT_CHR",
   "NFS_FSTAT_BLK",
   "NFS_FSTAT_REG",
   "NFS_FSTAT_LNK",
   "NFS_FSTAT_NON",
   "NFS_TIMEOUT_SEC",
   "NFS_TIMEOUT_USEC",
   "NFS_SOCKOPTVAL",
   "NFS_REXMIT_SEC",
   "NFS_REXMIT_USEC",
   "AUTH_UNIX_FIELD_LEN",
   "MAX_GRPS",
   "PING_MAXPACKET",
   "PING_INTERVAL",
   "PING_TMO",
   "ICMP_PROTO",
   "ICMP_TYPENUM",
   "PING_TASK_NAME_LEN",
   "PING_OPT_SILENT",
   "PING_OPT_DONTROUTE",
   "PING_OPT_DEBUG",
   "MAX_IDENTITY_LEN",
   "NUM_SIGNALS",
   "SIGURG",
   "NUM_SIGNALS",
   "MAX_NAME_LENGTH",
   "MAX_DEF_TYPE",
   "T_SM_SEM_B",
   "T_SM_SEM_C",
   "T_SM_MSG_Q",
   "T_SM_PART_ID",
   "T_SM_BLOCK",
   "SM_OBJ_MAX_CPU",
   "SYM_UNDF",
   "SYM_LOCAL",
   "SYM_GLOBAL",
   "SYM_ABS",
   "SYM_TEXT",
   "SYM_DATA",
   "SYM_BSS",
   "SYM_COMM",
   "SYM_SDA",
   "SYM_SDA2",
   "SYM_MASK_ALL",
   "SYM_MASK_NONE",
   "SYM_MASK_EXACT",
   "SYM_SDA_MASK",
   "BOOT_NORMAL",
   "BOOT_NO_AUTOBOOT",
   "BOOT_CLEAR",
   "BOOT_QUICK_AUTOBOOT",
   "SYSFLG_NO_SYS_CONTROLLER",
   "SYSFLG_DEBUG",
   "SYSFLG_NO_AUTOBOOT",
   "SYSFLG_QUICK_AUTOBOOT",
   "SYSFLG_NO_STARTUP_SCRIPT",
   "SYSFLG_NO_SECURITY",
   "SYSFLG_BOOTP",
   "SYSFLG_TFTP",
   "SYSFLG_PROXY",
   "SYSFLG_WDB",
   "SYSFLG_VENDOR_0",
   "SYSFLG_VENDOR_1",
   "SYSFLG_VENDOR_2",
   "SYSFLG_VENDOR_3",
   "MAX_TASK_ARGS",
   "VX_MAX_TASK_SWITCH_RTNS",
   "VX_MAX_TASK_SWAP_RTNS",
   "VX_MAX_TASK_DELETE_RTNS",
   "VX_MAX_TASK_CREATE_RTNS",
   "VX_SUPERVISOR_MODE",
   "VX_UNBREAKABLE",
   "VX_DEALLOC_STACK",
   "VX_FP_TASK",
   "VX_STDIO",
   "VX_ADA_DEBUG",
   "VX_FORTRAN",
   "VX_PRIVATE_ENV",
   "VX_NO_STACK_FILL",
   "UNLD_KEEP_BREAKPOINTS",
   "UNLD_SYNC",
   "CONTEXT_SWITCH",
   "TASK_STATE",
   "OBJECT_STATUS",
   "OBJ_TASK",
   "OBJ_SEM",
   "OBJ_MSG",
   "OBJ_WD",
   "INSTRUMENT_ON",
   "INSTRUMENT_OFF",
   NULL
 };
 static long Define_VxWorks_slotValues [] = {
   (long)_PARM_BUFSIZ,
   (long)_PARM_EXIT_FAILURE,
   (long)_PARM_EXIT_SUCCESS,
   (long)_PARM_FILENAME_MAX,
   (long)_PARM_FOPEN_MAX,
   (long)_PARM_L_ctermid,
   (long)_PARM_L_cuserid,
   (long)_PARM_L_tmpnam,
   (long)_PARM_MB_CUR_MAX,
   (long)_PARM_NAME_MAX,
   (long)_PARM_PATH_MAX,
   (long)_PARM_RAND_MAX,
   (long)_PARM_TMP_MAX,
   (long)_PARM_UTS_MACHINE_MAX,
   (long)_PARM_UTS_NODENAME_MAX,
   (long)_PARM_UTS_RELEASE_MAX,
   (long)_PARM_UTS_SYSNAME_MAX,
   (long)_PARM_UTS_VERSION_MAX,
   (long)_PARM_BIG_ENDIAN,
   (long)_PARM_LITTLE_ENDIAN,
   (long)_PARM_STACK_GROWS_UP,
   (long)AIO_CANCELED,
   (long)AIO_NOTCANCELED,
   (long)AIO_ALLDONE,
   (long)LIO_WAIT,
   (long)LIO_NOWAIT,
   (long)LIO_READ,
   (long)LIO_WRITE,
   (long)LIO_NOP,
   (long)CLOCK_REALTIME,
   (long)TIMER_ABSTIME,
   (long)_POSIX_CLOCKRES_MIN,
   (long)_POSIX_INTERVAL_MAX,
   (long)_POSIX_TIMER_MAX,
   (long)_POSIX_DELAYTIMER_MAX,
   (long)SIGEV_NONE,
   (long)SIGEV_SIGNAL,
   (long)SIGHUP,
   (long)SIGINT,
   (long)SIGQUIT,
   (long)SIGILL,
   (long)SIGTRAP,
   (long)SIGABRT,
   (long)SIGEMT,
   (long)SIGFPE,
   (long)SIGKILL,
   (long)SIGBUS,
   (long)SIGSEGV,
   (long)SIGFMT,
   (long)SIGPIPE,
   (long)SIGALRM,
   (long)SIGTERM,
   (long)SIGSTOP,
   (long)SIGTSTP,
   (long)SIGCONT,
   (long)SIGCHLD,
   (long)SIGTTIN,
   (long)SIGTTOU,
   (long)SIGUSR1,
   (long)SIGUSR2,
   (long)SIGRTMIN,
   (long)SIGRTMAX,
   (long)SA_NOCLDSTOP,
   (long)SA_SIGINFO,
   (long)SA_ONSTACK,
   (long)SA_INTERRUPT,
   (long)SA_RESETHAND,
   (long)SIG_BLOCK,
   (long)SIG_UNBLOCK,
   (long)SIG_SETMASK,
   (long)SI_SYNC,
   (long)SI_KILL,
   (long)SI_QUEUE,
   (long)SI_TIMER,
   (long)SI_ASYNCIO,
   (long)SI_MESGQ,
   (long)BOOT_DEV_LEN,
   (long)BOOT_HOST_LEN,
   (long)BOOT_ADDR_LEN,
   (long)BOOT_FILE_LEN,
   (long)BOOT_USR_LEN,
   (long)BOOT_PASSWORD_LEN,
   (long)BOOT_OTHER_LEN,
   (long)BOOT_FIELD_LEN,
   (long)IPPROTO_IP,
   (long)IPPROTO_ICMP,
   (long)IPPROTO_GGP,
   (long)IPPROTO_TCP,
   (long)IPPROTO_EGP,
   (long)IPPROTO_PUP,
   (long)IPPROTO_UDP,
   (long)IPPROTO_IDP,
   (long)IPPROTO_RAW,
   (long)IPPROTO_MAX,
   (long)IPPORT_RESERVED,
   (long)IPPORT_USERRESERVED,
   (long)IMPLINK_IP,
   (long)IMPLINK_LOWEXPER,
   (long)IMPLINK_HIGHEXPER,
   (long)INADDR_ANY,
   (long)INADDR_BROADCAST,
   (long)INADDR_NONE,
   (long)IN_LOOPBACKNET,
   (long)IP_OPTIONS,
   (long)MAXHOSTNAMELEN,
   (long)IPPORT_BOOTPS,
   (long)IPPORT_BOOTPC,
   (long)BOOTREQUEST,
   (long)BOOTREPLY,
   (long)SIZE_VEND,
   (long)SIZE_FILE,
   (long)TAG_PAD,
   (long)TAG_SUBNET_MASK,
   (long)TAG_TIME_OFFSET,
   (long)TAG_GATEWAY,
   (long)TAG_TIME_SERVER,
   (long)TAG_NAME_SERVER,
   (long)TAG_DOMAIN_SERVER,
   (long)TAG_LOG_SERVER,
   (long)TAG_COOKIE_SERVER,
   (long)TAG_LPR_SERVER,
   (long)TAG_IMPRESS_SERVER,
   (long)TAG_RLP_SERVER,
   (long)TAG_HOSTNAME,
   (long)TAG_BOOTSIZE,
   (long)TAG_END,
   (long)_INSTRUCTION_CACHE,
   (long)_DATA_CACHE,
   (long)_BRANCH_CACHE,
   (long)CACHE_DISABLED,
   (long)CACHE_WRITETHROUGH,
   (long)CACHE_COPYBACK,
   (long)CACHE_WRITEALLOCATE,
   (long)CACHE_NO_WRITEALLOCATE,
   (long)CACHE_SNOOP_ENABLE,
   (long)CACHE_SNOOP_DISABLE,
   (long)CACHE_BURST_ENABLE,
   (long)CACHE_BURST_DISABLE,
   (long)FIFO_KEY_HEAD,
   (long)FIFO_KEY_TAIL,
   (long)SEM_Q_MASK,
   (long)SEM_Q_FIFO,
   (long)SEM_Q_PRIORITY,
   (long)SEM_DELETE_SAFE,
   (long)SEM_INVERSION_SAFE,
   (long)DOS_BOOT_SEC_NUM,
   (long)DOS_MIN_CLUST,
   (long)DOS_MAX_CLUSTERS,
   (long)DOS_SYS_ID_LEN,
   (long)DOS_LONG_NAME_LEN,
   (long)DOS_NAME_LEN,
   (long)DOS_EXT_LEN,
   (long)DOS_RESERVED_LEN,
   (long)DOS_LONG_RESERVED_LEN,
   (long)DOS_DEL_MARK,
   (long)DOS_NAME_E5,
   (long)DOS_MAX_NFATS,
   (long)DOS_MAX_DIR_LEVELS,
   (long)DOS_FAT_AVAIL,
   (long)DOS_FAT_BAD,
   (long)DOS_FAT16_BAD,
   (long)DOS_FAT_EOF,
   (long)DOS_FAT16_EOF,
   (long)DOS_FAT_12BIT_MAX,
   (long)DOS_BOOT_JMP,
   (long)DOS_BOOT_SYS_ID,
   (long)DOS_BOOT_BYTES_PER_SEC,
   (long)DOS_BOOT_SEC_PER_CLUST,
   (long)DOS_BOOT_NRESRVD_SECS,
   (long)DOS_BOOT_NFATS,
   (long)DOS_BOOT_MAX_ROOT_ENTS,
   (long)DOS_BOOT_NSECTORS,
   (long)DOS_BOOT_MEDIA_BYTE,
   (long)DOS_BOOT_SEC_PER_FAT,
   (long)DOS_BOOT_SEC_PER_TRACK,
   (long)DOS_BOOT_NHEADS,
   (long)DOS_BOOT_NHIDDEN_SECS,
   (long)DOS_BOOT_LONG_NSECTORS,
   (long)DOS_BOOT_DRIVE_NUM,
   (long)DOS_BOOT_SIG_REC,
   (long)DOS_BOOT_VOL_ID,
   (long)DOS_BOOT_VOL_LABEL,
   (long)DOS_BOOT_PART_TBL,
   (long)DOS_EXT_BOOT_SIG,
   (long)DOS_PTYPE_FAT12,
   (long)DOS_PTYPE_FAT16,
   (long)DOS_PTYPE_EXTENDED,
   (long)DOS_ATTR_RDONLY,
   (long)DOS_ATTR_HIDDEN,
   (long)DOS_ATTR_SYSTEM,
   (long)DOS_ATTR_VOL_LABEL,
   (long)DOS_ATTR_DIRECTORY,
   (long)DOS_ATTR_ARCHIVE,
   (long)DOS_VD_READY_CHANGED,
   (long)DOS_VD_RESET,
   (long)DOS_VD_MOUNTED,
   (long)DOS_VD_CANT_RESET,
   (long)DOS_VD_CANT_MOUNT,
   (long)DOS_OPT_CHANGENOWARN,
   (long)DOS_OPT_AUTOSYNC,
   (long)DOS_OPT_LONGNAMES,
   (long)DOS_OPT_EXPORT,
   (long)DOS_OPT_LOWERCASE,
   (long)FTP_PRELIM,
   (long)FTP_COMPLETE,
   (long)FTP_CONTINUE,
   (long)FTP_TRANSIENT,
   (long)FTP_ERROR,
   (long)FTP_NOACTION,
   (long)TYPE_A,
   (long)TYPE_E,
   (long)TYPE_I,
   (long)TYPE_L,
   (long)FORM_N,
   (long)FORM_T,
   (long)FORM_C,
   (long)STRU_F,
   (long)STRU_R,
   (long)STRU_P,
   (long)MODE_S,
   (long)MODE_B,
   (long)MODE_C,
   (long)BLK_EOR,
   (long)BLK_EOF,
   (long)BLK_ERRORS,
   (long)BLK_RESTART,
   (long)BLK_BYTECOUNT,
   (long)BP_INT_NONE,
   (long)BP_INT_MAILBOX_1,
   (long)BP_INT_MAILBOX_2,
   (long)BP_INT_MAILBOX_4,
   (long)BP_INT_BUS,
   (long)BP_INT_MAILBOX_R1,
   (long)BP_INT_MAILBOX_R2,
   (long)BP_INT_MAILBOX_R4,
   (long)NO_SYMBOLS,
   (long)GLOBAL_SYMBOLS,
   (long)ALL_SYMBOLS,
   (long)LOAD_NO_SYMBOLS,
   (long)LOAD_LOCAL_SYMBOLS,
   (long)LOAD_GLOBAL_SYMBOLS,
   (long)HIDDEN_MODULE,
   (long)LOAD_MODULE_INFO_ONLY,
   (long)LOAD_LOADED_BY_TGTSVR,
   (long)MAX_LOGIN_NAME_LEN,
   (long)MAX_LOGIN_ENTRY,
   (long)MEM_BLOCK_CHECK,
   (long)MEM_ALLOC_ERROR_LOG_FLAG,
   (long)MEM_ALLOC_ERROR_SUSPEND_FLAG,
   (long)MEM_BLOCK_ERROR_LOG_FLAG,
   (long)MEM_BLOCK_ERROR_SUSPEND_FLAG,
   (long)MEM_ALLOC_ERROR_MASK,
   (long)MEM_ALLOC_ERROR_RETURN,
   (long)MEM_ALLOC_ERROR_LOG_MSG,
   (long)MEM_ALLOC_ERROR_LOG_AND_SUSPEND,
   (long)MEM_BLOCK_ERROR_MASK,
   (long)MEM_BLOCK_ERROR_RETURN,
   (long)MEM_BLOCK_ERROR_LOG_MSG,
   (long)MEM_BLOCK_ERROR_LOG_AND_SUSPEND,
   (long)MODULE_GROUP_MAX,
   (long)MODULE_A_OUT,
   (long)MODULE_B_OUT,
   (long)MODULE_ECOFF,
   (long)MODULE_ELF,
   (long)SEGMENT_TEXT,
   (long)SEGMENT_DATA,
   (long)SEGMENT_BSS,
   (long)SEGMENT_UNWIND,
   (long)SEGMENT_STUB,
   (long)SEG_FREE_MEMORY,
   (long)SEG_WRITE_PROTECTION,
   (long)MODDISPLAY_CODESIZE,
   (long)MODDISPLAY_IS_DLL_NODE,
   (long)MODCHECK_NOPRINT,
   (long)MODULE_REPLACED,
   (long)MAX_EXPORTED_FILESYSTEMS,
   (long)MOUNTD_PRIORITY_DEFAULT,
   (long)MOUNTD_STACKSIZE_DEFAULT,
   (long)MSG_Q_TYPE_MASK,
   (long)MSG_Q_FIFO,
   (long)MSG_Q_PRIORITY,
   (long)MSG_PRI_NORMAL,
   (long)MSG_PRI_URGENT,
   (long)NFS_FSTAT_DIR,
   (long)NFS_FSTAT_CHR,
   (long)NFS_FSTAT_BLK,
   (long)NFS_FSTAT_REG,
   (long)NFS_FSTAT_LNK,
   (long)NFS_FSTAT_NON,
   (long)NFS_TIMEOUT_SEC,
   (long)NFS_TIMEOUT_USEC,
   (long)NFS_SOCKOPTVAL,
   (long)NFS_REXMIT_SEC,
   (long)NFS_REXMIT_USEC,
   (long)AUTH_UNIX_FIELD_LEN,
   (long)MAX_GRPS,
   (long)PING_MAXPACKET,
   (long)PING_INTERVAL,
   (long)PING_TMO,
   (long)ICMP_PROTO,
   (long)ICMP_TYPENUM,
   (long)PING_TASK_NAME_LEN,
   (long)PING_OPT_SILENT,
   (long)PING_OPT_DONTROUTE,
   (long)PING_OPT_DEBUG,
   (long)MAX_IDENTITY_LEN,
   (long)NUM_SIGNALS,
   (long)SIGURG,
   (long)NUM_SIGNALS,
   (long)MAX_NAME_LENGTH,
   (long)MAX_DEF_TYPE,
   (long)T_SM_SEM_B,
   (long)T_SM_SEM_C,
   (long)T_SM_MSG_Q,
   (long)T_SM_PART_ID,
   (long)T_SM_BLOCK,
   (long)SM_OBJ_MAX_CPU,
   (long)SYM_UNDF,
   (long)SYM_LOCAL,
   (long)SYM_GLOBAL,
   (long)SYM_ABS,
   (long)SYM_TEXT,
   (long)SYM_DATA,
   (long)SYM_BSS,
   (long)SYM_COMM,
   (long)SYM_SDA,
   (long)SYM_SDA2,
   (long)SYM_MASK_ALL,
   (long)SYM_MASK_NONE,
   (long)SYM_MASK_EXACT,
   (long)SYM_SDA_MASK,
   (long)BOOT_NORMAL,
   (long)BOOT_NO_AUTOBOOT,
   (long)BOOT_CLEAR,
   (long)BOOT_QUICK_AUTOBOOT,
   (long)SYSFLG_NO_SYS_CONTROLLER,
   (long)SYSFLG_DEBUG,
   (long)SYSFLG_NO_AUTOBOOT,
   (long)SYSFLG_QUICK_AUTOBOOT,
   (long)SYSFLG_NO_STARTUP_SCRIPT,
   (long)SYSFLG_NO_SECURITY,
   (long)SYSFLG_BOOTP,
   (long)SYSFLG_TFTP,
   (long)SYSFLG_PROXY,
   (long)SYSFLG_WDB,
   (long)SYSFLG_VENDOR_0,
   (long)SYSFLG_VENDOR_1,
   (long)SYSFLG_VENDOR_2,
   (long)SYSFLG_VENDOR_3,
   (long)MAX_TASK_ARGS,
   (long)VX_MAX_TASK_SWITCH_RTNS,
   (long)VX_MAX_TASK_SWAP_RTNS,
   (long)VX_MAX_TASK_DELETE_RTNS,
   (long)VX_MAX_TASK_CREATE_RTNS,
   (long)VX_SUPERVISOR_MODE,
   (long)VX_UNBREAKABLE,
   (long)VX_DEALLOC_STACK,
   (long)VX_FP_TASK,
   (long)VX_STDIO,
   (long)VX_ADA_DEBUG,
   (long)VX_FORTRAN,
   (long)VX_PRIVATE_ENV,
   (long)VX_NO_STACK_FILL,
   (long)UNLD_KEEP_BREAKPOINTS,
   (long)UNLD_SYNC,
   (long)CONTEXT_SWITCH,
   (long)TASK_STATE,
   (long)OBJECT_STATUS,
   (long)OBJ_TASK,
   (long)OBJ_SEM,
   (long)OBJ_MSG,
   (long)OBJ_WD,
   (long)INSTRUMENT_ON,
   (long)INSTRUMENT_OFF,
   0
 };
 static JWRAP_enums Define_VxWorks_enum  = {
  JWRAP_ENUM,  &usedType [JTYPE_Define_VxWorks],
  374,
  Define_VxWorks_slotNames,
  (long*)Define_VxWorks_slotValues
 };
LOCAL int Put_Define_VxWorks (Tcl_Interp *interp, Tcl_Obj *tclObj) {
  return (jWrapEnumTcl2Cc (interp, &Define_VxWorks_enum, tclObj));
}
LOCAL void Get_Define_VxWorks (Tcl_Obj *tclObj) {
  jWrapEnumCc2Tcl (&Define_VxWorks_enum, tclObj);
}
// Build Define_VxWorks jointure as a Tcl type
static Tcl_ObjType Define_VxWorks_type = {
  "Define_VxWorks",
  (Tcl_FreeInternalRepProc *)NULL,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Define_VxWorks,
  (Tcl_SetFromAnyProc*)      Put_Define_VxWorks
  };


/* *** Enumeration Section *** */

 // As enum as no name we produce a dummy enumeration for size computing
 enum Enum_VxWorks_0 {
   slot_1_0= BRANCH_CACHE,
   slot_1_1= INSTRUCTION_CACHE,
   slot_1_2= DATA_CACHE
 };

  // build enumeration Enum_VxWorks_0 
 static char *Enum_VxWorks_0_slotNames [] = {
   "BRANCH_CACHE",
   "INSTRUCTION_CACHE",
   "DATA_CACHE",
   NULL
 };
 static enum Enum_VxWorks_0 Enum_VxWorks_0_slotValues [] = {
   BRANCH_CACHE,
   INSTRUCTION_CACHE,
   DATA_CACHE,
   0
 };
 static JWRAP_enums Enum_VxWorks_0_enum  = {
  JWRAP_ENUM,  &usedType [JTYPE_Enum_VxWorks_0],
  3,
  Enum_VxWorks_0_slotNames,
  (long*)Enum_VxWorks_0_slotValues
 };
LOCAL int Put_Enum_VxWorks_0 (Tcl_Interp *interp, Tcl_Obj *tclObj) {
  return (jWrapEnumTcl2Cc (interp, &Enum_VxWorks_0_enum, tclObj));
}
LOCAL void Get_Enum_VxWorks_0 (Tcl_Obj *tclObj) {
  jWrapEnumCc2Tcl (&Enum_VxWorks_0_enum, tclObj);
}
// Build Enum_VxWorks_0 jointure as a Tcl type
static Tcl_ObjType Enum_VxWorks_0_type = {
  "Enum_VxWorks_0",
  (Tcl_FreeInternalRepProc *)NULL,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Enum_VxWorks_0,
  (Tcl_SetFromAnyProc*)      Put_Enum_VxWorks_0
  };
 // As enum as no name we produce a dummy enumeration for size computing
 enum Enum_VxWorks_1 {
   slot_2_0= SEM_EMPTY,
   slot_2_1= SEM_FULL
 };

  // build enumeration Enum_VxWorks_1 
 static char *Enum_VxWorks_1_slotNames [] = {
   "SEM_EMPTY",
   "SEM_FULL",
   NULL
 };
 static enum Enum_VxWorks_1 Enum_VxWorks_1_slotValues [] = {
   SEM_EMPTY,
   SEM_FULL,
   0
 };
 static JWRAP_enums Enum_VxWorks_1_enum  = {
  JWRAP_ENUM,  &usedType [JTYPE_Enum_VxWorks_1],
  2,
  Enum_VxWorks_1_slotNames,
  (long*)Enum_VxWorks_1_slotValues
 };
LOCAL int Put_Enum_VxWorks_1 (Tcl_Interp *interp, Tcl_Obj *tclObj) {
  return (jWrapEnumTcl2Cc (interp, &Enum_VxWorks_1_enum, tclObj));
}
LOCAL void Get_Enum_VxWorks_1 (Tcl_Obj *tclObj) {
  jWrapEnumCc2Tcl (&Enum_VxWorks_1_enum, tclObj);
}
// Build Enum_VxWorks_1 jointure as a Tcl type
static Tcl_ObjType Enum_VxWorks_1_type = {
  "Enum_VxWorks_1",
  (Tcl_FreeInternalRepProc *)NULL,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Enum_VxWorks_1,
  (Tcl_SetFromAnyProc*)      Put_Enum_VxWorks_1
  };

 // Hold Defines & Enum reference for jWrap struct help cmd
 static JWRAP_enums *enumerations[]={
  &Define_VxWorks_enum,
  &Enum_VxWorks_0_enum,
  &Enum_VxWorks_1_enum,
  NULL
 };
 
/* *** Unions Section *** */


// Alloc sigval slot jointure for Put/Get functions
static char *sigval_slotNames[] =  {
    "sival_int",
    "sival_ptr",
    NULL
};
static JWRAP_types *sigval_slotTypes[] = {
    &usedType [JTYPE_int], // sival_int
    &usedType [JTYPE_void_Ptr], // sival_ptr
    NULL
};
static int sigval_slotOffsets[2];
static int sigval_slotArrays[] = {
    1, // sival_int
    1, // sival_ptr
    0
};
static JWRAP_structs sigval_union = {
  JWRAP_UNION,
  &usedType [JTYPE_sigval],
  2,
  sigval_slotNames,
  sigval_slotTypes,
  sigval_slotOffsets,
  sigval_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_sigval (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &sigval_union, srcObj, destObj));
}
LOCAL int Put_sigval (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj *destObj) {
  return (jWrapTypeUpdate (interp, &sigval_union, srcObj, destObj));
}
LOCAL char* Get_sigval (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&sigval_union, tclObj);
}
// Build sigval jointure as a Tcl type
static Tcl_ObjType sigval_type = {
  "sigval",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sigval,
  (Tcl_SetFromAnyProc*)      Put_sigval
  };
// Build sigval jointure as a Tcl type
static Tcl_ObjType sigval_ptr = {
  "sigval_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sigval,
  (Tcl_SetFromAnyProc*)      Create_sigval
  };
// We need to produce internal union in order computing size
union Union_VxWorks_0 {
  void* handler;
  void* action;
};
typedef union Union_VxWorks_0 Union_VxWorks_0;

// Alloc Union_VxWorks_0 slot jointure for Put/Get functions
static char *Union_VxWorks_0_slotNames[] =  {
    "handler",
    "action",
    NULL
};
static JWRAP_types *Union_VxWorks_0_slotTypes[] = {
    &usedType [JTYPE_void_Ptr], // handler
    &usedType [JTYPE_void_Ptr], // action
    NULL
};
static int Union_VxWorks_0_slotOffsets[2];
static int Union_VxWorks_0_slotArrays[] = {
    1, // handler
    1, // action
    0
};
static JWRAP_structs Union_VxWorks_0_union = {
  JWRAP_UNION,
  &usedType [JTYPE_Union_VxWorks_0],
  2,
  Union_VxWorks_0_slotNames,
  Union_VxWorks_0_slotTypes,
  Union_VxWorks_0_slotOffsets,
  Union_VxWorks_0_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Union_VxWorks_0 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Union_VxWorks_0_union, srcObj, destObj));
}
LOCAL int Put_Union_VxWorks_0 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj *destObj) {
  return (jWrapTypeUpdate (interp, &Union_VxWorks_0_union, srcObj, destObj));
}
LOCAL char* Get_Union_VxWorks_0 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Union_VxWorks_0_union, tclObj);
}
// Build Union_VxWorks_0 jointure as a Tcl type
static Tcl_ObjType Union_VxWorks_0_type = {
  "Union_VxWorks_0",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Union_VxWorks_0,
  (Tcl_SetFromAnyProc*)      Put_Union_VxWorks_0
  };
// Build Union_VxWorks_0 jointure as a Tcl type
static Tcl_ObjType Union_VxWorks_0_ptr = {
  "Union_VxWorks_0_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Union_VxWorks_0,
  (Tcl_SetFromAnyProc*)      Create_Union_VxWorks_0
  };
// We need to produce internal union in order computing size
union Union_VxWorks_1 {
  char* mountproc_mnt_1_arg;
  char* mountproc_umnt_1_arg;
};
typedef union Union_VxWorks_1 Union_VxWorks_1;

// Alloc Union_VxWorks_1 slot jointure for Put/Get functions
static char *Union_VxWorks_1_slotNames[] =  {
    "mountproc_mnt_1_arg",
    "mountproc_umnt_1_arg",
    NULL
};
static JWRAP_types *Union_VxWorks_1_slotTypes[] = {
    &usedType [JTYPE_char_Ptr], // mountproc_mnt_1_arg
    &usedType [JTYPE_char_Ptr], // mountproc_umnt_1_arg
    NULL
};
static int Union_VxWorks_1_slotOffsets[2];
static int Union_VxWorks_1_slotArrays[] = {
    1, // mountproc_mnt_1_arg
    1, // mountproc_umnt_1_arg
    0
};
static JWRAP_structs Union_VxWorks_1_union = {
  JWRAP_UNION,
  &usedType [JTYPE_Union_VxWorks_1],
  2,
  Union_VxWorks_1_slotNames,
  Union_VxWorks_1_slotTypes,
  Union_VxWorks_1_slotOffsets,
  Union_VxWorks_1_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Union_VxWorks_1 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Union_VxWorks_1_union, srcObj, destObj));
}
LOCAL int Put_Union_VxWorks_1 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj *destObj) {
  return (jWrapTypeUpdate (interp, &Union_VxWorks_1_union, srcObj, destObj));
}
LOCAL char* Get_Union_VxWorks_1 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Union_VxWorks_1_union, tclObj);
}
// Build Union_VxWorks_1 jointure as a Tcl type
static Tcl_ObjType Union_VxWorks_1_type = {
  "Union_VxWorks_1",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Union_VxWorks_1,
  (Tcl_SetFromAnyProc*)      Put_Union_VxWorks_1
  };
// Build Union_VxWorks_1 jointure as a Tcl type
static Tcl_ObjType Union_VxWorks_1_ptr = {
  "Union_VxWorks_1_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Union_VxWorks_1,
  (Tcl_SetFromAnyProc*)      Create_Union_VxWorks_1
  };
 
/* *** Structure Section *** */
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_0 {
  int quot;
  int rem;
};

// Alloc Struct_VxWorks_0 slot structure for Put/Get functions
static char *Struct_VxWorks_0_slotNames[] =  {
    "quot",
    "rem",
    NULL
};
static JWRAP_types *Struct_VxWorks_0_slotTypes[] = {
    &usedType [JTYPE_int], // quot 
    &usedType [JTYPE_int], // rem 
    NULL
};
static int Struct_VxWorks_0_slotArrays[] = {
    1, // quot
    1, // rem
    0
};
static int Struct_VxWorks_0_slotOffsets[2];
static JWRAP_structs Struct_VxWorks_0_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_0],
  2,
  Struct_VxWorks_0_slotNames,
  Struct_VxWorks_0_slotTypes,
  Struct_VxWorks_0_slotOffsets,
  Struct_VxWorks_0_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_0 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_0_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_0 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_0_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_0 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_0_struct, tclObj);
}
// Build Struct_VxWorks_0 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_0_type = {
  "Struct_VxWorks_0",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_0,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_0
  };
// Build Struct_VxWorks_0 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_0_ptr = {
  "Struct_VxWorks_0_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_0,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_0
  };

// Alloc aiocb slot structure for Put/Get functions
static char *aiocb_slotNames[] =  {
    "aio_fildes",
    "aio_offset",
    "aio_buf",
    "aio_nbytes",
    "aio_reqprio",
    "aio_sigevent",
    "aio_lio_opcode",
    "aio_sys",
    NULL
};
static JWRAP_types *aiocb_slotTypes[] = {
    &usedType [JTYPE_int], // aio_fildes 
    &usedType [JTYPE_vx_off_t], // aio_offset 
    &usedType [JTYPE_void_Ptr], // aio_buf 
    &usedType [JTYPE_size_t], // aio_nbytes 
    &usedType [JTYPE_int], // aio_reqprio 
    &usedType [JTYPE_vx_SigVect], // aio_sigevent 
    &usedType [JTYPE_int], // aio_lio_opcode 
    &usedType [JTYPE_vx_AIO_SYS], // aio_sys 
    NULL
};
static int aiocb_slotArrays[] = {
    1, // aio_fildes
    1, // aio_offset
    1, // aio_buf
    1, // aio_nbytes
    1, // aio_reqprio
    1, // aio_sigevent
    1, // aio_lio_opcode
    1, // aio_sys
    0
};
static int aiocb_slotOffsets[8];
static JWRAP_structs aiocb_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_aiocb],
  8,
  aiocb_slotNames,
  aiocb_slotTypes,
  aiocb_slotOffsets,
  aiocb_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_aiocb (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &aiocb_struct, srcObj, destObj));
}
LOCAL int Put_aiocb (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &aiocb_struct, srcObj, destObj));
}
LOCAL char* Get_aiocb (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&aiocb_struct, tclObj);
}
// Build aiocb structure as a Tcl type
static Tcl_ObjType aiocb_type = {
  "aiocb",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_aiocb,
  (Tcl_SetFromAnyProc*)      Put_aiocb
  };
// Build aiocb structure as a Tcl type
static Tcl_ObjType aiocb_ptr = {
  "aiocb_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_aiocb,
  (Tcl_SetFromAnyProc*)      Create_aiocb
  };

// Alloc utimbuf slot structure for Put/Get functions
static char *utimbuf_slotNames[] =  {
    "actime",
    "modtime",
    NULL
};
static JWRAP_types *utimbuf_slotTypes[] = {
    &usedType [JTYPE_long], // actime 
    &usedType [JTYPE_long], // modtime 
    NULL
};
static int utimbuf_slotArrays[] = {
    1, // actime
    1, // modtime
    0
};
static int utimbuf_slotOffsets[2];
static JWRAP_structs utimbuf_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_utimbuf],
  2,
  utimbuf_slotNames,
  utimbuf_slotTypes,
  utimbuf_slotOffsets,
  utimbuf_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_utimbuf (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &utimbuf_struct, srcObj, destObj));
}
LOCAL int Put_utimbuf (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &utimbuf_struct, srcObj, destObj));
}
LOCAL char* Get_utimbuf (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&utimbuf_struct, tclObj);
}
// Build utimbuf structure as a Tcl type
static Tcl_ObjType utimbuf_type = {
  "utimbuf",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_utimbuf,
  (Tcl_SetFromAnyProc*)      Put_utimbuf
  };
// Build utimbuf structure as a Tcl type
static Tcl_ObjType utimbuf_ptr = {
  "utimbuf_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_utimbuf,
  (Tcl_SetFromAnyProc*)      Create_utimbuf
  };

// Alloc tm slot structure for Put/Get functions
static char *tm_slotNames[] =  {
    "tm_sec",
    "tm_min",
    "tm_hour",
    "tm_mday",
    "tm_mon",
    "tm_year",
    "tm_wday",
    "tm_yday",
    "tm_isdst",
    NULL
};
static JWRAP_types *tm_slotTypes[] = {
    &usedType [JTYPE_int], // tm_sec 
    &usedType [JTYPE_int], // tm_min 
    &usedType [JTYPE_int], // tm_hour 
    &usedType [JTYPE_int], // tm_mday 
    &usedType [JTYPE_int], // tm_mon 
    &usedType [JTYPE_int], // tm_year 
    &usedType [JTYPE_int], // tm_wday 
    &usedType [JTYPE_int], // tm_yday 
    &usedType [JTYPE_int], // tm_isdst 
    NULL
};
static int tm_slotArrays[] = {
    1, // tm_sec
    1, // tm_min
    1, // tm_hour
    1, // tm_mday
    1, // tm_mon
    1, // tm_year
    1, // tm_wday
    1, // tm_yday
    1, // tm_isdst
    0
};
static int tm_slotOffsets[9];
static JWRAP_structs tm_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_tm],
  9,
  tm_slotNames,
  tm_slotTypes,
  tm_slotOffsets,
  tm_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_tm (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &tm_struct, srcObj, destObj));
}
LOCAL int Put_tm (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &tm_struct, srcObj, destObj));
}
LOCAL char* Get_tm (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&tm_struct, tclObj);
}
// Build tm structure as a Tcl type
static Tcl_ObjType tm_type = {
  "tm",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_tm,
  (Tcl_SetFromAnyProc*)      Put_tm
  };
// Build tm structure as a Tcl type
static Tcl_ObjType tm_ptr = {
  "tm_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_tm,
  (Tcl_SetFromAnyProc*)      Create_tm
  };

// Alloc vx_timespec slot structure for Put/Get functions
static char *vx_timespec_slotNames[] =  {
    "tv_sec",
    "tv_nsec",
    NULL
};
static JWRAP_types *vx_timespec_slotTypes[] = {
    &usedType [JTYPE_long], // tv_sec 
    &usedType [JTYPE_long], // tv_nsec 
    NULL
};
static int vx_timespec_slotArrays[] = {
    1, // tv_sec
    1, // tv_nsec
    0
};
static int vx_timespec_slotOffsets[2];
static JWRAP_structs vx_timespec_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_vx_timespec],
  2,
  vx_timespec_slotNames,
  vx_timespec_slotTypes,
  vx_timespec_slotOffsets,
  vx_timespec_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_vx_timespec (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &vx_timespec_struct, srcObj, destObj));
}
LOCAL int Put_vx_timespec (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &vx_timespec_struct, srcObj, destObj));
}
LOCAL char* Get_vx_timespec (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&vx_timespec_struct, tclObj);
}
// Build vx_timespec structure as a Tcl type
static Tcl_ObjType vx_timespec_type = {
  "vx_timespec",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_vx_timespec,
  (Tcl_SetFromAnyProc*)      Put_vx_timespec
  };
// Build vx_timespec structure as a Tcl type
static Tcl_ObjType vx_timespec_ptr = {
  "vx_timespec_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_vx_timespec,
  (Tcl_SetFromAnyProc*)      Create_vx_timespec
  };

// Alloc itimerspec slot structure for Put/Get functions
static char *itimerspec_slotNames[] =  {
    "it_interval",
    "it_value",
    NULL
};
static JWRAP_types *itimerspec_slotTypes[] = {
    &usedType [JTYPE_vx_timespec], // it_interval 
    &usedType [JTYPE_vx_timespec], // it_value 
    NULL
};
static int itimerspec_slotArrays[] = {
    1, // it_interval
    1, // it_value
    0
};
static int itimerspec_slotOffsets[2];
static JWRAP_structs itimerspec_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_itimerspec],
  2,
  itimerspec_slotNames,
  itimerspec_slotTypes,
  itimerspec_slotOffsets,
  itimerspec_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_itimerspec (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &itimerspec_struct, srcObj, destObj));
}
LOCAL int Put_itimerspec (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &itimerspec_struct, srcObj, destObj));
}
LOCAL char* Get_itimerspec (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&itimerspec_struct, tclObj);
}
// Build itimerspec structure as a Tcl type
static Tcl_ObjType itimerspec_type = {
  "itimerspec",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_itimerspec,
  (Tcl_SetFromAnyProc*)      Put_itimerspec
  };
// Build itimerspec structure as a Tcl type
static Tcl_ObjType itimerspec_ptr = {
  "itimerspec_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_itimerspec,
  (Tcl_SetFromAnyProc*)      Create_itimerspec
  };

// Alloc sigevent slot structure for Put/Get functions
static char *sigevent_slotNames[] =  {
    "sigev_signo",
    "sigev_value",
    "sigev_notify",
    NULL
};
static JWRAP_types *sigevent_slotTypes[] = {
    &usedType [JTYPE_int], // sigev_signo 
    &usedType [JTYPE_sigval], // sigev_value 
    &usedType [JTYPE_int], // sigev_notify 
    NULL
};
static int sigevent_slotArrays[] = {
    1, // sigev_signo
    1, // sigev_value
    1, // sigev_notify
    0
};
static int sigevent_slotOffsets[3];
static JWRAP_structs sigevent_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_sigevent],
  3,
  sigevent_slotNames,
  sigevent_slotTypes,
  sigevent_slotOffsets,
  sigevent_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_sigevent (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &sigevent_struct, srcObj, destObj));
}
LOCAL int Put_sigevent (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &sigevent_struct, srcObj, destObj));
}
LOCAL char* Get_sigevent (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&sigevent_struct, tclObj);
}
// Build sigevent structure as a Tcl type
static Tcl_ObjType sigevent_type = {
  "sigevent",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sigevent,
  (Tcl_SetFromAnyProc*)      Put_sigevent
  };
// Build sigevent structure as a Tcl type
static Tcl_ObjType sigevent_ptr = {
  "sigevent_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sigevent,
  (Tcl_SetFromAnyProc*)      Create_sigevent
  };

// Alloc siginfo slot structure for Put/Get functions
static char *siginfo_slotNames[] =  {
    "si_signo",
    "si_code",
    "si_value",
    NULL
};
static JWRAP_types *siginfo_slotTypes[] = {
    &usedType [JTYPE_int], // si_signo 
    &usedType [JTYPE_int], // si_code 
    &usedType [JTYPE_sigval], // si_value 
    NULL
};
static int siginfo_slotArrays[] = {
    1, // si_signo
    1, // si_code
    1, // si_value
    0
};
static int siginfo_slotOffsets[3];
static JWRAP_structs siginfo_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_siginfo],
  3,
  siginfo_slotNames,
  siginfo_slotTypes,
  siginfo_slotOffsets,
  siginfo_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_siginfo (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &siginfo_struct, srcObj, destObj));
}
LOCAL int Put_siginfo (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &siginfo_struct, srcObj, destObj));
}
LOCAL char* Get_siginfo (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&siginfo_struct, tclObj);
}
// Build siginfo structure as a Tcl type
static Tcl_ObjType siginfo_type = {
  "siginfo",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_siginfo,
  (Tcl_SetFromAnyProc*)      Put_siginfo
  };
// Build siginfo structure as a Tcl type
static Tcl_ObjType siginfo_ptr = {
  "siginfo_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_siginfo,
  (Tcl_SetFromAnyProc*)      Create_siginfo
  };

// Alloc sigaction slot structure for Put/Get functions
static char *sigaction_slotNames[] =  {
    "sa_u",
    "sa_mask",
    "sa_flags",
    NULL
};
static JWRAP_types *sigaction_slotTypes[] = {
    &usedType [JTYPE_Union_VxWorks_0], // sa_u 
    &usedType [JTYPE_sigset_t], // sa_mask 
    &usedType [JTYPE_int], // sa_flags 
    NULL
};
static int sigaction_slotArrays[] = {
    1, // sa_u
    1, // sa_mask
    1, // sa_flags
    0
};
static int sigaction_slotOffsets[3];
static JWRAP_structs sigaction_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_sigaction],
  3,
  sigaction_slotNames,
  sigaction_slotTypes,
  sigaction_slotOffsets,
  sigaction_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_sigaction (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &sigaction_struct, srcObj, destObj));
}
LOCAL int Put_sigaction (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &sigaction_struct, srcObj, destObj));
}
LOCAL char* Get_sigaction (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&sigaction_struct, tclObj);
}
// Build sigaction structure as a Tcl type
static Tcl_ObjType sigaction_type = {
  "sigaction",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sigaction,
  (Tcl_SetFromAnyProc*)      Put_sigaction
  };
// Build sigaction structure as a Tcl type
static Tcl_ObjType sigaction_ptr = {
  "sigaction_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sigaction,
  (Tcl_SetFromAnyProc*)      Create_sigaction
  };

// Alloc node slot structure for Put/Get functions
static char *node_slotNames[] =  {
    "next",
    "previous",
    NULL
};
static JWRAP_types *node_slotTypes[] = {
    &usedType [JTYPE_node_Ptr], // next 
    &usedType [JTYPE_node_Ptr], // previous 
    NULL
};
static int node_slotArrays[] = {
    1, // next
    1, // previous
    0
};
static int node_slotOffsets[2];
static JWRAP_structs node_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_node],
  2,
  node_slotNames,
  node_slotTypes,
  node_slotOffsets,
  node_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_node (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &node_struct, srcObj, destObj));
}
LOCAL int Put_node (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &node_struct, srcObj, destObj));
}
LOCAL char* Get_node (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&node_struct, tclObj);
}
// Build node structure as a Tcl type
static Tcl_ObjType node_type = {
  "node",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_node,
  (Tcl_SetFromAnyProc*)      Put_node
  };
// Build node structure as a Tcl type
static Tcl_ObjType node_ptr = {
  "node_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_node,
  (Tcl_SetFromAnyProc*)      Create_node
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_1 {
  NODE node;
  int count;
};

// Alloc Struct_VxWorks_1 slot structure for Put/Get functions
static char *Struct_VxWorks_1_slotNames[] =  {
    "node",
    "count",
    NULL
};
static JWRAP_types *Struct_VxWorks_1_slotTypes[] = {
    &usedType [JTYPE_NODE], // node 
    &usedType [JTYPE_int], // count 
    NULL
};
static int Struct_VxWorks_1_slotArrays[] = {
    1, // node
    1, // count
    0
};
static int Struct_VxWorks_1_slotOffsets[2];
static JWRAP_structs Struct_VxWorks_1_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_1],
  2,
  Struct_VxWorks_1_slotNames,
  Struct_VxWorks_1_slotTypes,
  Struct_VxWorks_1_slotOffsets,
  Struct_VxWorks_1_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_1 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_1_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_1 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_1_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_1 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_1_struct, tclObj);
}
// Build Struct_VxWorks_1 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_1_type = {
  "Struct_VxWorks_1",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_1,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_1
  };
// Build Struct_VxWorks_1 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_1_ptr = {
  "Struct_VxWorks_1_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_1,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_1
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_2 {
  char bootDev;
  char hostName;
  char targetName;
  char ead;
  char bad;
  char had;
  char gad;
  char bootFile;
  char startupScript;
  char usr;
  char passwd;
  char other;
  int procNum;
  int flags;
};

// Alloc Struct_VxWorks_2 slot structure for Put/Get functions
static char *Struct_VxWorks_2_slotNames[] =  {
    "bootDev",
    "hostName",
    "targetName",
    "ead",
    "bad",
    "had",
    "gad",
    "bootFile",
    "startupScript",
    "usr",
    "passwd",
    "other",
    "procNum",
    "flags",
    NULL
};
static JWRAP_types *Struct_VxWorks_2_slotTypes[] = {
    &usedType [JTYPE_char], // bootDev 
    &usedType [JTYPE_char], // hostName 
    &usedType [JTYPE_char], // targetName 
    &usedType [JTYPE_char], // ead 
    &usedType [JTYPE_char], // bad 
    &usedType [JTYPE_char], // had 
    &usedType [JTYPE_char], // gad 
    &usedType [JTYPE_char], // bootFile 
    &usedType [JTYPE_char], // startupScript 
    &usedType [JTYPE_char], // usr 
    &usedType [JTYPE_char], // passwd 
    &usedType [JTYPE_char], // other 
    &usedType [JTYPE_int], // procNum 
    &usedType [JTYPE_int], // flags 
    NULL
};
static int Struct_VxWorks_2_slotArrays[] = {
    20, // bootDev
    20, // hostName
    20, // targetName
    30, // ead
    30, // bad
    30, // had
    30, // gad
    80, // bootFile
    80, // startupScript
    20, // usr
    20, // passwd
    80, // other
    1, // procNum
    1, // flags
    0
};
static int Struct_VxWorks_2_slotOffsets[14];
static JWRAP_structs Struct_VxWorks_2_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_2],
  14,
  Struct_VxWorks_2_slotNames,
  Struct_VxWorks_2_slotTypes,
  Struct_VxWorks_2_slotOffsets,
  Struct_VxWorks_2_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_2 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_2_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_2 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_2_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_2 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_2_struct, tclObj);
}
// Build Struct_VxWorks_2 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_2_type = {
  "Struct_VxWorks_2",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_2,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_2
  };
// Build Struct_VxWorks_2 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_2_ptr = {
  "Struct_VxWorks_2_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_2,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_2
  };

// Alloc in_addr slot structure for Put/Get functions
static char *in_addr_slotNames[] =  {
    "s_addr",
    NULL
};
static JWRAP_types *in_addr_slotTypes[] = {
    &usedType [JTYPE_u_long], // s_addr 
    NULL
};
static int in_addr_slotArrays[] = {
    1, // s_addr
    0
};
static int in_addr_slotOffsets[1];
static JWRAP_structs in_addr_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_in_addr],
  1,
  in_addr_slotNames,
  in_addr_slotTypes,
  in_addr_slotOffsets,
  in_addr_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_in_addr (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &in_addr_struct, srcObj, destObj));
}
LOCAL int Put_in_addr (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &in_addr_struct, srcObj, destObj));
}
LOCAL char* Get_in_addr (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&in_addr_struct, tclObj);
}
// Build in_addr structure as a Tcl type
static Tcl_ObjType in_addr_type = {
  "in_addr",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_in_addr,
  (Tcl_SetFromAnyProc*)      Put_in_addr
  };
// Build in_addr structure as a Tcl type
static Tcl_ObjType in_addr_ptr = {
  "in_addr_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_in_addr,
  (Tcl_SetFromAnyProc*)      Create_in_addr
  };

// Alloc sockaddr_in slot structure for Put/Get functions
static char *sockaddr_in_slotNames[] =  {
    "sin_family",
    "sin_port",
    "sin_addr",
    "sin_zero",
    NULL
};
static JWRAP_types *sockaddr_in_slotTypes[] = {
    &usedType [JTYPE_short], // sin_family 
    &usedType [JTYPE_u_short], // sin_port 
    &usedType [JTYPE_in_addr], // sin_addr 
    &usedType [JTYPE_char], // sin_zero 
    NULL
};
static int sockaddr_in_slotArrays[] = {
    1, // sin_family
    1, // sin_port
    1, // sin_addr
    8, // sin_zero
    0
};
static int sockaddr_in_slotOffsets[4];
static JWRAP_structs sockaddr_in_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_sockaddr_in],
  4,
  sockaddr_in_slotNames,
  sockaddr_in_slotTypes,
  sockaddr_in_slotOffsets,
  sockaddr_in_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_sockaddr_in (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &sockaddr_in_struct, srcObj, destObj));
}
LOCAL int Put_sockaddr_in (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &sockaddr_in_struct, srcObj, destObj));
}
LOCAL char* Get_sockaddr_in (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&sockaddr_in_struct, tclObj);
}
// Build sockaddr_in structure as a Tcl type
static Tcl_ObjType sockaddr_in_type = {
  "sockaddr_in",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sockaddr_in,
  (Tcl_SetFromAnyProc*)      Put_sockaddr_in
  };
// Build sockaddr_in structure as a Tcl type
static Tcl_ObjType sockaddr_in_ptr = {
  "sockaddr_in_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_sockaddr_in,
  (Tcl_SetFromAnyProc*)      Create_sockaddr_in
  };

// Alloc hostname_struct slot structure for Put/Get functions
static char *hostname_struct_slotNames[] =  {
    "link",
    "name",
    NULL
};
static JWRAP_types *hostname_struct_slotTypes[] = {
    &usedType [JTYPE_hostname_struct_Ptr], // link 
    &usedType [JTYPE_char_Ptr], // name 
    NULL
};
static int hostname_struct_slotArrays[] = {
    1, // link
    1, // name
    0
};
static int hostname_struct_slotOffsets[2];
static JWRAP_structs hostname_struct_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_hostname_struct],
  2,
  hostname_struct_slotNames,
  hostname_struct_slotTypes,
  hostname_struct_slotOffsets,
  hostname_struct_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_hostname_struct (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &hostname_struct_struct, srcObj, destObj));
}
LOCAL int Put_hostname_struct (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &hostname_struct_struct, srcObj, destObj));
}
LOCAL char* Get_hostname_struct (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&hostname_struct_struct, tclObj);
}
// Build hostname_struct structure as a Tcl type
static Tcl_ObjType hostname_struct_type = {
  "hostname_struct",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_hostname_struct,
  (Tcl_SetFromAnyProc*)      Put_hostname_struct
  };
// Build hostname_struct structure as a Tcl type
static Tcl_ObjType hostname_struct_ptr = {
  "hostname_struct_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_hostname_struct,
  (Tcl_SetFromAnyProc*)      Create_hostname_struct
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_3 {
  NODE node;
  HOSTNAME hostName;
  struct in_addr netAddr;
};

// Alloc Struct_VxWorks_3 slot structure for Put/Get functions
static char *Struct_VxWorks_3_slotNames[] =  {
    "node",
    "hostName",
    "netAddr",
    NULL
};
static JWRAP_types *Struct_VxWorks_3_slotTypes[] = {
    &usedType [JTYPE_NODE], // node 
    &usedType [JTYPE_HOSTNAME], // hostName 
    &usedType [JTYPE_in_addr], // netAddr 
    NULL
};
static int Struct_VxWorks_3_slotArrays[] = {
    1, // node
    1, // hostName
    1, // netAddr
    0
};
static int Struct_VxWorks_3_slotOffsets[3];
static JWRAP_structs Struct_VxWorks_3_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_3],
  3,
  Struct_VxWorks_3_slotNames,
  Struct_VxWorks_3_slotTypes,
  Struct_VxWorks_3_slotOffsets,
  Struct_VxWorks_3_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_3 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_3_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_3 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_3_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_3 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_3_struct, tclObj);
}
// Build Struct_VxWorks_3 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_3_type = {
  "Struct_VxWorks_3",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_3,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_3
  };
// Build Struct_VxWorks_3 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_3_ptr = {
  "Struct_VxWorks_3_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_3,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_3
  };

// Alloc bootp_msg slot structure for Put/Get functions
static char *bootp_msg_slotNames[] =  {
    "bp_op",
    "bp_htype",
    "bp_hlen",
    "bp_hops",
    "bp_xid",
    "bp_secs",
    "bp_unused",
    "bp_ciaddr",
    "bp_yiaddr",
    "bp_siaddr",
    "bp_giaddr",
    "bp_chaddr",
    "bp_sname",
    "bp_file",
    "bp_vend",
    NULL
};
static JWRAP_types *bootp_msg_slotTypes[] = {
    &usedType [JTYPE_char], // bp_op 
    &usedType [JTYPE_char], // bp_htype 
    &usedType [JTYPE_char], // bp_hlen 
    &usedType [JTYPE_char], // bp_hops 
    &usedType [JTYPE_long], // bp_xid 
    &usedType [JTYPE_short], // bp_secs 
    &usedType [JTYPE_short], // bp_unused 
    &usedType [JTYPE_in_addr], // bp_ciaddr 
    &usedType [JTYPE_in_addr], // bp_yiaddr 
    &usedType [JTYPE_in_addr], // bp_siaddr 
    &usedType [JTYPE_in_addr], // bp_giaddr 
    &usedType [JTYPE_char], // bp_chaddr 
    &usedType [JTYPE_char], // bp_sname 
    &usedType [JTYPE_char], // bp_file 
    &usedType [JTYPE_char], // bp_vend 
    NULL
};
static int bootp_msg_slotArrays[] = {
    1, // bp_op
    1, // bp_htype
    1, // bp_hlen
    1, // bp_hops
    1, // bp_xid
    1, // bp_secs
    1, // bp_unused
    1, // bp_ciaddr
    1, // bp_yiaddr
    1, // bp_siaddr
    1, // bp_giaddr
    16, // bp_chaddr
    64, // bp_sname
    128, // bp_file
    64, // bp_vend
    0
};
static int bootp_msg_slotOffsets[15];
static JWRAP_structs bootp_msg_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_bootp_msg],
  15,
  bootp_msg_slotNames,
  bootp_msg_slotTypes,
  bootp_msg_slotOffsets,
  bootp_msg_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_bootp_msg (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &bootp_msg_struct, srcObj, destObj));
}
LOCAL int Put_bootp_msg (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &bootp_msg_struct, srcObj, destObj));
}
LOCAL char* Get_bootp_msg (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&bootp_msg_struct, tclObj);
}
// Build bootp_msg structure as a Tcl type
static Tcl_ObjType bootp_msg_type = {
  "bootp_msg",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_bootp_msg,
  (Tcl_SetFromAnyProc*)      Put_bootp_msg
  };
// Build bootp_msg structure as a Tcl type
static Tcl_ObjType bootp_msg_ptr = {
  "bootp_msg_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_bootp_msg,
  (Tcl_SetFromAnyProc*)      Create_bootp_msg
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_4 {
  void* enableRtn;
  void* disableRtn;
  void* lockRtn;
  void* unlockRtn;
  void* flushRtn;
  void* invalidateRtn;
  void* clearRtn;
  void* textUpdateRtn;
  void* pipeFlushRtn;
  void* dmaMallocRtn;
  void* dmaFreeRtn;
  void* dmaVirtToPhysRtn;
  void* dmaPhysToVirtRtn;
};

// Alloc Struct_VxWorks_4 slot structure for Put/Get functions
static char *Struct_VxWorks_4_slotNames[] =  {
    "enableRtn",
    "disableRtn",
    "lockRtn",
    "unlockRtn",
    "flushRtn",
    "invalidateRtn",
    "clearRtn",
    "textUpdateRtn",
    "pipeFlushRtn",
    "dmaMallocRtn",
    "dmaFreeRtn",
    "dmaVirtToPhysRtn",
    "dmaPhysToVirtRtn",
    NULL
};
static JWRAP_types *Struct_VxWorks_4_slotTypes[] = {
    &usedType [JTYPE_void_Ptr], // enableRtn 
    &usedType [JTYPE_void_Ptr], // disableRtn 
    &usedType [JTYPE_void_Ptr], // lockRtn 
    &usedType [JTYPE_void_Ptr], // unlockRtn 
    &usedType [JTYPE_void_Ptr], // flushRtn 
    &usedType [JTYPE_void_Ptr], // invalidateRtn 
    &usedType [JTYPE_void_Ptr], // clearRtn 
    &usedType [JTYPE_void_Ptr], // textUpdateRtn 
    &usedType [JTYPE_void_Ptr], // pipeFlushRtn 
    &usedType [JTYPE_void_Ptr], // dmaMallocRtn 
    &usedType [JTYPE_void_Ptr], // dmaFreeRtn 
    &usedType [JTYPE_void_Ptr], // dmaVirtToPhysRtn 
    &usedType [JTYPE_void_Ptr], // dmaPhysToVirtRtn 
    NULL
};
static int Struct_VxWorks_4_slotArrays[] = {
    1, // enableRtn
    1, // disableRtn
    1, // lockRtn
    1, // unlockRtn
    1, // flushRtn
    1, // invalidateRtn
    1, // clearRtn
    1, // textUpdateRtn
    1, // pipeFlushRtn
    1, // dmaMallocRtn
    1, // dmaFreeRtn
    1, // dmaVirtToPhysRtn
    1, // dmaPhysToVirtRtn
    0
};
static int Struct_VxWorks_4_slotOffsets[13];
static JWRAP_structs Struct_VxWorks_4_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_4],
  13,
  Struct_VxWorks_4_slotNames,
  Struct_VxWorks_4_slotTypes,
  Struct_VxWorks_4_slotOffsets,
  Struct_VxWorks_4_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_4 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_4_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_4 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_4_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_4 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_4_struct, tclObj);
}
// Build Struct_VxWorks_4 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_4_type = {
  "Struct_VxWorks_4",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_4,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_4
  };
// Build Struct_VxWorks_4 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_4_ptr = {
  "Struct_VxWorks_4_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_4,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_4
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_5 {
  void* flushRtn;
  void* invalidateRtn;
  void* virtToPhysRtn;
  void* physToVirtRtn;
};

// Alloc Struct_VxWorks_5 slot structure for Put/Get functions
static char *Struct_VxWorks_5_slotNames[] =  {
    "flushRtn",
    "invalidateRtn",
    "virtToPhysRtn",
    "physToVirtRtn",
    NULL
};
static JWRAP_types *Struct_VxWorks_5_slotTypes[] = {
    &usedType [JTYPE_void_Ptr], // flushRtn 
    &usedType [JTYPE_void_Ptr], // invalidateRtn 
    &usedType [JTYPE_void_Ptr], // virtToPhysRtn 
    &usedType [JTYPE_void_Ptr], // physToVirtRtn 
    NULL
};
static int Struct_VxWorks_5_slotArrays[] = {
    1, // flushRtn
    1, // invalidateRtn
    1, // virtToPhysRtn
    1, // physToVirtRtn
    0
};
static int Struct_VxWorks_5_slotOffsets[4];
static JWRAP_structs Struct_VxWorks_5_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_5],
  4,
  Struct_VxWorks_5_slotNames,
  Struct_VxWorks_5_slotTypes,
  Struct_VxWorks_5_slotOffsets,
  Struct_VxWorks_5_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_5 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_5_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_5 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_5_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_5 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_5_struct, tclObj);
}
// Build Struct_VxWorks_5 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_5_type = {
  "Struct_VxWorks_5",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_5,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_5
  };
// Build Struct_VxWorks_5 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_5_ptr = {
  "Struct_VxWorks_5_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_5,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_5
  };

// Alloc dirent slot structure for Put/Get functions
static char *dirent_slotNames[] =  {
    "d_name",
    NULL
};
static JWRAP_types *dirent_slotTypes[] = {
    &usedType [JTYPE_char], // d_name 
    NULL
};
static int dirent_slotArrays[] = {
    256, // d_name
    0
};
static int dirent_slotOffsets[1];
static JWRAP_structs dirent_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_dirent],
  1,
  dirent_slotNames,
  dirent_slotTypes,
  dirent_slotOffsets,
  dirent_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_dirent (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &dirent_struct, srcObj, destObj));
}
LOCAL int Put_dirent (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &dirent_struct, srcObj, destObj));
}
LOCAL char* Get_dirent (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&dirent_struct, tclObj);
}
// Build dirent structure as a Tcl type
static Tcl_ObjType dirent_type = {
  "dirent",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_dirent,
  (Tcl_SetFromAnyProc*)      Put_dirent
  };
// Build dirent structure as a Tcl type
static Tcl_ObjType dirent_ptr = {
  "dirent_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_dirent,
  (Tcl_SetFromAnyProc*)      Create_dirent
  };

// Alloc slnode slot structure for Put/Get functions
static char *slnode_slotNames[] =  {
    "next",
    NULL
};
static JWRAP_types *slnode_slotTypes[] = {
    &usedType [JTYPE_slnode_Ptr], // next 
    NULL
};
static int slnode_slotArrays[] = {
    1, // next
    0
};
static int slnode_slotOffsets[1];
static JWRAP_structs slnode_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_slnode],
  1,
  slnode_slotNames,
  slnode_slotTypes,
  slnode_slotOffsets,
  slnode_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_slnode (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &slnode_struct, srcObj, destObj));
}
LOCAL int Put_slnode (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &slnode_struct, srcObj, destObj));
}
LOCAL char* Get_slnode (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&slnode_struct, tclObj);
}
// Build slnode structure as a Tcl type
static Tcl_ObjType slnode_type = {
  "slnode",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_slnode,
  (Tcl_SetFromAnyProc*)      Put_slnode
  };
// Build slnode structure as a Tcl type
static Tcl_ObjType slnode_ptr = {
  "slnode_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_slnode,
  (Tcl_SetFromAnyProc*)      Create_slnode
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_6 {
  HASH_NODE node;
  int key;
  int data;
};

// Alloc Struct_VxWorks_6 slot structure for Put/Get functions
static char *Struct_VxWorks_6_slotNames[] =  {
    "node",
    "key",
    "data",
    NULL
};
static JWRAP_types *Struct_VxWorks_6_slotTypes[] = {
    &usedType [JTYPE_HASH_NODE], // node 
    &usedType [JTYPE_int], // key 
    &usedType [JTYPE_int], // data 
    NULL
};
static int Struct_VxWorks_6_slotArrays[] = {
    1, // node
    1, // key
    1, // data
    0
};
static int Struct_VxWorks_6_slotOffsets[3];
static JWRAP_structs Struct_VxWorks_6_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_6],
  3,
  Struct_VxWorks_6_slotNames,
  Struct_VxWorks_6_slotTypes,
  Struct_VxWorks_6_slotOffsets,
  Struct_VxWorks_6_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_6 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_6_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_6 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_6_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_6 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_6_struct, tclObj);
}
// Build Struct_VxWorks_6 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_6_type = {
  "Struct_VxWorks_6",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_6,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_6
  };
// Build Struct_VxWorks_6 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_6_ptr = {
  "Struct_VxWorks_6_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_6,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_6
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_7 {
  HASH_NODE node;
  char* string;
  int data;
};

// Alloc Struct_VxWorks_7 slot structure for Put/Get functions
static char *Struct_VxWorks_7_slotNames[] =  {
    "node",
    "string",
    "data",
    NULL
};
static JWRAP_types *Struct_VxWorks_7_slotTypes[] = {
    &usedType [JTYPE_HASH_NODE], // node 
    &usedType [JTYPE_char_Ptr], // string 
    &usedType [JTYPE_int], // data 
    NULL
};
static int Struct_VxWorks_7_slotArrays[] = {
    1, // node
    1, // string
    1, // data
    0
};
static int Struct_VxWorks_7_slotOffsets[3];
static JWRAP_structs Struct_VxWorks_7_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_7],
  3,
  Struct_VxWorks_7_slotNames,
  Struct_VxWorks_7_slotTypes,
  Struct_VxWorks_7_slotOffsets,
  Struct_VxWorks_7_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_7 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_7_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_7 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_7_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_7 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_7_struct, tclObj);
}
// Build Struct_VxWorks_7 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_7_type = {
  "Struct_VxWorks_7",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_7,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_7
  };
// Build Struct_VxWorks_7 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_7_ptr = {
  "Struct_VxWorks_7_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_7,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_7
  };

// Alloc dlnode slot structure for Put/Get functions
static char *dlnode_slotNames[] =  {
    "next",
    "previous",
    NULL
};
static JWRAP_types *dlnode_slotTypes[] = {
    &usedType [JTYPE_dlnode_Ptr], // next 
    &usedType [JTYPE_dlnode_Ptr], // previous 
    NULL
};
static int dlnode_slotArrays[] = {
    1, // next
    1, // previous
    0
};
static int dlnode_slotOffsets[2];
static JWRAP_structs dlnode_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_dlnode],
  2,
  dlnode_slotNames,
  dlnode_slotTypes,
  dlnode_slotOffsets,
  dlnode_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_dlnode (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &dlnode_struct, srcObj, destObj));
}
LOCAL int Put_dlnode (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &dlnode_struct, srcObj, destObj));
}
LOCAL char* Get_dlnode (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&dlnode_struct, tclObj);
}
// Build dlnode structure as a Tcl type
static Tcl_ObjType dlnode_type = {
  "dlnode",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_dlnode,
  (Tcl_SetFromAnyProc*)      Put_dlnode
  };
// Build dlnode structure as a Tcl type
static Tcl_ObjType dlnode_ptr = {
  "dlnode_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_dlnode,
  (Tcl_SetFromAnyProc*)      Create_dlnode
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_8 {
  DL_NODE node;
  short drvNum;
  char* name;
};

// Alloc Struct_VxWorks_8 slot structure for Put/Get functions
static char *Struct_VxWorks_8_slotNames[] =  {
    "node",
    "drvNum",
    "name",
    NULL
};
static JWRAP_types *Struct_VxWorks_8_slotTypes[] = {
    &usedType [JTYPE_DL_NODE], // node 
    &usedType [JTYPE_short], // drvNum 
    &usedType [JTYPE_char_Ptr], // name 
    NULL
};
static int Struct_VxWorks_8_slotArrays[] = {
    1, // node
    1, // drvNum
    1, // name
    0
};
static int Struct_VxWorks_8_slotOffsets[3];
static JWRAP_structs Struct_VxWorks_8_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_8],
  3,
  Struct_VxWorks_8_slotNames,
  Struct_VxWorks_8_slotTypes,
  Struct_VxWorks_8_slotOffsets,
  Struct_VxWorks_8_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_8 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_8_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_8 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_8_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_8 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_8_struct, tclObj);
}
// Build Struct_VxWorks_8 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_8_type = {
  "Struct_VxWorks_8",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_8,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_8
  };
// Build Struct_VxWorks_8 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_8_ptr = {
  "Struct_VxWorks_8_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_8,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_8
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_9 {
  UINT8 dospt_status;
  UINT8 dospt_startHead;
  short dospt_startSec;
  UINT8 dospt_type;
  UINT8 dospt_endHead;
  short dospt_endSec;
  ULONG dospt_absSec;
  ULONG dospt_nSectors;
};

// Alloc Struct_VxWorks_9 slot structure for Put/Get functions
static char *Struct_VxWorks_9_slotNames[] =  {
    "dospt_status",
    "dospt_startHead",
    "dospt_startSec",
    "dospt_type",
    "dospt_endHead",
    "dospt_endSec",
    "dospt_absSec",
    "dospt_nSectors",
    NULL
};
static JWRAP_types *Struct_VxWorks_9_slotTypes[] = {
    &usedType [JTYPE_UINT8], // dospt_status 
    &usedType [JTYPE_UINT8], // dospt_startHead 
    &usedType [JTYPE_short], // dospt_startSec 
    &usedType [JTYPE_UINT8], // dospt_type 
    &usedType [JTYPE_UINT8], // dospt_endHead 
    &usedType [JTYPE_short], // dospt_endSec 
    &usedType [JTYPE_ULONG], // dospt_absSec 
    &usedType [JTYPE_ULONG], // dospt_nSectors 
    NULL
};
static int Struct_VxWorks_9_slotArrays[] = {
    1, // dospt_status
    1, // dospt_startHead
    1, // dospt_startSec
    1, // dospt_type
    1, // dospt_endHead
    1, // dospt_endSec
    1, // dospt_absSec
    1, // dospt_nSectors
    0
};
static int Struct_VxWorks_9_slotOffsets[8];
static JWRAP_structs Struct_VxWorks_9_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_9],
  8,
  Struct_VxWorks_9_slotNames,
  Struct_VxWorks_9_slotTypes,
  Struct_VxWorks_9_slotOffsets,
  Struct_VxWorks_9_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_9 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_9_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_9 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_9_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_9 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_9_struct, tclObj);
}
// Build Struct_VxWorks_9 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_9_type = {
  "Struct_VxWorks_9",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_9,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_9
  };
// Build Struct_VxWorks_9 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_9_ptr = {
  "Struct_VxWorks_9_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_9,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_9
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_10 {
  UINT8 dosdde_name;
  UINT8 dosdde_ext;
  UINT8 dosdde_attrib;
  char dosdde_reserved;
  USHORT dosdde_time;
  USHORT dosdde_date;
  USHORT dosdde_cluster;
  ULONG dosdde_size;
};

// Alloc Struct_VxWorks_10 slot structure for Put/Get functions
static char *Struct_VxWorks_10_slotNames[] =  {
    "dosdde_name",
    "dosdde_ext",
    "dosdde_attrib",
    "dosdde_reserved",
    "dosdde_time",
    "dosdde_date",
    "dosdde_cluster",
    "dosdde_size",
    NULL
};
static JWRAP_types *Struct_VxWorks_10_slotTypes[] = {
    &usedType [JTYPE_UINT8], // dosdde_name 
    &usedType [JTYPE_UINT8], // dosdde_ext 
    &usedType [JTYPE_UINT8], // dosdde_attrib 
    &usedType [JTYPE_char], // dosdde_reserved 
    &usedType [JTYPE_USHORT], // dosdde_time 
    &usedType [JTYPE_USHORT], // dosdde_date 
    &usedType [JTYPE_USHORT], // dosdde_cluster 
    &usedType [JTYPE_ULONG], // dosdde_size 
    NULL
};
static int Struct_VxWorks_10_slotArrays[] = {
    8, // dosdde_name
    3, // dosdde_ext
    1, // dosdde_attrib
    10, // dosdde_reserved
    1, // dosdde_time
    1, // dosdde_date
    1, // dosdde_cluster
    1, // dosdde_size
    0
};
static int Struct_VxWorks_10_slotOffsets[8];
static JWRAP_structs Struct_VxWorks_10_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_10],
  8,
  Struct_VxWorks_10_slotNames,
  Struct_VxWorks_10_slotTypes,
  Struct_VxWorks_10_slotOffsets,
  Struct_VxWorks_10_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_10 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_10_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_10 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_10_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_10 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_10_struct, tclObj);
}
// Build Struct_VxWorks_10 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_10_type = {
  "Struct_VxWorks_10",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_10,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_10
  };
// Build Struct_VxWorks_10 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_10_ptr = {
  "Struct_VxWorks_10_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_10,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_10
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_11 {
  UINT8 dosdee_name;
  char dosdee_reserved;
  UINT8 dosdee_attrib;
  USHORT dosdee_time;
  USHORT dosdee_date;
  USHORT dosdee_cluster;
  ULONG dosdee_size;
};

// Alloc Struct_VxWorks_11 slot structure for Put/Get functions
static char *Struct_VxWorks_11_slotNames[] =  {
    "dosdee_name",
    "dosdee_reserved",
    "dosdee_attrib",
    "dosdee_time",
    "dosdee_date",
    "dosdee_cluster",
    "dosdee_size",
    NULL
};
static JWRAP_types *Struct_VxWorks_11_slotTypes[] = {
    &usedType [JTYPE_UINT8], // dosdee_name 
    &usedType [JTYPE_char], // dosdee_reserved 
    &usedType [JTYPE_UINT8], // dosdee_attrib 
    &usedType [JTYPE_USHORT], // dosdee_time 
    &usedType [JTYPE_USHORT], // dosdee_date 
    &usedType [JTYPE_USHORT], // dosdee_cluster 
    &usedType [JTYPE_ULONG], // dosdee_size 
    NULL
};
static int Struct_VxWorks_11_slotArrays[] = {
    40, // dosdee_name
    13, // dosdee_reserved
    1, // dosdee_attrib
    1, // dosdee_time
    1, // dosdee_date
    1, // dosdee_cluster
    1, // dosdee_size
    0
};
static int Struct_VxWorks_11_slotOffsets[7];
static JWRAP_structs Struct_VxWorks_11_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_11],
  7,
  Struct_VxWorks_11_slotNames,
  Struct_VxWorks_11_slotTypes,
  Struct_VxWorks_11_slotOffsets,
  Struct_VxWorks_11_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_11 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_11_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_11 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_11_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_11 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_11_struct, tclObj);
}
// Build Struct_VxWorks_11 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_11_type = {
  "Struct_VxWorks_11",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_11,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_11
  };
// Build Struct_VxWorks_11 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_11_ptr = {
  "Struct_VxWorks_11_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_11,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_11
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_12 {
  char dosvc_mediaByte;
  UINT8 dosvc_secPerClust;
  short dosvc_nResrvd;
  char dosvc_nFats;
  UINT16 dosvc_secPerFat;
  short dosvc_maxRootEnts;
  UINT dosvc_nHidden;
  UINT dosvc_options;
  UINT dosvc_reserved;
};

// Alloc Struct_VxWorks_12 slot structure for Put/Get functions
static char *Struct_VxWorks_12_slotNames[] =  {
    "dosvc_mediaByte",
    "dosvc_secPerClust",
    "dosvc_nResrvd",
    "dosvc_nFats",
    "dosvc_secPerFat",
    "dosvc_maxRootEnts",
    "dosvc_nHidden",
    "dosvc_options",
    "dosvc_reserved",
    NULL
};
static JWRAP_types *Struct_VxWorks_12_slotTypes[] = {
    &usedType [JTYPE_char], // dosvc_mediaByte 
    &usedType [JTYPE_UINT8], // dosvc_secPerClust 
    &usedType [JTYPE_short], // dosvc_nResrvd 
    &usedType [JTYPE_char], // dosvc_nFats 
    &usedType [JTYPE_UINT16], // dosvc_secPerFat 
    &usedType [JTYPE_short], // dosvc_maxRootEnts 
    &usedType [JTYPE_UINT], // dosvc_nHidden 
    &usedType [JTYPE_UINT], // dosvc_options 
    &usedType [JTYPE_UINT], // dosvc_reserved 
    NULL
};
static int Struct_VxWorks_12_slotArrays[] = {
    1, // dosvc_mediaByte
    1, // dosvc_secPerClust
    1, // dosvc_nResrvd
    1, // dosvc_nFats
    1, // dosvc_secPerFat
    1, // dosvc_maxRootEnts
    1, // dosvc_nHidden
    1, // dosvc_options
    1, // dosvc_reserved
    0
};
static int Struct_VxWorks_12_slotOffsets[9];
static JWRAP_structs Struct_VxWorks_12_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_12],
  9,
  Struct_VxWorks_12_slotNames,
  Struct_VxWorks_12_slotTypes,
  Struct_VxWorks_12_slotOffsets,
  Struct_VxWorks_12_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_12 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_12_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_12 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_12_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_12 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_12_struct, tclObj);
}
// Build Struct_VxWorks_12 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_12_type = {
  "Struct_VxWorks_12",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_12,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_12
  };
// Build Struct_VxWorks_12 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_12_ptr = {
  "Struct_VxWorks_12_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_12,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_12
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_13 {
  DEV_HDR dosvd_devHdr;
  short dosvd_status;
  char dosvd_sysId;
  SEM_ID dosvd_semId;
  void* dosvd_pBlkDev;
  char dosvd_mediaByte;
  UINT8 dosvd_secPerClust;
  UINT dosvd_bytesPerClust;
  UINT8 dosvd_nFats;
  UINT16 dosvd_secPerFat;
  int dosvd_nFatEnts;
  int dosvd_fat12Bit;
  int dosvd_fatModified;
  UINT8* dosvd_pFatBuf;
  int dosvd_fatEntFreeCnt;
  USHORT dosvd_maxRootEnts;
  ULONG dosvd_nRootEnts;
  int dosvd_rootSec;
  DOS_DIR_ENT* dosvd_pRoot;
  USHORT dosvd_nResrvdSecs;
  ULONG dosvd_nHiddenSecs;
  UINT dosvd_dataSec;
  UINT8 dosvd_driveNum;
  UINT8 dosvd_bootSigRec;
  ULONG dosvd_volId;
  char dosvd_volLabel;
  int dosvd_state;
  int dosvd_retry;
  UINT dosvd_options;
  UINT8* dosvd_pFatModTbl;
  HASH_ID dosvd_hashTbl;
  int dosvd_uid;
  int dosvd_gid;
  int dosvd_mode;
};

// Alloc Struct_VxWorks_13 slot structure for Put/Get functions
static char *Struct_VxWorks_13_slotNames[] =  {
    "dosvd_devHdr",
    "dosvd_status",
    "dosvd_sysId",
    "dosvd_semId",
    "dosvd_pBlkDev",
    "dosvd_mediaByte",
    "dosvd_secPerClust",
    "dosvd_bytesPerClust",
    "dosvd_nFats",
    "dosvd_secPerFat",
    "dosvd_nFatEnts",
    "dosvd_fat12Bit",
    "dosvd_fatModified",
    "dosvd_pFatBuf",
    "dosvd_fatEntFreeCnt",
    "dosvd_maxRootEnts",
    "dosvd_nRootEnts",
    "dosvd_rootSec",
    "dosvd_pRoot",
    "dosvd_nResrvdSecs",
    "dosvd_nHiddenSecs",
    "dosvd_dataSec",
    "dosvd_driveNum",
    "dosvd_bootSigRec",
    "dosvd_volId",
    "dosvd_volLabel",
    "dosvd_state",
    "dosvd_retry",
    "dosvd_options",
    "dosvd_pFatModTbl",
    "dosvd_hashTbl",
    "dosvd_uid",
    "dosvd_gid",
    "dosvd_mode",
    NULL
};
static JWRAP_types *Struct_VxWorks_13_slotTypes[] = {
    &usedType [JTYPE_DEV_HDR], // dosvd_devHdr 
    &usedType [JTYPE_short], // dosvd_status 
    &usedType [JTYPE_char], // dosvd_sysId 
    &usedType [JTYPE_SEM_ID], // dosvd_semId 
    &usedType [JTYPE_void_Ptr], // dosvd_pBlkDev 
    &usedType [JTYPE_char], // dosvd_mediaByte 
    &usedType [JTYPE_UINT8], // dosvd_secPerClust 
    &usedType [JTYPE_UINT], // dosvd_bytesPerClust 
    &usedType [JTYPE_UINT8], // dosvd_nFats 
    &usedType [JTYPE_UINT16], // dosvd_secPerFat 
    &usedType [JTYPE_int], // dosvd_nFatEnts 
    &usedType [JTYPE_int], // dosvd_fat12Bit 
    &usedType [JTYPE_int], // dosvd_fatModified 
    &usedType [JTYPE_UINT8_Ptr], // dosvd_pFatBuf 
    &usedType [JTYPE_int], // dosvd_fatEntFreeCnt 
    &usedType [JTYPE_USHORT], // dosvd_maxRootEnts 
    &usedType [JTYPE_ULONG], // dosvd_nRootEnts 
    &usedType [JTYPE_int], // dosvd_rootSec 
    &usedType [JTYPE_DOS_DIR_ENT_Ptr], // dosvd_pRoot 
    &usedType [JTYPE_USHORT], // dosvd_nResrvdSecs 
    &usedType [JTYPE_ULONG], // dosvd_nHiddenSecs 
    &usedType [JTYPE_UINT], // dosvd_dataSec 
    &usedType [JTYPE_UINT8], // dosvd_driveNum 
    &usedType [JTYPE_UINT8], // dosvd_bootSigRec 
    &usedType [JTYPE_ULONG], // dosvd_volId 
    &usedType [JTYPE_char], // dosvd_volLabel 
    &usedType [JTYPE_int], // dosvd_state 
    &usedType [JTYPE_int], // dosvd_retry 
    &usedType [JTYPE_UINT], // dosvd_options 
    &usedType [JTYPE_UINT8_Ptr], // dosvd_pFatModTbl 
    &usedType [JTYPE_HASH_ID], // dosvd_hashTbl 
    &usedType [JTYPE_int], // dosvd_uid 
    &usedType [JTYPE_int], // dosvd_gid 
    &usedType [JTYPE_int], // dosvd_mode 
    NULL
};
static int Struct_VxWorks_13_slotArrays[] = {
    1, // dosvd_devHdr
    1, // dosvd_status
    8, // dosvd_sysId
    1, // dosvd_semId
    1, // dosvd_pBlkDev
    1, // dosvd_mediaByte
    1, // dosvd_secPerClust
    1, // dosvd_bytesPerClust
    1, // dosvd_nFats
    1, // dosvd_secPerFat
    1, // dosvd_nFatEnts
    1, // dosvd_fat12Bit
    1, // dosvd_fatModified
    1, // dosvd_pFatBuf
    1, // dosvd_fatEntFreeCnt
    1, // dosvd_maxRootEnts
    1, // dosvd_nRootEnts
    1, // dosvd_rootSec
    1, // dosvd_pRoot
    1, // dosvd_nResrvdSecs
    1, // dosvd_nHiddenSecs
    1, // dosvd_dataSec
    1, // dosvd_driveNum
    1, // dosvd_bootSigRec
    1, // dosvd_volId
    8, // dosvd_volLabel
    1, // dosvd_state
    1, // dosvd_retry
    1, // dosvd_options
    1, // dosvd_pFatModTbl
    1, // dosvd_hashTbl
    1, // dosvd_uid
    1, // dosvd_gid
    1, // dosvd_mode
    0
};
static int Struct_VxWorks_13_slotOffsets[34];
static JWRAP_structs Struct_VxWorks_13_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_13],
  34,
  Struct_VxWorks_13_slotNames,
  Struct_VxWorks_13_slotTypes,
  Struct_VxWorks_13_slotOffsets,
  Struct_VxWorks_13_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_13 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_13_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_13 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_13_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_13 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_13_struct, tclObj);
}
// Build Struct_VxWorks_13 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_13_type = {
  "Struct_VxWorks_13",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_13,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_13
  };
// Build Struct_VxWorks_13 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_13_ptr = {
  "Struct_VxWorks_13_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_13,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_13
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_14 {
  int dosdt_year;
  int dosdt_month;
  int dosdt_day;
  int dosdt_hour;
  int dosdt_minute;
  int dosdt_second;
};

// Alloc Struct_VxWorks_14 slot structure for Put/Get functions
static char *Struct_VxWorks_14_slotNames[] =  {
    "dosdt_year",
    "dosdt_month",
    "dosdt_day",
    "dosdt_hour",
    "dosdt_minute",
    "dosdt_second",
    NULL
};
static JWRAP_types *Struct_VxWorks_14_slotTypes[] = {
    &usedType [JTYPE_int], // dosdt_year 
    &usedType [JTYPE_int], // dosdt_month 
    &usedType [JTYPE_int], // dosdt_day 
    &usedType [JTYPE_int], // dosdt_hour 
    &usedType [JTYPE_int], // dosdt_minute 
    &usedType [JTYPE_int], // dosdt_second 
    NULL
};
static int Struct_VxWorks_14_slotArrays[] = {
    1, // dosdt_year
    1, // dosdt_month
    1, // dosdt_day
    1, // dosdt_hour
    1, // dosdt_minute
    1, // dosdt_second
    0
};
static int Struct_VxWorks_14_slotOffsets[6];
static JWRAP_structs Struct_VxWorks_14_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_14],
  6,
  Struct_VxWorks_14_slotNames,
  Struct_VxWorks_14_slotTypes,
  Struct_VxWorks_14_slotOffsets,
  Struct_VxWorks_14_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_14 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_14_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_14 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_14_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_14 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_14_struct, tclObj);
}
// Build Struct_VxWorks_14 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_14_type = {
  "Struct_VxWorks_14",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_14,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_14
  };
// Build Struct_VxWorks_14 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_14_ptr = {
  "Struct_VxWorks_14_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_14,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_14
  };

// Alloc buffers slot structure for Put/Get functions
static char *buffers_slotNames[] =  {
    "bufferIndexInUse",
    "bufferInUse",
    "bufferInReserve",
    "bufferIndexInReserve",
    NULL
};
static JWRAP_types *buffers_slotTypes[] = {
    &usedType [JTYPE_char_Ptr], // bufferIndexInUse 
    &usedType [JTYPE_char_Ptr], // bufferInUse 
    &usedType [JTYPE_char_Ptr], // bufferInReserve 
    &usedType [JTYPE_char_Ptr], // bufferIndexInReserve 
    NULL
};
static int buffers_slotArrays[] = {
    1, // bufferIndexInUse
    1, // bufferInUse
    1, // bufferInReserve
    1, // bufferIndexInReserve
    0
};
static int buffers_slotOffsets[4];
static JWRAP_structs buffers_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_buffers],
  4,
  buffers_slotNames,
  buffers_slotTypes,
  buffers_slotOffsets,
  buffers_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_buffers (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &buffers_struct, srcObj, destObj));
}
LOCAL int Put_buffers (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &buffers_struct, srcObj, destObj));
}
LOCAL char* Get_buffers (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&buffers_struct, tclObj);
}
// Build buffers structure as a Tcl type
static Tcl_ObjType buffers_type = {
  "buffers",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_buffers,
  (Tcl_SetFromAnyProc*)      Put_buffers
  };
// Build buffers structure as a Tcl type
static Tcl_ObjType buffers_ptr = {
  "buffers_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_buffers,
  (Tcl_SetFromAnyProc*)      Create_buffers
  };

// Alloc excfaultTab slot structure for Put/Get functions
static char *excfaultTab_slotNames[] =  {
    "faultType",
    "subtype",
    "signal",
    "code",
    NULL
};
static JWRAP_types *excfaultTab_slotTypes[] = {
    &usedType [JTYPE_int], // faultType 
    &usedType [JTYPE_int], // subtype 
    &usedType [JTYPE_int], // signal 
    &usedType [JTYPE_int], // code 
    NULL
};
static int excfaultTab_slotArrays[] = {
    1, // faultType
    1, // subtype
    1, // signal
    1, // code
    0
};
static int excfaultTab_slotOffsets[4];
static JWRAP_structs excfaultTab_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_excfaultTab],
  4,
  excfaultTab_slotNames,
  excfaultTab_slotTypes,
  excfaultTab_slotOffsets,
  excfaultTab_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_excfaultTab (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &excfaultTab_struct, srcObj, destObj));
}
LOCAL int Put_excfaultTab (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &excfaultTab_struct, srcObj, destObj));
}
LOCAL char* Get_excfaultTab (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&excfaultTab_struct, tclObj);
}
// Build excfaultTab structure as a Tcl type
static Tcl_ObjType excfaultTab_type = {
  "excfaultTab",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_excfaultTab,
  (Tcl_SetFromAnyProc*)      Put_excfaultTab
  };
// Build excfaultTab structure as a Tcl type
static Tcl_ObjType excfaultTab_ptr = {
  "excfaultTab_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_excfaultTab,
  (Tcl_SetFromAnyProc*)      Create_excfaultTab
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_15 {
  char* addrText;
  char* addrData;
  char* addrBss;
  UINT sizeText;
  UINT sizeProtectedText;
  UINT sizeData;
  UINT sizeBss;
  int flagsText;
  int flagsData;
  int flagsBss;
};

// Alloc Struct_VxWorks_15 slot structure for Put/Get functions
static char *Struct_VxWorks_15_slotNames[] =  {
    "addrText",
    "addrData",
    "addrBss",
    "sizeText",
    "sizeProtectedText",
    "sizeData",
    "sizeBss",
    "flagsText",
    "flagsData",
    "flagsBss",
    NULL
};
static JWRAP_types *Struct_VxWorks_15_slotTypes[] = {
    &usedType [JTYPE_char_Ptr], // addrText 
    &usedType [JTYPE_char_Ptr], // addrData 
    &usedType [JTYPE_char_Ptr], // addrBss 
    &usedType [JTYPE_UINT], // sizeText 
    &usedType [JTYPE_UINT], // sizeProtectedText 
    &usedType [JTYPE_UINT], // sizeData 
    &usedType [JTYPE_UINT], // sizeBss 
    &usedType [JTYPE_int], // flagsText 
    &usedType [JTYPE_int], // flagsData 
    &usedType [JTYPE_int], // flagsBss 
    NULL
};
static int Struct_VxWorks_15_slotArrays[] = {
    1, // addrText
    1, // addrData
    1, // addrBss
    1, // sizeText
    1, // sizeProtectedText
    1, // sizeData
    1, // sizeBss
    1, // flagsText
    1, // flagsData
    1, // flagsBss
    0
};
static int Struct_VxWorks_15_slotOffsets[10];
static JWRAP_structs Struct_VxWorks_15_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_15],
  10,
  Struct_VxWorks_15_slotNames,
  Struct_VxWorks_15_slotTypes,
  Struct_VxWorks_15_slotOffsets,
  Struct_VxWorks_15_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_15 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_15_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_15 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_15_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_15 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_15_struct, tclObj);
}
// Build Struct_VxWorks_15 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_15_type = {
  "Struct_VxWorks_15",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_15,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_15
  };
// Build Struct_VxWorks_15 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_15_ptr = {
  "Struct_VxWorks_15_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_15,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_15
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_16 {
  unsigned long numBytesFree;
  unsigned long numBlocksFree;
  unsigned long maxBlockSizeFree;
  unsigned long numBytesAlloc;
  unsigned long numBlocksAlloc;
};

// Alloc Struct_VxWorks_16 slot structure for Put/Get functions
static char *Struct_VxWorks_16_slotNames[] =  {
    "numBytesFree",
    "numBlocksFree",
    "maxBlockSizeFree",
    "numBytesAlloc",
    "numBlocksAlloc",
    NULL
};
static JWRAP_types *Struct_VxWorks_16_slotTypes[] = {
    &usedType [JTYPE_long], // numBytesFree 
    &usedType [JTYPE_long], // numBlocksFree 
    &usedType [JTYPE_long], // maxBlockSizeFree 
    &usedType [JTYPE_long], // numBytesAlloc 
    &usedType [JTYPE_long], // numBlocksAlloc 
    NULL
};
static int Struct_VxWorks_16_slotArrays[] = {
    1, // numBytesFree
    1, // numBlocksFree
    1, // maxBlockSizeFree
    1, // numBytesAlloc
    1, // numBlocksAlloc
    0
};
static int Struct_VxWorks_16_slotOffsets[5];
static JWRAP_structs Struct_VxWorks_16_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_16],
  5,
  Struct_VxWorks_16_slotNames,
  Struct_VxWorks_16_slotTypes,
  Struct_VxWorks_16_slotOffsets,
  Struct_VxWorks_16_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_16 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_16_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_16 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_16_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_16 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_16_struct, tclObj);
}
// Build Struct_VxWorks_16 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_16_type = {
  "Struct_VxWorks_16",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_16,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_16
  };
// Build Struct_VxWorks_16 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_16_ptr = {
  "Struct_VxWorks_16_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_16,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_16
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_17 {
  DL_NODE segmentNode;
  void* address;
  int size;
  int type;
  int flags;
  u_short checksum;
};

// Alloc Struct_VxWorks_17 slot structure for Put/Get functions
static char *Struct_VxWorks_17_slotNames[] =  {
    "segmentNode",
    "address",
    "size",
    "type",
    "flags",
    "checksum",
    NULL
};
static JWRAP_types *Struct_VxWorks_17_slotTypes[] = {
    &usedType [JTYPE_DL_NODE], // segmentNode 
    &usedType [JTYPE_void_Ptr], // address 
    &usedType [JTYPE_int], // size 
    &usedType [JTYPE_int], // type 
    &usedType [JTYPE_int], // flags 
    &usedType [JTYPE_u_short], // checksum 
    NULL
};
static int Struct_VxWorks_17_slotArrays[] = {
    1, // segmentNode
    1, // address
    1, // size
    1, // type
    1, // flags
    1, // checksum
    0
};
static int Struct_VxWorks_17_slotOffsets[6];
static JWRAP_structs Struct_VxWorks_17_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_17],
  6,
  Struct_VxWorks_17_slotNames,
  Struct_VxWorks_17_slotTypes,
  Struct_VxWorks_17_slotOffsets,
  Struct_VxWorks_17_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_17 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_17_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_17 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_17_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_17 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_17_struct, tclObj);
}
// Build Struct_VxWorks_17 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_17_type = {
  "Struct_VxWorks_17",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_17,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_17
  };
// Build Struct_VxWorks_17 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_17_ptr = {
  "Struct_VxWorks_17_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_17,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_17
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_18 {
  void* textAddr;
  void* dataAddr;
  void* bssAddr;
  int textSize;
  int dataSize;
  int bssSize;
};

// Alloc Struct_VxWorks_18 slot structure for Put/Get functions
static char *Struct_VxWorks_18_slotNames[] =  {
    "textAddr",
    "dataAddr",
    "bssAddr",
    "textSize",
    "dataSize",
    "bssSize",
    NULL
};
static JWRAP_types *Struct_VxWorks_18_slotTypes[] = {
    &usedType [JTYPE_void_Ptr], // textAddr 
    &usedType [JTYPE_void_Ptr], // dataAddr 
    &usedType [JTYPE_void_Ptr], // bssAddr 
    &usedType [JTYPE_int], // textSize 
    &usedType [JTYPE_int], // dataSize 
    &usedType [JTYPE_int], // bssSize 
    NULL
};
static int Struct_VxWorks_18_slotArrays[] = {
    1, // textAddr
    1, // dataAddr
    1, // bssAddr
    1, // textSize
    1, // dataSize
    1, // bssSize
    0
};
static int Struct_VxWorks_18_slotOffsets[6];
static JWRAP_structs Struct_VxWorks_18_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_18],
  6,
  Struct_VxWorks_18_slotNames,
  Struct_VxWorks_18_slotTypes,
  Struct_VxWorks_18_slotOffsets,
  Struct_VxWorks_18_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_18 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_18_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_18 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_18_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_18 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_18_struct, tclObj);
}
// Build Struct_VxWorks_18 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_18_type = {
  "Struct_VxWorks_18",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_18,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_18
  };
// Build Struct_VxWorks_18 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_18_ptr = {
  "Struct_VxWorks_18_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_18,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_18
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_19 {
  char name;
  int format;
  int group;
  MODULE_SEG_INFO segInfo;
};

// Alloc Struct_VxWorks_19 slot structure for Put/Get functions
static char *Struct_VxWorks_19_slotNames[] =  {
    "name",
    "format",
    "group",
    "segInfo",
    NULL
};
static JWRAP_types *Struct_VxWorks_19_slotTypes[] = {
    &usedType [JTYPE_char], // name 
    &usedType [JTYPE_int], // format 
    &usedType [JTYPE_int], // group 
    &usedType [JTYPE_MODULE_SEG_INFO], // segInfo 
    NULL
};
static int Struct_VxWorks_19_slotArrays[] = {
    99, // name
    1, // format
    1, // group
    1, // segInfo
    0
};
static int Struct_VxWorks_19_slotOffsets[4];
static JWRAP_structs Struct_VxWorks_19_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_19],
  4,
  Struct_VxWorks_19_slotNames,
  Struct_VxWorks_19_slotTypes,
  Struct_VxWorks_19_slotOffsets,
  Struct_VxWorks_19_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_19 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_19_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_19 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_19_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_19 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_19_struct, tclObj);
}
// Build Struct_VxWorks_19 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_19_type = {
  "Struct_VxWorks_19",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_19,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_19
  };
// Build Struct_VxWorks_19 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_19_ptr = {
  "Struct_VxWorks_19_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_19,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_19
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_20 {
  char* next;
  char* prev;
  char dirName;
  int dirFd;
  ULONG fsId;
  int volumeId;
  int readOnly;
};

// Alloc Struct_VxWorks_20 slot structure for Put/Get functions
static char *Struct_VxWorks_20_slotNames[] =  {
    "next",
    "prev",
    "dirName",
    "dirFd",
    "fsId",
    "volumeId",
    "readOnly",
    NULL
};
static JWRAP_types *Struct_VxWorks_20_slotTypes[] = {
    &usedType [JTYPE_char_Ptr], // next 
    &usedType [JTYPE_char_Ptr], // prev 
    &usedType [JTYPE_char], // dirName 
    &usedType [JTYPE_int], // dirFd 
    &usedType [JTYPE_ULONG], // fsId 
    &usedType [JTYPE_int], // volumeId 
    &usedType [JTYPE_int], // readOnly 
    NULL
};
static int Struct_VxWorks_20_slotArrays[] = {
    1, // next
    1, // prev
    255, // dirName
    1, // dirFd
    1, // fsId
    1, // volumeId
    1, // readOnly
    0
};
static int Struct_VxWorks_20_slotOffsets[7];
static JWRAP_structs Struct_VxWorks_20_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_20],
  7,
  Struct_VxWorks_20_slotNames,
  Struct_VxWorks_20_slotTypes,
  Struct_VxWorks_20_slotOffsets,
  Struct_VxWorks_20_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_20 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_20_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_20 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_20_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_20 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_20_struct, tclObj);
}
// Build Struct_VxWorks_20 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_20_type = {
  "Struct_VxWorks_20",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_20,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_20
  };
// Build Struct_VxWorks_20 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_20_ptr = {
  "Struct_VxWorks_20_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_20,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_20
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_21 {
  int numMsgs;
  int numTasks;
  int sendTimeouts;
  int recvTimeouts;
  int options;
  int maxMsgs;
  int maxMsgLength;
  int taskIdListMax;
  int* taskIdList;
  int msgListMax;
  void* msgPtrList;
  int* msgLenList;
};

// Alloc Struct_VxWorks_21 slot structure for Put/Get functions
static char *Struct_VxWorks_21_slotNames[] =  {
    "numMsgs",
    "numTasks",
    "sendTimeouts",
    "recvTimeouts",
    "options",
    "maxMsgs",
    "maxMsgLength",
    "taskIdListMax",
    "taskIdList",
    "msgListMax",
    "msgPtrList",
    "msgLenList",
    NULL
};
static JWRAP_types *Struct_VxWorks_21_slotTypes[] = {
    &usedType [JTYPE_int], // numMsgs 
    &usedType [JTYPE_int], // numTasks 
    &usedType [JTYPE_int], // sendTimeouts 
    &usedType [JTYPE_int], // recvTimeouts 
    &usedType [JTYPE_int], // options 
    &usedType [JTYPE_int], // maxMsgs 
    &usedType [JTYPE_int], // maxMsgLength 
    &usedType [JTYPE_int], // taskIdListMax 
    &usedType [JTYPE_int_Ptr], // taskIdList 
    &usedType [JTYPE_int], // msgListMax 
    &usedType [JTYPE_void_Ptr], // msgPtrList 
    &usedType [JTYPE_int_Ptr], // msgLenList 
    NULL
};
static int Struct_VxWorks_21_slotArrays[] = {
    1, // numMsgs
    1, // numTasks
    1, // sendTimeouts
    1, // recvTimeouts
    1, // options
    1, // maxMsgs
    1, // maxMsgLength
    1, // taskIdListMax
    1, // taskIdList
    1, // msgListMax
    1, // msgPtrList
    1, // msgLenList
    0
};
static int Struct_VxWorks_21_slotOffsets[12];
static JWRAP_structs Struct_VxWorks_21_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_21],
  12,
  Struct_VxWorks_21_slotNames,
  Struct_VxWorks_21_slotTypes,
  Struct_VxWorks_21_slotOffsets,
  Struct_VxWorks_21_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_21 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_21_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_21 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_21_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_21 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_21_struct, tclObj);
}
// Build Struct_VxWorks_21 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_21_type = {
  "Struct_VxWorks_21",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_21,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_21
  };
// Build Struct_VxWorks_21 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_21_ptr = {
  "Struct_VxWorks_21_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_21,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_21
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_22 {
  int volumeId;
  ULONG fsId;
  ULONG inode;
  INT8 reserved;
};

// Alloc Struct_VxWorks_22 slot structure for Put/Get functions
static char *Struct_VxWorks_22_slotNames[] =  {
    "volumeId",
    "fsId",
    "inode",
    "reserved",
    NULL
};
static JWRAP_types *Struct_VxWorks_22_slotTypes[] = {
    &usedType [JTYPE_int], // volumeId 
    &usedType [JTYPE_ULONG], // fsId 
    &usedType [JTYPE_ULONG], // inode 
    &usedType [JTYPE_INT8], // reserved 
    NULL
};
static int Struct_VxWorks_22_slotArrays[] = {
    1, // volumeId
    1, // fsId
    1, // inode
    24, // reserved
    0
};
static int Struct_VxWorks_22_slotOffsets[4];
static JWRAP_structs Struct_VxWorks_22_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_22],
  4,
  Struct_VxWorks_22_slotNames,
  Struct_VxWorks_22_slotTypes,
  Struct_VxWorks_22_slotOffsets,
  Struct_VxWorks_22_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_22 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_22_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_22 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_22_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_22 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_22_struct, tclObj);
}
// Build Struct_VxWorks_22 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_22_type = {
  "Struct_VxWorks_22",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_22,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_22
  };
// Build Struct_VxWorks_22 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_22_ptr = {
  "Struct_VxWorks_22_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_22,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_22
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_23 {
  int nullCalls;
  int getattrCalls;
  int setattrCalls;
  int rootCalls;
  int lookupCalls;
  int readlinkCalls;
  int readCalls;
  int writecacheCalls;
  int writeCalls;
  int createCalls;
  int removeCalls;
  int renameCalls;
  int linkCalls;
  int symlinkCalls;
  int mkdirCalls;
  int rmdirCalls;
  int readdirCalls;
  int statfsCalls;
};

// Alloc Struct_VxWorks_23 slot structure for Put/Get functions
static char *Struct_VxWorks_23_slotNames[] =  {
    "nullCalls",
    "getattrCalls",
    "setattrCalls",
    "rootCalls",
    "lookupCalls",
    "readlinkCalls",
    "readCalls",
    "writecacheCalls",
    "writeCalls",
    "createCalls",
    "removeCalls",
    "renameCalls",
    "linkCalls",
    "symlinkCalls",
    "mkdirCalls",
    "rmdirCalls",
    "readdirCalls",
    "statfsCalls",
    NULL
};
static JWRAP_types *Struct_VxWorks_23_slotTypes[] = {
    &usedType [JTYPE_int], // nullCalls 
    &usedType [JTYPE_int], // getattrCalls 
    &usedType [JTYPE_int], // setattrCalls 
    &usedType [JTYPE_int], // rootCalls 
    &usedType [JTYPE_int], // lookupCalls 
    &usedType [JTYPE_int], // readlinkCalls 
    &usedType [JTYPE_int], // readCalls 
    &usedType [JTYPE_int], // writecacheCalls 
    &usedType [JTYPE_int], // writeCalls 
    &usedType [JTYPE_int], // createCalls 
    &usedType [JTYPE_int], // removeCalls 
    &usedType [JTYPE_int], // renameCalls 
    &usedType [JTYPE_int], // linkCalls 
    &usedType [JTYPE_int], // symlinkCalls 
    &usedType [JTYPE_int], // mkdirCalls 
    &usedType [JTYPE_int], // rmdirCalls 
    &usedType [JTYPE_int], // readdirCalls 
    &usedType [JTYPE_int], // statfsCalls 
    NULL
};
static int Struct_VxWorks_23_slotArrays[] = {
    1, // nullCalls
    1, // getattrCalls
    1, // setattrCalls
    1, // rootCalls
    1, // lookupCalls
    1, // readlinkCalls
    1, // readCalls
    1, // writecacheCalls
    1, // writeCalls
    1, // createCalls
    1, // removeCalls
    1, // renameCalls
    1, // linkCalls
    1, // symlinkCalls
    1, // mkdirCalls
    1, // rmdirCalls
    1, // readdirCalls
    1, // statfsCalls
    0
};
static int Struct_VxWorks_23_slotOffsets[18];
static JWRAP_structs Struct_VxWorks_23_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_23],
  18,
  Struct_VxWorks_23_slotNames,
  Struct_VxWorks_23_slotTypes,
  Struct_VxWorks_23_slotOffsets,
  Struct_VxWorks_23_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_23 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_23_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_23 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_23_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_23 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_23_struct, tclObj);
}
// Build Struct_VxWorks_23 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_23_type = {
  "Struct_VxWorks_23",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_23,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_23
  };
// Build Struct_VxWorks_23 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_23_ptr = {
  "Struct_VxWorks_23_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_23,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_23
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_24 {
  char hostName;
  char remFileSys;
  char locFileSys;
};

// Alloc Struct_VxWorks_24 slot structure for Put/Get functions
static char *Struct_VxWorks_24_slotNames[] =  {
    "hostName",
    "remFileSys",
    "locFileSys",
    NULL
};
static JWRAP_types *Struct_VxWorks_24_slotTypes[] = {
    &usedType [JTYPE_char], // hostName 
    &usedType [JTYPE_char], // remFileSys 
    &usedType [JTYPE_char], // locFileSys 
    NULL
};
static int Struct_VxWorks_24_slotArrays[] = {
    64, // hostName
    255, // remFileSys
    255, // locFileSys
    0
};
static int Struct_VxWorks_24_slotOffsets[3];
static JWRAP_structs Struct_VxWorks_24_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_24],
  3,
  Struct_VxWorks_24_slotNames,
  Struct_VxWorks_24_slotTypes,
  Struct_VxWorks_24_slotOffsets,
  Struct_VxWorks_24_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_24 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_24_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_24 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_24_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_24 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_24_struct, tclObj);
}
// Build Struct_VxWorks_24 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_24_type = {
  "Struct_VxWorks_24",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_24,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_24
  };
// Build Struct_VxWorks_24 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_24_ptr = {
  "Struct_VxWorks_24_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_24,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_24
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_25 {
  char* ifName;
  void* attachRtn;
  char* arg1;
  int arg2;
  int arg3;
  int arg4;
  int arg5;
  int arg6;
  int arg7;
  int arg8;
};

// Alloc Struct_VxWorks_25 slot structure for Put/Get functions
static char *Struct_VxWorks_25_slotNames[] =  {
    "ifName",
    "attachRtn",
    "arg1",
    "arg2",
    "arg3",
    "arg4",
    "arg5",
    "arg6",
    "arg7",
    "arg8",
    NULL
};
static JWRAP_types *Struct_VxWorks_25_slotTypes[] = {
    &usedType [JTYPE_char_Ptr], // ifName 
    &usedType [JTYPE_void_Ptr], // attachRtn 
    &usedType [JTYPE_char_Ptr], // arg1 
    &usedType [JTYPE_int], // arg2 
    &usedType [JTYPE_int], // arg3 
    &usedType [JTYPE_int], // arg4 
    &usedType [JTYPE_int], // arg5 
    &usedType [JTYPE_int], // arg6 
    &usedType [JTYPE_int], // arg7 
    &usedType [JTYPE_int], // arg8 
    NULL
};
static int Struct_VxWorks_25_slotArrays[] = {
    1, // ifName
    1, // attachRtn
    1, // arg1
    1, // arg2
    1, // arg3
    1, // arg4
    1, // arg5
    1, // arg6
    1, // arg7
    1, // arg8
    0
};
static int Struct_VxWorks_25_slotOffsets[10];
static JWRAP_structs Struct_VxWorks_25_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_25],
  10,
  Struct_VxWorks_25_slotNames,
  Struct_VxWorks_25_slotTypes,
  Struct_VxWorks_25_slotOffsets,
  Struct_VxWorks_25_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_25 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_25_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_25 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_25_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_25 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_25_struct, tclObj);
}
// Build Struct_VxWorks_25 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_25_type = {
  "Struct_VxWorks_25",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_25,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_25
  };
// Build Struct_VxWorks_25 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_25_ptr = {
  "Struct_VxWorks_25_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_25,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_25
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_26 {
  int td_id;
  char* td_name;
  int td_priority;
  int td_status;
  int td_options;
  void* td_entry;
  char* td_sp;
  char* td_pStackBase;
  char* td_pStackLimit;
  char* td_pStackEnd;
  int td_stackSize;
  int td_stackCurrent;
  int td_stackHigh;
  int td_stackMargin;
  int td_errorStatus;
  int td_delay;
};

// Alloc Struct_VxWorks_26 slot structure for Put/Get functions
static char *Struct_VxWorks_26_slotNames[] =  {
    "td_id",
    "td_name",
    "td_priority",
    "td_status",
    "td_options",
    "td_entry",
    "td_sp",
    "td_pStackBase",
    "td_pStackLimit",
    "td_pStackEnd",
    "td_stackSize",
    "td_stackCurrent",
    "td_stackHigh",
    "td_stackMargin",
    "td_errorStatus",
    "td_delay",
    NULL
};
static JWRAP_types *Struct_VxWorks_26_slotTypes[] = {
    &usedType [JTYPE_int], // td_id 
    &usedType [JTYPE_char_Ptr], // td_name 
    &usedType [JTYPE_int], // td_priority 
    &usedType [JTYPE_int], // td_status 
    &usedType [JTYPE_int], // td_options 
    &usedType [JTYPE_void_Ptr], // td_entry 
    &usedType [JTYPE_char_Ptr], // td_sp 
    &usedType [JTYPE_char_Ptr], // td_pStackBase 
    &usedType [JTYPE_char_Ptr], // td_pStackLimit 
    &usedType [JTYPE_char_Ptr], // td_pStackEnd 
    &usedType [JTYPE_int], // td_stackSize 
    &usedType [JTYPE_int], // td_stackCurrent 
    &usedType [JTYPE_int], // td_stackHigh 
    &usedType [JTYPE_int], // td_stackMargin 
    &usedType [JTYPE_int], // td_errorStatus 
    &usedType [JTYPE_int], // td_delay 
    NULL
};
static int Struct_VxWorks_26_slotArrays[] = {
    1, // td_id
    1, // td_name
    1, // td_priority
    1, // td_status
    1, // td_options
    1, // td_entry
    1, // td_sp
    1, // td_pStackBase
    1, // td_pStackLimit
    1, // td_pStackEnd
    1, // td_stackSize
    1, // td_stackCurrent
    1, // td_stackHigh
    1, // td_stackMargin
    1, // td_errorStatus
    1, // td_delay
    0
};
static int Struct_VxWorks_26_slotOffsets[16];
static JWRAP_structs Struct_VxWorks_26_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_26],
  16,
  Struct_VxWorks_26_slotNames,
  Struct_VxWorks_26_slotTypes,
  Struct_VxWorks_26_slotOffsets,
  Struct_VxWorks_26_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_26 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_26_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_26 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_26_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_26 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_26_struct, tclObj);
}
// Build Struct_VxWorks_26 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_26_type = {
  "Struct_VxWorks_26",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_26,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_26
  };
// Build Struct_VxWorks_26 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_26_ptr = {
  "Struct_VxWorks_26_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_26,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_26
  };

// Alloc taskVar slot structure for Put/Get functions
static char *taskVar_slotNames[] =  {
    "next",
    "address",
    "value",
    NULL
};
static JWRAP_types *taskVar_slotTypes[] = {
    &usedType [JTYPE_taskVar_Ptr], // next 
    &usedType [JTYPE_int_Ptr], // address 
    &usedType [JTYPE_int], // value 
    NULL
};
static int taskVar_slotArrays[] = {
    1, // next
    1, // address
    1, // value
    0
};
static int taskVar_slotOffsets[3];
static JWRAP_structs taskVar_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_taskVar],
  3,
  taskVar_slotNames,
  taskVar_slotTypes,
  taskVar_slotOffsets,
  taskVar_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_taskVar (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &taskVar_struct, srcObj, destObj));
}
LOCAL int Put_taskVar (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &taskVar_struct, srcObj, destObj));
}
LOCAL char* Get_taskVar (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&taskVar_struct, tclObj);
}
// Build taskVar structure as a Tcl type
static Tcl_ObjType taskVar_type = {
  "taskVar",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_taskVar,
  (Tcl_SetFromAnyProc*)      Put_taskVar
  };
// Build taskVar structure as a Tcl type
static Tcl_ObjType taskVar_ptr = {
  "taskVar_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_taskVar,
  (Tcl_SetFromAnyProc*)      Create_taskVar
  };
// As enum as no name we  produce a dummy  structure for size computing
struct Struct_VxWorks_27 {
  ULONG lower;
  ULONG upper;
};

// Alloc Struct_VxWorks_27 slot structure for Put/Get functions
static char *Struct_VxWorks_27_slotNames[] =  {
    "lower",
    "upper",
    NULL
};
static JWRAP_types *Struct_VxWorks_27_slotTypes[] = {
    &usedType [JTYPE_ULONG], // lower 
    &usedType [JTYPE_ULONG], // upper 
    NULL
};
static int Struct_VxWorks_27_slotArrays[] = {
    1, // lower
    1, // upper
    0
};
static int Struct_VxWorks_27_slotOffsets[2];
static JWRAP_structs Struct_VxWorks_27_struct = {
  JWRAP_STRUCT,
  &usedType [JTYPE_Struct_VxWorks_27],
  2,
  Struct_VxWorks_27_slotNames,
  Struct_VxWorks_27_slotTypes,
  Struct_VxWorks_27_slotOffsets,
  Struct_VxWorks_27_slotArrays,
  (Function*)JWRAP_CREATE_FUNC,
  (Function*)JWRAP_FREE_FUNC,
  (Function*)JWRAP_CGET_FUNC
};
LOCAL int Create_Struct_VxWorks_27 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeTcl2Cc (interp, &Struct_VxWorks_27_struct, srcObj, destObj));
}
LOCAL int Put_Struct_VxWorks_27 (Tcl_Interp *interp, Tcl_Obj *srcObj, Tcl_Obj * destObj) {
  return (jWrapTypeUpdate (interp, &Struct_VxWorks_27_struct, srcObj, destObj));
}
LOCAL char* Get_Struct_VxWorks_27 (Tcl_Obj *tclObj) {
  return jWrapTypeCc2Tcl (&Struct_VxWorks_27_struct, tclObj);
}
// Build Struct_VxWorks_27 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_27_type = {
  "Struct_VxWorks_27",
  (Tcl_FreeInternalRepProc *)jWrapTypeClean,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_27,
  (Tcl_SetFromAnyProc*)      Put_Struct_VxWorks_27
  };
// Build Struct_VxWorks_27 structure as a Tcl type
static Tcl_ObjType Struct_VxWorks_27_ptr = {
  "Struct_VxWorks_27_Ptr",
  (Tcl_FreeInternalRepProc *)jWrapTypeFree,
  (Tcl_DupInternalRepProc *) NULL,
  (Tcl_UpdateStringProc*)    Get_Struct_VxWorks_27,
  (Tcl_SetFromAnyProc*)      Create_Struct_VxWorks_27
  };

 // Hold structure & unions reference for jWrap struct help cmd
 static JWRAP_structs *structures[]={
  &Struct_VxWorks_0_struct,
  &aiocb_struct,
  &utimbuf_struct,
  &tm_struct,
  &vx_timespec_struct,
  &itimerspec_struct,
  &sigevent_struct,
  &siginfo_struct,
  &sigaction_struct,
  &node_struct,
  &Struct_VxWorks_1_struct,
  &Struct_VxWorks_2_struct,
  &in_addr_struct,
  &sockaddr_in_struct,
  &hostname_struct_struct,
  &Struct_VxWorks_3_struct,
  &bootp_msg_struct,
  &Struct_VxWorks_4_struct,
  &Struct_VxWorks_5_struct,
  &dirent_struct,
  &slnode_struct,
  &Struct_VxWorks_6_struct,
  &Struct_VxWorks_7_struct,
  &dlnode_struct,
  &Struct_VxWorks_8_struct,
  &Struct_VxWorks_9_struct,
  &Struct_VxWorks_10_struct,
  &Struct_VxWorks_11_struct,
  &Struct_VxWorks_12_struct,
  &Struct_VxWorks_13_struct,
  &Struct_VxWorks_14_struct,
  &buffers_struct,
  &excfaultTab_struct,
  &Struct_VxWorks_15_struct,
  &Struct_VxWorks_16_struct,
  &Struct_VxWorks_17_struct,
  &Struct_VxWorks_18_struct,
  &Struct_VxWorks_19_struct,
  &Struct_VxWorks_20_struct,
  &Struct_VxWorks_21_struct,
  &Struct_VxWorks_22_struct,
  &Struct_VxWorks_23_struct,
  &Struct_VxWorks_24_struct,
  &Struct_VxWorks_25_struct,
  &Struct_VxWorks_26_struct,
  &taskVar_struct,
  &Struct_VxWorks_27_struct,
  &sigval_union,
  &Union_VxWorks_0_union,
  &Union_VxWorks_1_union,
  NULL
 };

/* *** Functions Section *** */

 // Interface jTcl to C++ for public utime C/C++ function/method
 static int jTcl_utime_0 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[0].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_utimbuf_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_utimbuf_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_utimbuf_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_utimbuf_Ptr].obj->name);
 }
  wtxCtx[0].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[0]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[0]);
  return TCL_ERROR;
 } // end jWrap_utime0

 // Interface jTcl to C++ for public raise C/C++ function/method
 static int jTcl_raise_1 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[1].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[1]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[1]);
  return TCL_ERROR;
 } // end jWrap_raise1

 // Interface jTcl to C++ for public kill C/C++ function/method
 static int jTcl_kill_2 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[2].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[2].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[2]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[2]);
  return TCL_ERROR;
 } // end jWrap_kill2

 // Interface jTcl to C++ for public sigemptyset C/C++ function/method
 static int jTcl_sigemptyset_3 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[3].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[3]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[3]);
  return TCL_ERROR;
 } // end jWrap_sigemptyset3

 // Interface jTcl to C++ for public sigfillset C/C++ function/method
 static int jTcl_sigfillset_4 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[4].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[4]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[4]);
  return TCL_ERROR;
 } // end jWrap_sigfillset4

 // Interface jTcl to C++ for public sigaddset C/C++ function/method
 static int jTcl_sigaddset_5 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[5].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[5].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[5]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[5]);
  return TCL_ERROR;
 } // end jWrap_sigaddset5

 // Interface jTcl to C++ for public sigdelset C/C++ function/method
 static int jTcl_sigdelset_6 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[6].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[6].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[6]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[6]);
  return TCL_ERROR;
 } // end jWrap_sigdelset6

 // Interface jTcl to C++ for public sigismember C/C++ function/method
 static int jTcl_sigismember_7 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[7].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[7].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[7]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[7]);
  return TCL_ERROR;
 } // end jWrap_sigismember7

 // Interface jTcl to C++ for public sigaction C/C++ function/method
 static int jTcl_sigaction_8 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[8].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigaction_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigaction_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigaction_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sigaction_Ptr].obj->name);
 }
  wtxCtx[8].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigaction_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigaction_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigaction_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_sigaction_Ptr].obj->name);
 }
  wtxCtx[8].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[8]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[8]);
  return TCL_ERROR;
 } // end jWrap_sigaction8

 // Interface jTcl to C++ for public sigprocmask C/C++ function/method
 static int jTcl_sigprocmask_9 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[9].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[9].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[9].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[9]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[9]);
  return TCL_ERROR;
 } // end jWrap_sigprocmask9

 // Interface jTcl to C++ for public sigpending C/C++ function/method
 static int jTcl_sigpending_10 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[10].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[10]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[10]);
  return TCL_ERROR;
 } // end jWrap_sigpending10

 // Interface jTcl to C++ for public sigsuspend C/C++ function/method
 static int jTcl_sigsuspend_11 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[11].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[11]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[11]);
  return TCL_ERROR;
 } // end jWrap_sigsuspend11

 // Interface jTcl to C++ for public sigwait C/C++ function/method
 static int jTcl_sigwait_12 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[12].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[12]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[12]);
  return TCL_ERROR;
 } // end jWrap_sigwait12

 // Interface jTcl to C++ for public sigwaitinfo C/C++ function/method
 static int jTcl_sigwaitinfo_13 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[13].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_siginfo_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_siginfo_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_siginfo_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_siginfo_Ptr].obj->name);
 }
  wtxCtx[13].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[13]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[13]);
  return TCL_ERROR;
 } // end jWrap_sigwaitinfo13

 // Interface jTcl to C++ for public sigtimedwait C/C++ function/method
 static int jTcl_sigtimedwait_14 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigset_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigset_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigset_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_sigset_t_Ptr].obj->name);
 }
  wtxCtx[14].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_siginfo_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_siginfo_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_siginfo_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_siginfo_Ptr].obj->name);
 }
  wtxCtx[14].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[14].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[14]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[14]);
  return TCL_ERROR;
 } // end jWrap_sigtimedwait14

 // Interface jTcl to C++ for public sigqueue C/C++ function/method
 static int jTcl_sigqueue_15 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[15].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[15].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigval].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigval].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigval].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_sigval].obj->name);
 }
  wtxCtx[15].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[15]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[15]);
  return TCL_ERROR;
 } // end jWrap_sigqueue15

 // Interface jTcl to C++ for public _clocks_per_sec C/C++ function/method
 static int jTcl__clocks_per_sec_16 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[16]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[16]);
  return TCL_ERROR;
 } // end jWrap__clocks_per_sec16

 // Interface jTcl to C++ for public asctime C/C++ function/method
 static int jTcl_asctime_17 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_tm_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_tm_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_tm_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_tm_Ptr].obj->name);
 }
  wtxCtx[17].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[17]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[17]);
  return TCL_ERROR;
 } // end jWrap_asctime17

 // Interface jTcl to C++ for public clock C/C++ function/method
 static int jTcl_clock_18 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[18]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[18]);
  return TCL_ERROR;
 } // end jWrap_clock18

 // Interface jTcl to C++ for public ctime C/C++ function/method
 static int jTcl_ctime_19 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long_Ptr].obj->name);
 }
  wtxCtx[19].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[19]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[19]);
  return TCL_ERROR;
 } // end jWrap_ctime19

 // Interface jTcl to C++ for public difftime C/C++ function/method
 static int jTcl_difftime_20 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[20].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[20].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[20]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_double].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[20]);
  return TCL_ERROR;
 } // end jWrap_difftime20

 // Interface jTcl to C++ for public gmtime C/C++ function/method
 static int jTcl_gmtime_21 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long_Ptr].obj->name);
 }
  wtxCtx[21].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[21]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_tm_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[21]);
  return TCL_ERROR;
 } // end jWrap_gmtime21

 // Interface jTcl to C++ for public localtime C/C++ function/method
 static int jTcl_localtime_22 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long_Ptr].obj->name);
 }
  wtxCtx[22].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[22]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_tm_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[22]);
  return TCL_ERROR;
 } // end jWrap_localtime22

 // Interface jTcl to C++ for public mktime C/C++ function/method
 static int jTcl_mktime_23 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_tm_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_tm_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_tm_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_tm_Ptr].obj->name);
 }
  wtxCtx[23].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[23]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[23]);
  return TCL_ERROR;
 } // end jWrap_mktime23

 // Interface jTcl to C++ for public strftime C/C++ function/method
 static int jTcl_strftime_24 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[24].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[24].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[24].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_tm_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_tm_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_tm_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_tm_Ptr].obj->name);
 }
  wtxCtx[24].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[24]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[24]);
  return TCL_ERROR;
 } // end jWrap_strftime24

 // Interface jTcl to C++ for public time C/C++ function/method
 static int jTcl_time_25 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long_Ptr].obj->name);
 }
  wtxCtx[25].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[25]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[25]);
  return TCL_ERROR;
 } // end jWrap_time25

 // Interface jTcl to C++ for public clock_gettime C/C++ function/method
 static int jTcl_clock_gettime_26 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_clockid_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_clockid_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_clockid_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_clockid_t].obj->name);
 }
  wtxCtx[26].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[26].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[26]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[26]);
  return TCL_ERROR;
 } // end jWrap_clock_gettime26

 // Interface jTcl to C++ for public clock_settime C/C++ function/method
 static int jTcl_clock_settime_27 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_clockid_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_clockid_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_clockid_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_clockid_t].obj->name);
 }
  wtxCtx[27].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[27].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[27]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[27]);
  return TCL_ERROR;
 } // end jWrap_clock_settime27

 // Interface jTcl to C++ for public clock_getres C/C++ function/method
 static int jTcl_clock_getres_28 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_clockid_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_clockid_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_clockid_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_clockid_t].obj->name);
 }
  wtxCtx[28].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[28].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[28]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[28]);
  return TCL_ERROR;
 } // end jWrap_clock_getres28

 // Interface jTcl to C++ for public timer_create C/C++ function/method
 static int jTcl_timer_create_29 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_clockid_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_clockid_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_clockid_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_clockid_t].obj->name);
 }
  wtxCtx[29].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigevent_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigevent_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigevent_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sigevent_Ptr].obj->name);
 }
  wtxCtx[29].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_timer_t_Ptr].obj->name);
 }
  wtxCtx[29].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[29]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[29]);
  return TCL_ERROR;
 } // end jWrap_timer_create29

 // Interface jTcl to C++ for public timer_delete C/C++ function/method
 static int jTcl_timer_delete_30 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[30].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[30]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[30]);
  return TCL_ERROR;
 } // end jWrap_timer_delete30

 // Interface jTcl to C++ for public timer_gettime C/C++ function/method
 static int jTcl_timer_gettime_31 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[31].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_itimerspec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_itimerspec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_itimerspec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_itimerspec_Ptr].obj->name);
 }
  wtxCtx[31].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[31]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[31]);
  return TCL_ERROR;
 } // end jWrap_timer_gettime31

 // Interface jTcl to C++ for public timer_settime C/C++ function/method
 static int jTcl_timer_settime_32 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[32].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[32].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_itimerspec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_itimerspec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_itimerspec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_itimerspec_Ptr].obj->name);
 }
  wtxCtx[32].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_itimerspec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_itimerspec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_itimerspec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_itimerspec_Ptr].obj->name);
 }
  wtxCtx[32].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[32]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[32]);
  return TCL_ERROR;
 } // end jWrap_timer_settime32

 // Interface jTcl to C++ for public timer_getoverrun C/C++ function/method
 static int jTcl_timer_getoverrun_33 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[33].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[33]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[33]);
  return TCL_ERROR;
 } // end jWrap_timer_getoverrun33

 // Interface jTcl to C++ for public timer_connect C/C++ function/method
 static int jTcl_timer_connect_34 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[34].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[34].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[34].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[34]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[34]);
  return TCL_ERROR;
 } // end jWrap_timer_connect34

 // Interface jTcl to C++ for public timer_cancel C/C++ function/method
 static int jTcl_timer_cancel_35 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[35].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[35]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[35]);
  return TCL_ERROR;
 } // end jWrap_timer_cancel35

 // Interface jTcl to C++ for public timer_show C/C++ function/method
 static int jTcl_timer_show_36 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timer_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timer_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timer_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_timer_t].obj->name);
 }
  wtxCtx[36].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[36]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[36]);
  return TCL_ERROR;
 } // end jWrap_timer_show36

 // Interface jTcl to C++ for public nanosleep C/C++ function/method
 static int jTcl_nanosleep_37 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[37].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[37].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[37]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[37]);
  return TCL_ERROR;
 } // end jWrap_nanosleep37

 // Interface jTcl to C++ for public aio_read C/C++ function/method
 static int jTcl_aio_read_38 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_aiocb_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_aiocb_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_aiocb_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_aiocb_Ptr].obj->name);
 }
  wtxCtx[38].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[38]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[38]);
  return TCL_ERROR;
 } // end jWrap_aio_read38

 // Interface jTcl to C++ for public aio_write C/C++ function/method
 static int jTcl_aio_write_39 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_aiocb_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_aiocb_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_aiocb_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_aiocb_Ptr].obj->name);
 }
  wtxCtx[39].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[39]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[39]);
  return TCL_ERROR;
 } // end jWrap_aio_write39

 // Interface jTcl to C++ for public lio_listio C/C++ function/method
 static int jTcl_lio_listio_40 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[40].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_aiocb_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_aiocb_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_aiocb_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_aiocb_Ptr_Ptr].obj->name);
 }
  wtxCtx[40].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[40].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigevent_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigevent_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigevent_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_sigevent_Ptr].obj->name);
 }
  wtxCtx[40].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[40]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[40]);
  return TCL_ERROR;
 } // end jWrap_lio_listio40

 // Interface jTcl to C++ for public aio_error C/C++ function/method
 static int jTcl_aio_error_41 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_aiocb_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_aiocb_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_aiocb_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_aiocb_Ptr].obj->name);
 }
  wtxCtx[41].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[41]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[41]);
  return TCL_ERROR;
 } // end jWrap_aio_error41

 // Interface jTcl to C++ for public aio_return C/C++ function/method
 static int jTcl_aio_return_42 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_agiocb_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_agiocb_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_agiocb_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_agiocb_Ptr].obj->name);
 }
  wtxCtx[42].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[42]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[42]);
  return TCL_ERROR;
 } // end jWrap_aio_return42

 // Interface jTcl to C++ for public aio_cancel C/C++ function/method
 static int jTcl_aio_cancel_43 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[43].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_aiocb_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_aiocb_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_aiocb_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_aiocb_Ptr].obj->name);
 }
  wtxCtx[43].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[43]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[43]);
  return TCL_ERROR;
 } // end jWrap_aio_cancel43

 // Interface jTcl to C++ for public aio_suspend C/C++ function/method
 static int jTcl_aio_suspend_44 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_aiocb_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_aiocb_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_aiocb_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_aiocb_Ptr_Ptr].obj->name);
 }
  wtxCtx[44].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[44].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_vx_timespec_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_vx_timespec_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_vx_timespec_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_vx_timespec_Ptr].obj->name);
 }
  wtxCtx[44].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[44]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[44]);
  return TCL_ERROR;
 } // end jWrap_aio_suspend44

 // Interface jTcl to C++ for public aioPxLibInit C/C++ function/method
 static int jTcl_aioPxLibInit_45 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[45].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[45]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[45]);
  return TCL_ERROR;
 } // end jWrap_aioPxLibInit45

 // Interface jTcl to C++ for public aioShow C/C++ function/method
 static int jTcl_aioShow_46 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[46].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[46]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[46]);
  return TCL_ERROR;
 } // end jWrap_aioShow46

 // Interface jTcl to C++ for public clearerr C/C++ function/method
 static int jTcl_clearerr_47 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[47].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[47]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[47]);
  return TCL_ERROR;
 } // end jWrap_clearerr47

 // Interface jTcl to C++ for public fclose C/C++ function/method
 static int jTcl_fclose_48 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[48].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[48]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[48]);
  return TCL_ERROR;
 } // end jWrap_fclose48

 // Interface jTcl to C++ for public feof C/C++ function/method
 static int jTcl_feof_49 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[49].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[49]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[49]);
  return TCL_ERROR;
 } // end jWrap_feof49

 // Interface jTcl to C++ for public ferror C/C++ function/method
 static int jTcl_ferror_50 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[50].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[50]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[50]);
  return TCL_ERROR;
 } // end jWrap_ferror50

 // Interface jTcl to C++ for public fflush C/C++ function/method
 static int jTcl_fflush_51 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[51].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[51]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[51]);
  return TCL_ERROR;
 } // end jWrap_fflush51

 // Interface jTcl to C++ for public fgetc C/C++ function/method
 static int jTcl_fgetc_52 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[52].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[52]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[52]);
  return TCL_ERROR;
 } // end jWrap_fgetc52

 // Interface jTcl to C++ for public fgetpos C/C++ function/method
 static int jTcl_fgetpos_53 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[53].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_fpos_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_fpos_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_fpos_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_fpos_t_Ptr].obj->name);
 }
  wtxCtx[53].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[53]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[53]);
  return TCL_ERROR;
 } // end jWrap_fgetpos53

 // Interface jTcl to C++ for public fgets C/C++ function/method
 static int jTcl_fgets_54 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[54].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[54].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[54].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[54]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[54]);
  return TCL_ERROR;
 } // end jWrap_fgets54

 // Interface jTcl to C++ for public fopen C/C++ function/method
 static int jTcl_fopen_55 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[55].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[55].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[55]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[55]);
  return TCL_ERROR;
 } // end jWrap_fopen55

 // Interface jTcl to C++ for public fputc C/C++ function/method
 static int jTcl_fputc_56 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[56].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[56].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[56]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[56]);
  return TCL_ERROR;
 } // end jWrap_fputc56

 // Interface jTcl to C++ for public fputs C/C++ function/method
 static int jTcl_fputs_57 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[57].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[57].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[57]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[57]);
  return TCL_ERROR;
 } // end jWrap_fputs57

 // Interface jTcl to C++ for public fread C/C++ function/method
 static int jTcl_fread_58 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[58].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[58].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[58].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[58].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[58]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[58]);
  return TCL_ERROR;
 } // end jWrap_fread58

 // Interface jTcl to C++ for public freopen C/C++ function/method
 static int jTcl_freopen_59 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[59].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[59].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[59].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[59]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[59]);
  return TCL_ERROR;
 } // end jWrap_freopen59

 // Interface jTcl to C++ for public fseek C/C++ function/method
 static int jTcl_fseek_60 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[60].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[60].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[60].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[60]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[60]);
  return TCL_ERROR;
 } // end jWrap_fseek60

 // Interface jTcl to C++ for public fsetpos C/C++ function/method
 static int jTcl_fsetpos_61 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[61].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_fpos_t_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_fpos_t_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_fpos_t_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_fpos_t_Ptr].obj->name);
 }
  wtxCtx[61].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[61]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[61]);
  return TCL_ERROR;
 } // end jWrap_fsetpos61

 // Interface jTcl to C++ for public ftell C/C++ function/method
 static int jTcl_ftell_62 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[62].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[62]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[62]);
  return TCL_ERROR;
 } // end jWrap_ftell62

 // Interface jTcl to C++ for public fwrite C/C++ function/method
 static int jTcl_fwrite_63 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[63].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[63].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[63].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[63].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[63]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[63]);
  return TCL_ERROR;
 } // end jWrap_fwrite63

 // Interface jTcl to C++ for public getc C/C++ function/method
 static int jTcl_getc_64 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[64].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[64]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[64]);
  return TCL_ERROR;
 } // end jWrap_getc64

 // Interface jTcl to C++ for public getchar C/C++ function/method
 static int jTcl_getchar_65 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[65]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[65]);
  return TCL_ERROR;
 } // end jWrap_getchar65

 // Interface jTcl to C++ for public gets C/C++ function/method
 static int jTcl_gets_66 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[66].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[66]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[66]);
  return TCL_ERROR;
 } // end jWrap_gets66

 // Interface jTcl to C++ for public perror C/C++ function/method
 static int jTcl_perror_67 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[67].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[67]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[67]);
  return TCL_ERROR;
 } // end jWrap_perror67

 // Interface jTcl to C++ for public putc C/C++ function/method
 static int jTcl_putc_68 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[68].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[68].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[68]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[68]);
  return TCL_ERROR;
 } // end jWrap_putc68

 // Interface jTcl to C++ for public putchar C/C++ function/method
 static int jTcl_putchar_69 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[69].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[69]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[69]);
  return TCL_ERROR;
 } // end jWrap_putchar69

 // Interface jTcl to C++ for public puts C/C++ function/method
 static int jTcl_puts_70 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[70].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[70]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[70]);
  return TCL_ERROR;
 } // end jWrap_puts70

 // Interface jTcl to C++ for public remove C/C++ function/method
 static int jTcl_remove_71 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[71].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[71]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[71]);
  return TCL_ERROR;
 } // end jWrap_remove71

 // Interface jTcl to C++ for public rename C/C++ function/method
 static int jTcl_rename_72 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[72].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[72].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[72]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[72]);
  return TCL_ERROR;
 } // end jWrap_rename72

 // Interface jTcl to C++ for public rewind C/C++ function/method
 static int jTcl_rewind_73 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[73].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[73]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[73]);
  return TCL_ERROR;
 } // end jWrap_rewind73

 // Interface jTcl to C++ for public setbuf C/C++ function/method
 static int jTcl_setbuf_74 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[74].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[74].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[74]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[74]);
  return TCL_ERROR;
 } // end jWrap_setbuf74

 // Interface jTcl to C++ for public setvbuf C/C++ function/method
 static int jTcl_setvbuf_75 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[75].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[75].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[75].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[75].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[75]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[75]);
  return TCL_ERROR;
 } // end jWrap_setvbuf75

 // Interface jTcl to C++ for public tmpfile C/C++ function/method
 static int jTcl_tmpfile_76 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[76]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[76]);
  return TCL_ERROR;
 } // end jWrap_tmpfile76

 // Interface jTcl to C++ for public tmpnam C/C++ function/method
 static int jTcl_tmpnam_77 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[77].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[77]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[77]);
  return TCL_ERROR;
 } // end jWrap_tmpnam77

 // Interface jTcl to C++ for public ungetc C/C++ function/method
 static int jTcl_ungetc_78 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[78].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[78].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[78]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[78]);
  return TCL_ERROR;
 } // end jWrap_ungetc78

 // Interface jTcl to C++ for public vfprintf C/C++ function/method
 static int jTcl_vfprintf_79 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[79].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[79].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[79].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[79]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[79]);
  return TCL_ERROR;
 } // end jWrap_vfprintf79

 // Interface jTcl to C++ for public vprintf C/C++ function/method
 static int jTcl_vprintf_80 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[80].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[80].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[80]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[80]);
  return TCL_ERROR;
 } // end jWrap_vprintf80

 // Interface jTcl to C++ for public vsprintf C/C++ function/method
 static int jTcl_vsprintf_81 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[81].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[81].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[81].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[81]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[81]);
  return TCL_ERROR;
 } // end jWrap_vsprintf81

 // Interface jTcl to C++ for public fdopen C/C++ function/method
 static int jTcl_fdopen_82 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[82].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[82].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[82]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[82]);
  return TCL_ERROR;
 } // end jWrap_fdopen82

 // Interface jTcl to C++ for public fileno C/C++ function/method
 static int jTcl_fileno_83 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_FILE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_FILE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_FILE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_FILE_Ptr].obj->name);
 }
  wtxCtx[83].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[83]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[83]);
  return TCL_ERROR;
 } // end jWrap_fileno83

 // Interface jTcl to C++ for public abort C/C++ function/method
 static int jTcl_abort_84 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[84]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[84]);
  return TCL_ERROR;
 } // end jWrap_abort84

 // Interface jTcl to C++ for public abs C/C++ function/method
 static int jTcl_abs_85 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[85].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[85]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[85]);
  return TCL_ERROR;
 } // end jWrap_abs85

 // Interface jTcl to C++ for public atexit C/C++ function/method
 static int jTcl_atexit_86 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[86].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[86]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[86]);
  return TCL_ERROR;
 } // end jWrap_atexit86

 // Interface jTcl to C++ for public atof C/C++ function/method
 static int jTcl_atof_87 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[87].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[87]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_double].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[87]);
  return TCL_ERROR;
 } // end jWrap_atof87

 // Interface jTcl to C++ for public atoi C/C++ function/method
 static int jTcl_atoi_88 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[88].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[88]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[88]);
  return TCL_ERROR;
 } // end jWrap_atoi88

 // Interface jTcl to C++ for public atol C/C++ function/method
 static int jTcl_atol_89 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[89].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[89]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[89]);
  return TCL_ERROR;
 } // end jWrap_atol89

 // Interface jTcl to C++ for public bsearch C/C++ function/method
 static int jTcl_bsearch_90 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[90].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[90].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[90].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[90].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[90].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[90]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[90]);
  return TCL_ERROR;
 } // end jWrap_bsearch90

 // Interface jTcl to C++ for public div C/C++ function/method
 static int jTcl_div_91 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[91].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[91].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[91]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_div_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[91]);
  return TCL_ERROR;
 } // end jWrap_div91

 // Interface jTcl to C++ for public labs C/C++ function/method
 static int jTcl_labs_92 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[92].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[92]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[92]);
  return TCL_ERROR;
 } // end jWrap_labs92

 // Interface jTcl to C++ for public ldiv C/C++ function/method
 static int jTcl_ldiv_93 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[93].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[93].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[93]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_div_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[93]);
  return TCL_ERROR;
 } // end jWrap_ldiv93

 // Interface jTcl to C++ for public mblen C/C++ function/method
 static int jTcl_mblen_94 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[94].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[94].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[94]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[94]);
  return TCL_ERROR;
 } // end jWrap_mblen94

 // Interface jTcl to C++ for public mbstowcs C/C++ function/method
 static int jTcl_mbstowcs_95 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[95].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[95].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[95].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[95]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[95]);
  return TCL_ERROR;
 } // end jWrap_mbstowcs95

 // Interface jTcl to C++ for public mbtowc C/C++ function/method
 static int jTcl_mbtowc_96 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[96].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[96].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[96].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[96]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[96]);
  return TCL_ERROR;
 } // end jWrap_mbtowc96

 // Interface jTcl to C++ for public rand C/C++ function/method
 static int jTcl_rand_97 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[97]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[97]);
  return TCL_ERROR;
 } // end jWrap_rand97

 // Interface jTcl to C++ for public srand C/C++ function/method
 static int jTcl_srand_98 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[98].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[98]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[98]);
  return TCL_ERROR;
 } // end jWrap_srand98

 // Interface jTcl to C++ for public system C/C++ function/method
 static int jTcl_system_99 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[99].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[99]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[99]);
  return TCL_ERROR;
 } // end jWrap_system99

 // Interface jTcl to C++ for public wcstombs C/C++ function/method
 static int jTcl_wcstombs_100 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[100].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[100].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[100].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[100]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[100]);
  return TCL_ERROR;
 } // end jWrap_wcstombs100

 // Interface jTcl to C++ for public wctomb C/C++ function/method
 static int jTcl_wctomb_101 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[101].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char].obj->name);
 }
  wtxCtx[101].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[101]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[101]);
  return TCL_ERROR;
 } // end jWrap_wctomb101

 // Interface jTcl to C++ for public calloc C/C++ function/method
 static int jTcl_calloc_102 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[102].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[102].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[102]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[102]);
  return TCL_ERROR;
 } // end jWrap_calloc102

 // Interface jTcl to C++ for public exit C/C++ function/method
 static int jTcl_exit_103 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[103].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[103]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[103]);
  return TCL_ERROR;
 } // end jWrap_exit103

 // Interface jTcl to C++ for public free C/C++ function/method
 static int jTcl_free_104 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[104].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[104]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[104]);
  return TCL_ERROR;
 } // end jWrap_free104

 // Interface jTcl to C++ for public getenv C/C++ function/method
 static int jTcl_getenv_105 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[105].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[105]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[105]);
  return TCL_ERROR;
 } // end jWrap_getenv105

 // Interface jTcl to C++ for public malloc C/C++ function/method
 static int jTcl_malloc_106 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[106].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[106]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[106]);
  return TCL_ERROR;
 } // end jWrap_malloc106

 // Interface jTcl to C++ for public realloc C/C++ function/method
 static int jTcl_realloc_107 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[107].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[107].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[107]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[107]);
  return TCL_ERROR;
 } // end jWrap_realloc107

 // Interface jTcl to C++ for public memchr C/C++ function/method
 static int jTcl_memchr_108 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[108].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[108].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[108].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[108]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[108]);
  return TCL_ERROR;
 } // end jWrap_memchr108

 // Interface jTcl to C++ for public memcmp C/C++ function/method
 static int jTcl_memcmp_109 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[109].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[109].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[109].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[109]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[109]);
  return TCL_ERROR;
 } // end jWrap_memcmp109

 // Interface jTcl to C++ for public memcpy C/C++ function/method
 static int jTcl_memcpy_110 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[110].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[110].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[110].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[110]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[110]);
  return TCL_ERROR;
 } // end jWrap_memcpy110

 // Interface jTcl to C++ for public memmove C/C++ function/method
 static int jTcl_memmove_111 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[111].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[111].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[111].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[111]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[111]);
  return TCL_ERROR;
 } // end jWrap_memmove111

 // Interface jTcl to C++ for public memset C/C++ function/method
 static int jTcl_memset_112 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[112].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[112].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[112].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[112]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[112]);
  return TCL_ERROR;
 } // end jWrap_memset112

 // Interface jTcl to C++ for public strcat C/C++ function/method
 static int jTcl_strcat_113 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[113].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[113].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[113]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[113]);
  return TCL_ERROR;
 } // end jWrap_strcat113

 // Interface jTcl to C++ for public strchr C/C++ function/method
 static int jTcl_strchr_114 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[114].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[114].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[114]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[114]);
  return TCL_ERROR;
 } // end jWrap_strchr114

 // Interface jTcl to C++ for public strcmp C/C++ function/method
 static int jTcl_strcmp_115 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[115].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[115].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[115]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[115]);
  return TCL_ERROR;
 } // end jWrap_strcmp115

 // Interface jTcl to C++ for public strcoll C/C++ function/method
 static int jTcl_strcoll_116 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[116].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[116].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[116]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[116]);
  return TCL_ERROR;
 } // end jWrap_strcoll116

 // Interface jTcl to C++ for public strcpy C/C++ function/method
 static int jTcl_strcpy_117 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[117].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[117].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[117]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[117]);
  return TCL_ERROR;
 } // end jWrap_strcpy117

 // Interface jTcl to C++ for public strcspn C/C++ function/method
 static int jTcl_strcspn_118 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[118].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[118].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[118]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[118]);
  return TCL_ERROR;
 } // end jWrap_strcspn118

 // Interface jTcl to C++ for public strlen C/C++ function/method
 static int jTcl_strlen_119 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[119].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[119]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[119]);
  return TCL_ERROR;
 } // end jWrap_strlen119

 // Interface jTcl to C++ for public strncat C/C++ function/method
 static int jTcl_strncat_120 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[120].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[120].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[120].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[120]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[120]);
  return TCL_ERROR;
 } // end jWrap_strncat120

 // Interface jTcl to C++ for public strncmp C/C++ function/method
 static int jTcl_strncmp_121 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[121].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[121].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[121].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[121]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[121]);
  return TCL_ERROR;
 } // end jWrap_strncmp121

 // Interface jTcl to C++ for public strncpy C/C++ function/method
 static int jTcl_strncpy_122 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[122].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[122].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[122].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[122]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[122]);
  return TCL_ERROR;
 } // end jWrap_strncpy122

 // Interface jTcl to C++ for public strpbrk C/C++ function/method
 static int jTcl_strpbrk_123 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[123].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[123].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[123]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[123]);
  return TCL_ERROR;
 } // end jWrap_strpbrk123

 // Interface jTcl to C++ for public strrchr C/C++ function/method
 static int jTcl_strrchr_124 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[124].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[124].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[124]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[124]);
  return TCL_ERROR;
 } // end jWrap_strrchr124

 // Interface jTcl to C++ for public strspn C/C++ function/method
 static int jTcl_strspn_125 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[125].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[125].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[125]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[125]);
  return TCL_ERROR;
 } // end jWrap_strspn125

 // Interface jTcl to C++ for public strstr C/C++ function/method
 static int jTcl_strstr_126 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[126].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[126].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[126]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[126]);
  return TCL_ERROR;
 } // end jWrap_strstr126

 // Interface jTcl to C++ for public strtok C/C++ function/method
 static int jTcl_strtok_127 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[127].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[127].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[127]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[127]);
  return TCL_ERROR;
 } // end jWrap_strtok127

 // Interface jTcl to C++ for public strxfrm C/C++ function/method
 static int jTcl_strxfrm_128 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[128].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[128].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[128].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[128]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_size_t].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[128]);
  return TCL_ERROR;
 } // end jWrap_strxfrm128

 // Interface jTcl to C++ for public strerror C/C++ function/method
 static int jTcl_strerror_129 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[129].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[129]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[129]);
  return TCL_ERROR;
 } // end jWrap_strerror129

 // Interface jTcl to C++ for public strerror_r C/C++ function/method
 static int jTcl_strerror_r_130 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[130].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[130].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[130]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[130]);
  return TCL_ERROR;
 } // end jWrap_strerror_r130

 // Interface jTcl to C++ for public bcopy C/C++ function/method
 static int jTcl_bcopy_131 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[131].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[131].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[131].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[131]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[131]);
  return TCL_ERROR;
 } // end jWrap_bcopy131

 // Interface jTcl to C++ for public bcopyBytes C/C++ function/method
 static int jTcl_bcopyBytes_132 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[132].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[132].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[132].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[132]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[132]);
  return TCL_ERROR;
 } // end jWrap_bcopyBytes132

 // Interface jTcl to C++ for public bcopyWords C/C++ function/method
 static int jTcl_bcopyWords_133 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[133].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[133].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[133].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[133]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[133]);
  return TCL_ERROR;
 } // end jWrap_bcopyWords133

 // Interface jTcl to C++ for public bcopyLongs C/C++ function/method
 static int jTcl_bcopyLongs_134 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[134].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[134].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[134].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[134]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[134]);
  return TCL_ERROR;
 } // end jWrap_bcopyLongs134

 // Interface jTcl to C++ for public bfill C/C++ function/method
 static int jTcl_bfill_135 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[135].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[135].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[135].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[135]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[135]);
  return TCL_ERROR;
 } // end jWrap_bfill135

 // Interface jTcl to C++ for public bfillBytes C/C++ function/method
 static int jTcl_bfillBytes_136 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[136].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[136].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[136].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[136]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[136]);
  return TCL_ERROR;
 } // end jWrap_bfillBytes136

 // Interface jTcl to C++ for public bzero C/C++ function/method
 static int jTcl_bzero_137 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[137].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[137].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[137]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[137]);
  return TCL_ERROR;
 } // end jWrap_bzero137

 // Interface jTcl to C++ for public bcmp C/C++ function/method
 static int jTcl_bcmp_138 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[138].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[138].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[138].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[138]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[138]);
  return TCL_ERROR;
 } // end jWrap_bcmp138

 // Interface jTcl to C++ for public binvert C/C++ function/method
 static int jTcl_binvert_139 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[139].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[139].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[139]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[139]);
  return TCL_ERROR;
 } // end jWrap_binvert139

 // Interface jTcl to C++ for public bswap C/C++ function/method
 static int jTcl_bswap_140 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[140].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[140].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[140].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[140]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[140]);
  return TCL_ERROR;
 } // end jWrap_bswap140

 // Interface jTcl to C++ for public uswab C/C++ function/method
 static int jTcl_uswab_141 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[141].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[141].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[141].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[141]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[141]);
  return TCL_ERROR;
 } // end jWrap_uswab141

 // Interface jTcl to C++ for public swab C/C++ function/method
 static int jTcl_swab_142 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[142].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[142].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[142].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[142]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[142]);
  return TCL_ERROR;
 } // end jWrap_swab142

 // Interface jTcl to C++ for public index C/C++ function/method
 static int jTcl_index_143 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[143].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[143].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[143]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[143]);
  return TCL_ERROR;
 } // end jWrap_index143

 // Interface jTcl to C++ for public rindex C/C++ function/method
 static int jTcl_rindex_144 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[144].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[144].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[144]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[144]);
  return TCL_ERROR;
 } // end jWrap_rindex144

 // Interface jTcl to C++ for public arpAdd C/C++ function/method
 static int jTcl_arpAdd_145 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[145].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[145].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[145].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[145]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[145]);
  return TCL_ERROR;
 } // end jWrap_arpAdd145

 // Interface jTcl to C++ for public arpDelete C/C++ function/method
 static int jTcl_arpDelete_146 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[146].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[146]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[146]);
  return TCL_ERROR;
 } // end jWrap_arpDelete146

 // Interface jTcl to C++ for public arpCmd C/C++ function/method
 static int jTcl_arpCmd_147 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[147].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_in_addr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_in_addr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_in_addr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_in_addr_Ptr].obj->name);
 }
  wtxCtx[147].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_u_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_u_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_u_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_u_char_Ptr].obj->name);
 }
  wtxCtx[147].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[147].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[147]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[147]);
  return TCL_ERROR;
 } // end jWrap_arpCmd147

 // Interface jTcl to C++ for public arpFlush C/C++ function/method
 static int jTcl_arpFlush_148 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[148]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[148]);
  return TCL_ERROR;
 } // end jWrap_arpFlush148

 // Interface jTcl to C++ for public bootNetmaskExtract C/C++ function/method
 static int jTcl_bootNetmaskExtract_149 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[149].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[149].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[149]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[149]);
  return TCL_ERROR;
 } // end jWrap_bootNetmaskExtract149

 // Interface jTcl to C++ for public bootStructToString C/C++ function/method
 static int jTcl_bootStructToString_150 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[150].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_BOOT_PARAMS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_BOOT_PARAMS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_BOOT_PARAMS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_BOOT_PARAMS_Ptr].obj->name);
 }
  wtxCtx[150].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[150]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[150]);
  return TCL_ERROR;
 } // end jWrap_bootStructToString150

 // Interface jTcl to C++ for public bootStringToStruct C/C++ function/method
 static int jTcl_bootStringToStruct_151 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[151].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_BOOT_PARAMS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_BOOT_PARAMS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_BOOT_PARAMS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_BOOT_PARAMS_Ptr].obj->name);
 }
  wtxCtx[151].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[151]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[151]);
  return TCL_ERROR;
 } // end jWrap_bootStringToStruct151

 // Interface jTcl to C++ for public bootParamsErrorPrint C/C++ function/method
 static int jTcl_bootParamsErrorPrint_152 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[152].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[152].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[152]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[152]);
  return TCL_ERROR;
 } // end jWrap_bootParamsErrorPrint152

 // Interface jTcl to C++ for public bootParamsPrompt C/C++ function/method
 static int jTcl_bootParamsPrompt_153 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[153].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[153]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[153]);
  return TCL_ERROR;
 } // end jWrap_bootParamsPrompt153

 // Interface jTcl to C++ for public bootParamsShow C/C++ function/method
 static int jTcl_bootParamsShow_154 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[154].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[154]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[154]);
  return TCL_ERROR;
 } // end jWrap_bootParamsShow154

 // Interface jTcl to C++ for public bootpParamsGet C/C++ function/method
 static int jTcl_bootpParamsGet_155 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 10) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[155].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[155].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[155].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[155].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[155].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[155].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[155].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[155].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_u_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_u_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_u_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_u_int].obj->name);
 }
  wtxCtx[155].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[155]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[155]);
  return TCL_ERROR;
 } // end jWrap_bootpParamsGet155

 // Interface jTcl to C++ for public bootpMsgSend C/C++ function/method
 static int jTcl_bootpMsgSend_156 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[156].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_in_addr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_in_addr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_in_addr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_in_addr_Ptr].obj->name);
 }
  wtxCtx[156].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[156].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_BOOTP_MSG_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_BOOTP_MSG_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_BOOTP_MSG_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_BOOTP_MSG_Ptr].obj->name);
 }
  wtxCtx[156].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_u_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_u_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_u_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_u_int].obj->name);
 }
  wtxCtx[156].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[156]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[156]);
  return TCL_ERROR;
 } // end jWrap_bootpMsgSend156

 // Interface jTcl to C++ for public bootpTagFind C/C++ function/method
 static int jTcl_bootpTagFind_157 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_u_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_u_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_u_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_u_char_Ptr].obj->name);
 }
  wtxCtx[157].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[157].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[157].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[157]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_u_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[157]);
  return TCL_ERROR;
 } // end jWrap_bootpTagFind157

 // Interface jTcl to C++ for public hostAdd C/C++ function/method
 static int jTcl_hostAdd_158 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[158].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[158].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[158]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[158]);
  return TCL_ERROR;
 } // end jWrap_hostAdd158

 // Interface jTcl to C++ for public hostDelete C/C++ function/method
 static int jTcl_hostDelete_159 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[159].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[159].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[159]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[159]);
  return TCL_ERROR;
 } // end jWrap_hostDelete159

 // Interface jTcl to C++ for public hostGetByAddr C/C++ function/method
 static int jTcl_hostGetByAddr_160 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[160].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[160].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[160]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[160]);
  return TCL_ERROR;
 } // end jWrap_hostGetByAddr160

 // Interface jTcl to C++ for public gethostname C/C++ function/method
 static int jTcl_gethostname_161 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[161].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[161].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[161]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[161]);
  return TCL_ERROR;
 } // end jWrap_gethostname161

 // Interface jTcl to C++ for public hostGetByName C/C++ function/method
 static int jTcl_hostGetByName_162 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[162].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[162]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[162]);
  return TCL_ERROR;
 } // end jWrap_hostGetByName162

 // Interface jTcl to C++ for public sethostname C/C++ function/method
 static int jTcl_sethostname_163 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[163].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[163].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[163]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[163]);
  return TCL_ERROR;
 } // end jWrap_sethostname163

 // Interface jTcl to C++ for public hostTblInit C/C++ function/method
 static int jTcl_hostTblInit_164 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[164]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[164]);
  return TCL_ERROR;
 } // end jWrap_hostTblInit164

 // Interface jTcl to C++ for public inet_addr C/C++ function/method
 static int jTcl_inet_addr_165 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[165]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[165]);
  return TCL_ERROR;
 } // end jWrap_inet_addr165

 // Interface jTcl to C++ for public inet_ntoa C/C++ function/method
 static int jTcl_inet_ntoa_166 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[166]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[166]);
  return TCL_ERROR;
 } // end jWrap_inet_ntoa166

 // Interface jTcl to C++ for public inet_makeaddr C/C++ function/method
 static int jTcl_inet_makeaddr_167 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[167]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_in_addr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[167]);
  return TCL_ERROR;
 } // end jWrap_inet_makeaddr167

 // Interface jTcl to C++ for public inet_network C/C++ function/method
 static int jTcl_inet_network_168 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[168]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_long].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[168]);
  return TCL_ERROR;
 } // end jWrap_inet_network168

 // Interface jTcl to C++ for public lstFirst C/C++ function/method
 static int jTcl_lstFirst_169 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[169].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[169]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[169]);
  return TCL_ERROR;
 } // end jWrap_lstFirst169

 // Interface jTcl to C++ for public lstGet C/C++ function/method
 static int jTcl_lstGet_170 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[170].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[170]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[170]);
  return TCL_ERROR;
 } // end jWrap_lstGet170

 // Interface jTcl to C++ for public lstLast C/C++ function/method
 static int jTcl_lstLast_171 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[171].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[171]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[171]);
  return TCL_ERROR;
 } // end jWrap_lstLast171

 // Interface jTcl to C++ for public lstNStep C/C++ function/method
 static int jTcl_lstNStep_172 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[172].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[172].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[172]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[172]);
  return TCL_ERROR;
 } // end jWrap_lstNStep172

 // Interface jTcl to C++ for public lstNext C/C++ function/method
 static int jTcl_lstNext_173 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[173].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[173]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[173]);
  return TCL_ERROR;
 } // end jWrap_lstNext173

 // Interface jTcl to C++ for public lstNth C/C++ function/method
 static int jTcl_lstNth_174 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[174].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[174].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[174]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[174]);
  return TCL_ERROR;
 } // end jWrap_lstNth174

 // Interface jTcl to C++ for public lstPrevious C/C++ function/method
 static int jTcl_lstPrevious_175 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[175].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[175]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[175]);
  return TCL_ERROR;
 } // end jWrap_lstPrevious175

 // Interface jTcl to C++ for public lstCount C/C++ function/method
 static int jTcl_lstCount_176 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[176].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[176]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[176]);
  return TCL_ERROR;
 } // end jWrap_lstCount176

 // Interface jTcl to C++ for public lstFind C/C++ function/method
 static int jTcl_lstFind_177 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[177].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[177].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[177]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[177]);
  return TCL_ERROR;
 } // end jWrap_lstFind177

 // Interface jTcl to C++ for public lstAdd C/C++ function/method
 static int jTcl_lstAdd_178 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[178].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[178].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[178]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[178]);
  return TCL_ERROR;
 } // end jWrap_lstAdd178

 // Interface jTcl to C++ for public lstConcat C/C++ function/method
 static int jTcl_lstConcat_179 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[179].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[179].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[179]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[179]);
  return TCL_ERROR;
 } // end jWrap_lstConcat179

 // Interface jTcl to C++ for public lstDelete C/C++ function/method
 static int jTcl_lstDelete_180 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[180].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[180].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[180]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[180]);
  return TCL_ERROR;
 } // end jWrap_lstDelete180

 // Interface jTcl to C++ for public lstExtract C/C++ function/method
 static int jTcl_lstExtract_181 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[181].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[181].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[181].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[181].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[181]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[181]);
  return TCL_ERROR;
 } // end jWrap_lstExtract181

 // Interface jTcl to C++ for public lstFree C/C++ function/method
 static int jTcl_lstFree_182 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[182].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[182]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[182]);
  return TCL_ERROR;
 } // end jWrap_lstFree182

 // Interface jTcl to C++ for public lstInit C/C++ function/method
 static int jTcl_lstInit_183 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[183].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[183]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[183]);
  return TCL_ERROR;
 } // end jWrap_lstInit183

 // Interface jTcl to C++ for public lstInsert C/C++ function/method
 static int jTcl_lstInsert_184 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_LIST_Ptr].obj->name);
 }
  wtxCtx[184].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[184].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_NODE_Ptr].obj->name);
 }
  wtxCtx[184].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[184]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[184]);
  return TCL_ERROR;
 } // end jWrap_lstInsert184

 // Interface jTcl to C++ for public cacheLibInit C/C++ function/method
 static int jTcl_cacheLibInit_185 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_MODE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_MODE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_MODE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_MODE].obj->name);
 }
  wtxCtx[185].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_MODE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_MODE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_MODE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_CACHE_MODE].obj->name);
 }
  wtxCtx[185].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[185]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[185]);
  return TCL_ERROR;
 } // end jWrap_cacheLibInit185

 // Interface jTcl to C++ for public cacheArchLibInit C/C++ function/method
 static int jTcl_cacheArchLibInit_186 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_MODE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_MODE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_MODE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_MODE].obj->name);
 }
  wtxCtx[186].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_MODE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_MODE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_MODE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_CACHE_MODE].obj->name);
 }
  wtxCtx[186].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[186]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[186]);
  return TCL_ERROR;
 } // end jWrap_cacheArchLibInit186

 // Interface jTcl to C++ for public cacheEnable C/C++ function/method
 static int jTcl_cacheEnable_187 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[187].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[187]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[187]);
  return TCL_ERROR;
 } // end jWrap_cacheEnable187

 // Interface jTcl to C++ for public cacheDisable C/C++ function/method
 static int jTcl_cacheDisable_188 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[188].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[188]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[188]);
  return TCL_ERROR;
 } // end jWrap_cacheDisable188

 // Interface jTcl to C++ for public cacheLock C/C++ function/method
 static int jTcl_cacheLock_189 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[189].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[189].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[189].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[189]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[189]);
  return TCL_ERROR;
 } // end jWrap_cacheLock189

 // Interface jTcl to C++ for public cacheUnlock C/C++ function/method
 static int jTcl_cacheUnlock_190 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[190].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[190].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[190].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[190]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[190]);
  return TCL_ERROR;
 } // end jWrap_cacheUnlock190

 // Interface jTcl to C++ for public cacheFlush C/C++ function/method
 static int jTcl_cacheFlush_191 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[191].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[191].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[191].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[191]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[191]);
  return TCL_ERROR;
 } // end jWrap_cacheFlush191

 // Interface jTcl to C++ for public cacheInvalidate C/C++ function/method
 static int jTcl_cacheInvalidate_192 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[192].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[192].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[192].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[192]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[192]);
  return TCL_ERROR;
 } // end jWrap_cacheInvalidate192

 // Interface jTcl to C++ for public cacheClear C/C++ function/method
 static int jTcl_cacheClear_193 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_TYPE].obj->name);
 }
  wtxCtx[193].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[193].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[193].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[193]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[193]);
  return TCL_ERROR;
 } // end jWrap_cacheClear193

 // Interface jTcl to C++ for public cacheTextUpdate C/C++ function/method
 static int jTcl_cacheTextUpdate_194 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[194].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[194].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[194]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[194]);
  return TCL_ERROR;
 } // end jWrap_cacheTextUpdate194

 // Interface jTcl to C++ for public cachePipeFlush C/C++ function/method
 static int jTcl_cachePipeFlush_195 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[195]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[195]);
  return TCL_ERROR;
 } // end jWrap_cachePipeFlush195

 // Interface jTcl to C++ for public cacheDmaMalloc C/C++ function/method
 static int jTcl_cacheDmaMalloc_196 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[196].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[196]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[196]);
  return TCL_ERROR;
 } // end jWrap_cacheDmaMalloc196

 // Interface jTcl to C++ for public cacheDmaFree C/C++ function/method
 static int jTcl_cacheDmaFree_197 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[197].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[197]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[197]);
  return TCL_ERROR;
 } // end jWrap_cacheDmaFree197

 // Interface jTcl to C++ for public cacheDrvFlush C/C++ function/method
 static int jTcl_cacheDrvFlush_198 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_FUNCS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_FUNCS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_FUNCS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_FUNCS_Ptr].obj->name);
 }
  wtxCtx[198].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[198].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[198].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[198]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[198]);
  return TCL_ERROR;
 } // end jWrap_cacheDrvFlush198

 // Interface jTcl to C++ for public cacheDrvInvalidate C/C++ function/method
 static int jTcl_cacheDrvInvalidate_199 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_FUNCS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_FUNCS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_FUNCS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_FUNCS_Ptr].obj->name);
 }
  wtxCtx[199].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[199].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[199].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[199]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[199]);
  return TCL_ERROR;
 } // end jWrap_cacheDrvInvalidate199

 // Interface jTcl to C++ for public cacheDrvVirtToPhys C/C++ function/method
 static int jTcl_cacheDrvVirtToPhys_200 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_FUNCS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_FUNCS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_FUNCS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_FUNCS_Ptr].obj->name);
 }
  wtxCtx[200].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[200].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[200]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[200]);
  return TCL_ERROR;
 } // end jWrap_cacheDrvVirtToPhys200

 // Interface jTcl to C++ for public cacheDrvPhysToVirt C/C++ function/method
 static int jTcl_cacheDrvPhysToVirt_201 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_CACHE_FUNCS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_CACHE_FUNCS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_CACHE_FUNCS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_CACHE_FUNCS_Ptr].obj->name);
 }
  wtxCtx[201].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[201].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[201]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[201]);
  return TCL_ERROR;
 } // end jWrap_cacheDrvPhysToVirt201

 // Interface jTcl to C++ for public cacheFuncsSet C/C++ function/method
 static int jTcl_cacheFuncsSet_202 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[202]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[202]);
  return TCL_ERROR;
 } // end jWrap_cacheFuncsSet202

 // Interface jTcl to C++ for public c C/C++ function/method
 static int jTcl_c_203 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[203].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[203].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[203].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[203]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[203]);
  return TCL_ERROR;
 } // end jWrap_c203

 // Interface jTcl to C++ for public s C/C++ function/method
 static int jTcl_s_204 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[204].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[204].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[204].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[204]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[204]);
  return TCL_ERROR;
 } // end jWrap_s204

 // Interface jTcl to C++ for public dbgHelp C/C++ function/method
 static int jTcl_dbgHelp_205 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[205]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[205]);
  return TCL_ERROR;
 } // end jWrap_dbgHelp205

 // Interface jTcl to C++ for public dbgInit C/C++ function/method
 static int jTcl_dbgInit_206 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[206]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[206]);
  return TCL_ERROR;
 } // end jWrap_dbgInit206

 // Interface jTcl to C++ for public b C/C++ function/method
 static int jTcl_b_207 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[207].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[207].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[207].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[207].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[207]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[207]);
  return TCL_ERROR;
 } // end jWrap_b207

 // Interface jTcl to C++ for public e C/C++ function/method
 static int jTcl_e_208 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[208].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_event_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_event_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_event_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_event_t].obj->name);
 }
  wtxCtx[208].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[208].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[208].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[208].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[208]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[208]);
  return TCL_ERROR;
 } // end jWrap_e208

 // Interface jTcl to C++ for public bd C/C++ function/method
 static int jTcl_bd_209 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[209].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[209].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[209]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[209]);
  return TCL_ERROR;
 } // end jWrap_bd209

 // Interface jTcl to C++ for public bdall C/C++ function/method
 static int jTcl_bdall_210 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[210].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[210]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[210]);
  return TCL_ERROR;
 } // end jWrap_bdall210

 // Interface jTcl to C++ for public cret C/C++ function/method
 static int jTcl_cret_211 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[211].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[211]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[211]);
  return TCL_ERROR;
 } // end jWrap_cret211

 // Interface jTcl to C++ for public so C/C++ function/method
 static int jTcl_so_212 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[212].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[212]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[212]);
  return TCL_ERROR;
 } // end jWrap_so212

 // Interface jTcl to C++ for public l C/C++ function/method
 static int jTcl_l_213 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[213].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[213].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[213]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[213]);
  return TCL_ERROR;
 } // end jWrap_l213

 // Interface jTcl to C++ for public tt C/C++ function/method
 static int jTcl_tt_214 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[214].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[214]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[214]);
  return TCL_ERROR;
 } // end jWrap_tt214

 // Interface jTcl to C++ for public dbgPrintCall C/C++ function/method
 static int jTcl_dbgPrintCall_215 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[215].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[215].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[215].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[215].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[215]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[215]);
  return TCL_ERROR;
 } // end jWrap_dbgPrintCall215

 // Interface jTcl to C++ for public dbgBrkExists C/C++ function/method
 static int jTcl_dbgBrkExists_216 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_INSTR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_INSTR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_INSTR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_INSTR_Ptr].obj->name);
 }
  wtxCtx[216].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[216].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[216]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[216]);
  return TCL_ERROR;
 } // end jWrap_dbgBrkExists216

 // Interface jTcl to C++ for public dbgBreakNotifyInstall C/C++ function/method
 static int jTcl_dbgBreakNotifyInstall_217 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[217].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[217]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[217]);
  return TCL_ERROR;
 } // end jWrap_dbgBreakNotifyInstall217

 // Interface jTcl to C++ for public dbgStepQuiet C/C++ function/method
 static int jTcl_dbgStepQuiet_218 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[218].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[218]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[218]);
  return TCL_ERROR;
 } // end jWrap_dbgStepQuiet218

 // Interface jTcl to C++ for public bdTask C/C++ function/method
 static int jTcl_bdTask_219 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[219].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[219]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[219]);
  return TCL_ERROR;
 } // end jWrap_bdTask219

 // Interface jTcl to C++ for public opendir C/C++ function/method
 static int jTcl_opendir_220 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[220].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[220]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DIR_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[220]);
  return TCL_ERROR;
 } // end jWrap_opendir220

 // Interface jTcl to C++ for public closedir C/C++ function/method
 static int jTcl_closedir_221 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DIR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DIR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DIR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DIR_Ptr].obj->name);
 }
  wtxCtx[221].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[221]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[221]);
  return TCL_ERROR;
 } // end jWrap_closedir221

 // Interface jTcl to C++ for public readdir C/C++ function/method
 static int jTcl_readdir_222 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DIR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DIR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DIR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DIR_Ptr].obj->name);
 }
  wtxCtx[222].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[222]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_dirent_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[222]);
  return TCL_ERROR;
 } // end jWrap_readdir222

 // Interface jTcl to C++ for public rewinddir C/C++ function/method
 static int jTcl_rewinddir_223 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DIR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DIR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DIR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DIR_Ptr].obj->name);
 }
  wtxCtx[223].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[223]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[223]);
  return TCL_ERROR;
 } // end jWrap_rewinddir223

 // Interface jTcl to C++ for public dosFsConfigGet C/C++ function/method
 static int jTcl_dosFsConfigGet_224 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->name);
 }
  wtxCtx[224].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->name);
 }
  wtxCtx[224].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[224]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[224]);
  return TCL_ERROR;
 } // end jWrap_dosFsConfigGet224

 // Interface jTcl to C++ for public dosFsConfigInit C/C++ function/method
 static int jTcl_dosFsConfigInit_225 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 10) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->name);
 }
  wtxCtx[225].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char].obj->name);
 }
  wtxCtx[225].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT8].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT8].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT8].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_UINT8].obj->name);
 }
  wtxCtx[225].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_short].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_short].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_short].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_short].obj->name);
 }
  wtxCtx[225].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_char].obj->name);
 }
  wtxCtx[225].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[225].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_short].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_short].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_short].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_short].obj->name);
 }
  wtxCtx[225].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[225].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[225].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[225]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[225]);
  return TCL_ERROR;
 } // end jWrap_dosFsConfigInit225

 // Interface jTcl to C++ for public dosFsConfigShow C/C++ function/method
 static int jTcl_dosFsConfigShow_226 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[226].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[226]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[226]);
  return TCL_ERROR;
 } // end jWrap_dosFsConfigShow226

 // Interface jTcl to C++ for public dosFsDateSet C/C++ function/method
 static int jTcl_dosFsDateSet_227 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[227].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[227].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[227].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[227]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[227]);
  return TCL_ERROR;
 } // end jWrap_dosFsDateSet227

 // Interface jTcl to C++ for public dosFsDateTimeInstall C/C++ function/method
 static int jTcl_dosFsDateTimeInstall_228 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[228].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[228]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[228]);
  return TCL_ERROR;
 } // end jWrap_dosFsDateTimeInstall228

 // Interface jTcl to C++ for public dosFsDevInit C/C++ function/method
 static int jTcl_dosFsDevInit_229 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[229].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_BLK_DEV_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_BLK_DEV_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_BLK_DEV_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_BLK_DEV_Ptr].obj->name);
 }
  wtxCtx[229].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_CONFIG_Ptr].obj->name);
 }
  wtxCtx[229].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[229]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[229]);
  return TCL_ERROR;
 } // end jWrap_dosFsDevInit229

 // Interface jTcl to C++ for public dosFsDevInitOptionsSet C/C++ function/method
 static int jTcl_dosFsDevInitOptionsSet_230 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[230].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[230]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[230]);
  return TCL_ERROR;
 } // end jWrap_dosFsDevInitOptionsSet230

 // Interface jTcl to C++ for public dosFsInit C/C++ function/method
 static int jTcl_dosFsInit_231 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[231].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[231]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[231]);
  return TCL_ERROR;
 } // end jWrap_dosFsInit231

 // Interface jTcl to C++ for public dosFsMkfs C/C++ function/method
 static int jTcl_dosFsMkfs_232 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[232].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_BLK_DEV_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_BLK_DEV_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_BLK_DEV_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_BLK_DEV_Ptr].obj->name);
 }
  wtxCtx[232].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[232]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[232]);
  return TCL_ERROR;
 } // end jWrap_dosFsMkfs232

 // Interface jTcl to C++ for public dosFsMkfsOptionsSet C/C++ function/method
 static int jTcl_dosFsMkfsOptionsSet_233 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[233].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[233]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[233]);
  return TCL_ERROR;
 } // end jWrap_dosFsMkfsOptionsSet233

 // Interface jTcl to C++ for public dosFsModeChange C/C++ function/method
 static int jTcl_dosFsModeChange_234 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->name);
 }
  wtxCtx[234].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[234].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[234]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[234]);
  return TCL_ERROR;
 } // end jWrap_dosFsModeChange234

 // Interface jTcl to C++ for public dosFsReadyChange C/C++ function/method
 static int jTcl_dosFsReadyChange_235 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->name);
 }
  wtxCtx[235].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[235]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[235]);
  return TCL_ERROR;
 } // end jWrap_dosFsReadyChange235

 // Interface jTcl to C++ for public dosFsTimeSet C/C++ function/method
 static int jTcl_dosFsTimeSet_236 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[236].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[236].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[236].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[236]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[236]);
  return TCL_ERROR;
 } // end jWrap_dosFsTimeSet236

 // Interface jTcl to C++ for public dosFsVolOptionsGet C/C++ function/method
 static int jTcl_dosFsVolOptionsGet_237 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->name);
 }
  wtxCtx[237].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_UINT_Ptr].obj->name);
 }
  wtxCtx[237].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[237]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[237]);
  return TCL_ERROR;
 } // end jWrap_dosFsVolOptionsGet237

 // Interface jTcl to C++ for public dosFsVolOptionsSet C/C++ function/method
 static int jTcl_dosFsVolOptionsSet_238 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->name);
 }
  wtxCtx[238].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[238].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[238]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[238]);
  return TCL_ERROR;
 } // end jWrap_dosFsVolOptionsSet238

 // Interface jTcl to C++ for public dosFsVolUnmount C/C++ function/method
 static int jTcl_dosFsVolUnmount_239 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DOS_VOL_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DOS_VOL_DESC_Ptr].obj->name);
 }
  wtxCtx[239].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[239]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[239]);
  return TCL_ERROR;
 } // end jWrap_dosFsVolUnmount239

 // Interface jTcl to C++ for public sllCreate C/C++ function/method
 static int jTcl_sllCreate_240 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[240]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[240]);
  return TCL_ERROR;
 } // end jWrap_sllCreate240

 // Interface jTcl to C++ for public sllEach C/C++ function/method
 static int jTcl_sllEach_241 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[241].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[241].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[241].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[241]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[241]);
  return TCL_ERROR;
 } // end jWrap_sllEach241

 // Interface jTcl to C++ for public sllGet C/C++ function/method
 static int jTcl_sllGet_242 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[242].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[242]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[242]);
  return TCL_ERROR;
 } // end jWrap_sllGet242

 // Interface jTcl to C++ for public sllPrevious C/C++ function/method
 static int jTcl_sllPrevious_243 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[243].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SL_NODE_Ptr].obj->name);
 }
  wtxCtx[243].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[243]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[243]);
  return TCL_ERROR;
 } // end jWrap_sllPrevious243

 // Interface jTcl to C++ for public sllDelete C/C++ function/method
 static int jTcl_sllDelete_244 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[244].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[244]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[244]);
  return TCL_ERROR;
 } // end jWrap_sllDelete244

 // Interface jTcl to C++ for public sllInit C/C++ function/method
 static int jTcl_sllInit_245 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[245].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[245]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[245]);
  return TCL_ERROR;
 } // end jWrap_sllInit245

 // Interface jTcl to C++ for public sllTerminate C/C++ function/method
 static int jTcl_sllTerminate_246 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[246].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[246]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[246]);
  return TCL_ERROR;
 } // end jWrap_sllTerminate246

 // Interface jTcl to C++ for public sllCount C/C++ function/method
 static int jTcl_sllCount_247 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[247].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[247]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[247]);
  return TCL_ERROR;
 } // end jWrap_sllCount247

 // Interface jTcl to C++ for public sllPutAtHead C/C++ function/method
 static int jTcl_sllPutAtHead_248 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[248].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SL_NODE_Ptr].obj->name);
 }
  wtxCtx[248].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[248]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[248]);
  return TCL_ERROR;
 } // end jWrap_sllPutAtHead248

 // Interface jTcl to C++ for public sllPutAtTail C/C++ function/method
 static int jTcl_sllPutAtTail_249 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[249].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SL_NODE_Ptr].obj->name);
 }
  wtxCtx[249].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[249]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[249]);
  return TCL_ERROR;
 } // end jWrap_sllPutAtTail249

 // Interface jTcl to C++ for public sllRemove C/C++ function/method
 static int jTcl_sllRemove_250 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[250].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SL_NODE_Ptr].obj->name);
 }
  wtxCtx[250].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_SL_NODE_Ptr].obj->name);
 }
  wtxCtx[250].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[250]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[250]);
  return TCL_ERROR;
 } // end jWrap_sllRemove250

 // Interface jTcl to C++ for public hashKeyCmp C/C++ function/method
 static int jTcl_hashKeyCmp_251 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_INT_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_INT_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_INT_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_H_NODE_INT_Ptr].obj->name);
 }
  wtxCtx[251].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_INT_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_INT_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_INT_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_H_NODE_INT_Ptr].obj->name);
 }
  wtxCtx[251].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[251].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[251]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[251]);
  return TCL_ERROR;
 } // end jWrap_hashKeyCmp251

 // Interface jTcl to C++ for public hashKeyStrCmp C/C++ function/method
 static int jTcl_hashKeyStrCmp_252 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_STRING_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_STRING_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_STRING_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_H_NODE_STRING_Ptr].obj->name);
 }
  wtxCtx[252].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_STRING_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_STRING_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_STRING_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_H_NODE_STRING_Ptr].obj->name);
 }
  wtxCtx[252].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[252].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[252]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[252]);
  return TCL_ERROR;
 } // end jWrap_hashKeyStrCmp252

 // Interface jTcl to C++ for public hashTblCreate C/C++ function/method
 static int jTcl_hashTblCreate_253 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[253].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[253].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[253].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[253].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[253]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_HASH_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[253]);
  return TCL_ERROR;
 } // end jWrap_hashTblCreate253

 // Interface jTcl to C++ for public hashTblEach C/C++ function/method
 static int jTcl_hashTblEach_254 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[254].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[254].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[254].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[254]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_HASH_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[254]);
  return TCL_ERROR;
 } // end jWrap_hashTblEach254

 // Interface jTcl to C++ for public hashTblFind C/C++ function/method
 static int jTcl_hashTblFind_255 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[255].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_HASH_NODE_Ptr].obj->name);
 }
  wtxCtx[255].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[255].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[255]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_HASH_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[255]);
  return TCL_ERROR;
 } // end jWrap_hashTblFind255

 // Interface jTcl to C++ for public hashLibInit C/C++ function/method
 static int jTcl_hashLibInit_256 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[256]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[256]);
  return TCL_ERROR;
 } // end jWrap_hashLibInit256

 // Interface jTcl to C++ for public hashTblDelete C/C++ function/method
 static int jTcl_hashTblDelete_257 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[257].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[257]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[257]);
  return TCL_ERROR;
 } // end jWrap_hashTblDelete257

 // Interface jTcl to C++ for public hashTblDestroy C/C++ function/method
 static int jTcl_hashTblDestroy_258 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[258].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[258].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[258]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[258]);
  return TCL_ERROR;
 } // end jWrap_hashTblDestroy258

 // Interface jTcl to C++ for public hashTblInit C/C++ function/method
 static int jTcl_hashTblInit_259 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 7) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_TBL_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_TBL_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_TBL_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_TBL_Ptr].obj->name);
 }
  wtxCtx[259].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SL_LIST_Ptr].obj->name);
 }
  wtxCtx[259].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[259].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[259].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[259].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[259].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[259]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[259]);
  return TCL_ERROR;
 } // end jWrap_hashTblInit259

 // Interface jTcl to C++ for public hashTblPut C/C++ function/method
 static int jTcl_hashTblPut_260 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[260].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_HASH_NODE_Ptr].obj->name);
 }
  wtxCtx[260].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[260]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[260]);
  return TCL_ERROR;
 } // end jWrap_hashTblPut260

 // Interface jTcl to C++ for public hashTblRemove C/C++ function/method
 static int jTcl_hashTblRemove_261 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[261].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_HASH_NODE_Ptr].obj->name);
 }
  wtxCtx[261].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[261]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[261]);
  return TCL_ERROR;
 } // end jWrap_hashTblRemove261

 // Interface jTcl to C++ for public hashTblTerminate C/C++ function/method
 static int jTcl_hashTblTerminate_262 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[262].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[262]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[262]);
  return TCL_ERROR;
 } // end jWrap_hashTblTerminate262

 // Interface jTcl to C++ for public hashFuncIterScale C/C++ function/method
 static int jTcl_hashFuncIterScale_263 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[263].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_STRING_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_STRING_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_STRING_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_H_NODE_STRING_Ptr].obj->name);
 }
  wtxCtx[263].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[263].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[263]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[263]);
  return TCL_ERROR;
 } // end jWrap_hashFuncIterScale263

 // Interface jTcl to C++ for public hashFuncModulo C/C++ function/method
 static int jTcl_hashFuncModulo_264 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[264].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_INT_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_INT_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_INT_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_H_NODE_INT_Ptr].obj->name);
 }
  wtxCtx[264].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[264].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[264]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[264]);
  return TCL_ERROR;
 } // end jWrap_hashFuncModulo264

 // Interface jTcl to C++ for public hashFuncMultiply C/C++ function/method
 static int jTcl_hashFuncMultiply_265 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[265].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_H_NODE_INT_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_H_NODE_INT_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_H_NODE_INT_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_H_NODE_INT_Ptr].obj->name);
 }
  wtxCtx[265].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[265].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[265]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[265]);
  return TCL_ERROR;
 } // end jWrap_hashFuncMultiply265

 // Interface jTcl to C++ for public iosInit C/C++ function/method
 static int jTcl_iosInit_266 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[266].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[266].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[266].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[266]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[266]);
  return TCL_ERROR;
 } // end jWrap_iosInit266

 // Interface jTcl to C++ for public iosShowInit C/C++ function/method
 static int jTcl_iosShowInit_267 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[267]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[267]);
  return TCL_ERROR;
 } // end jWrap_iosShowInit267

 // Interface jTcl to C++ for public iosFdDevFind C/C++ function/method
 static int jTcl_iosFdDevFind_268 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[268].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[268]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[268]);
  return TCL_ERROR;
 } // end jWrap_iosFdDevFind268

 // Interface jTcl to C++ for public iosNextDevGet C/C++ function/method
 static int jTcl_iosNextDevGet_269 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[269].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[269]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[269]);
  return TCL_ERROR;
 } // end jWrap_iosNextDevGet269

 // Interface jTcl to C++ for public iosClose C/C++ function/method
 static int jTcl_iosClose_270 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[270].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[270]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[270]);
  return TCL_ERROR;
 } // end jWrap_iosClose270

 // Interface jTcl to C++ for public iosDevAdd C/C++ function/method
 static int jTcl_iosDevAdd_271 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[271].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[271].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[271].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[271]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[271]);
  return TCL_ERROR;
 } // end jWrap_iosDevAdd271

 // Interface jTcl to C++ for public iosDrvRemove C/C++ function/method
 static int jTcl_iosDrvRemove_272 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[272].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[272].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[272]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[272]);
  return TCL_ERROR;
 } // end jWrap_iosDrvRemove272

 // Interface jTcl to C++ for public iosCreate C/C++ function/method
 static int jTcl_iosCreate_273 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[273].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[273].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[273].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[273]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[273]);
  return TCL_ERROR;
 } // end jWrap_iosCreate273

 // Interface jTcl to C++ for public iosDelete C/C++ function/method
 static int jTcl_iosDelete_274 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[274].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[274].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[274]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[274]);
  return TCL_ERROR;
 } // end jWrap_iosDelete274

 // Interface jTcl to C++ for public iosDrvInstall C/C++ function/method
 static int jTcl_iosDrvInstall_275 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 8) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[275].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[275]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[275]);
  return TCL_ERROR;
 } // end jWrap_iosDrvInstall275

 // Interface jTcl to C++ for public iosFdNew C/C++ function/method
 static int jTcl_iosFdNew_276 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[276].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[276].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[276].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[276]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[276]);
  return TCL_ERROR;
 } // end jWrap_iosFdNew276

 // Interface jTcl to C++ for public iosFdValue C/C++ function/method
 static int jTcl_iosFdValue_277 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[277].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[277]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[277]);
  return TCL_ERROR;
 } // end jWrap_iosFdValue277

 // Interface jTcl to C++ for public iosIoctl C/C++ function/method
 static int jTcl_iosIoctl_278 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[278].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[278].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[278].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[278]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[278]);
  return TCL_ERROR;
 } // end jWrap_iosIoctl278

 // Interface jTcl to C++ for public iosOpen C/C++ function/method
 static int jTcl_iosOpen_279 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[279].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[279].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[279].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[279].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[279]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[279]);
  return TCL_ERROR;
 } // end jWrap_iosOpen279

 // Interface jTcl to C++ for public iosRead C/C++ function/method
 static int jTcl_iosRead_280 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[280].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[280].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[280].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[280]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[280]);
  return TCL_ERROR;
 } // end jWrap_iosRead280

 // Interface jTcl to C++ for public iosWrite C/C++ function/method
 static int jTcl_iosWrite_281 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[281].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[281].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[281].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[281]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[281]);
  return TCL_ERROR;
 } // end jWrap_iosWrite281

 // Interface jTcl to C++ for public iosDevDelete C/C++ function/method
 static int jTcl_iosDevDelete_282 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[282].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[282]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[282]);
  return TCL_ERROR;
 } // end jWrap_iosDevDelete282

 // Interface jTcl to C++ for public iosDevShow C/C++ function/method
 static int jTcl_iosDevShow_283 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[283]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[283]);
  return TCL_ERROR;
 } // end jWrap_iosDevShow283

 // Interface jTcl to C++ for public iosDrvShow C/C++ function/method
 static int jTcl_iosDrvShow_284 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[284]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[284]);
  return TCL_ERROR;
 } // end jWrap_iosDrvShow284

 // Interface jTcl to C++ for public iosFdFree C/C++ function/method
 static int jTcl_iosFdFree_285 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[285].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[285]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[285]);
  return TCL_ERROR;
 } // end jWrap_iosFdFree285

 // Interface jTcl to C++ for public iosFdSet C/C++ function/method
 static int jTcl_iosFdSet_286 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[286].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DEV_HDR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DEV_HDR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DEV_HDR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_DEV_HDR_Ptr].obj->name);
 }
  wtxCtx[286].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[286].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[286].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[286]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[286]);
  return TCL_ERROR;
 } // end jWrap_iosFdSet286

 // Interface jTcl to C++ for public iosFdShow C/C++ function/method
 static int jTcl_iosFdShow_287 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[287]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[287]);
  return TCL_ERROR;
 } // end jWrap_iosFdShow287

 // Interface jTcl to C++ for public dllCreate C/C++ function/method
 static int jTcl_dllCreate_288 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[288]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[288]);
  return TCL_ERROR;
 } // end jWrap_dllCreate288

 // Interface jTcl to C++ for public dllEach C/C++ function/method
 static int jTcl_dllEach_289 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[289].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[289].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[289].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[289]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DL_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[289]);
  return TCL_ERROR;
 } // end jWrap_dllEach289

 // Interface jTcl to C++ for public dllGet C/C++ function/method
 static int jTcl_dllGet_290 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[290].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[290]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_DL_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[290]);
  return TCL_ERROR;
 } // end jWrap_dllGet290

 // Interface jTcl to C++ for public dllDelete C/C++ function/method
 static int jTcl_dllDelete_291 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[291].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[291]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[291]);
  return TCL_ERROR;
 } // end jWrap_dllDelete291

 // Interface jTcl to C++ for public dllInit C/C++ function/method
 static int jTcl_dllInit_292 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[292].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[292]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[292]);
  return TCL_ERROR;
 } // end jWrap_dllInit292

 // Interface jTcl to C++ for public dllTerminate C/C++ function/method
 static int jTcl_dllTerminate_293 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[293].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[293]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[293]);
  return TCL_ERROR;
 } // end jWrap_dllTerminate293

 // Interface jTcl to C++ for public dllCount C/C++ function/method
 static int jTcl_dllCount_294 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[294].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[294]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[294]);
  return TCL_ERROR;
 } // end jWrap_dllCount294

 // Interface jTcl to C++ for public dllAdd C/C++ function/method
 static int jTcl_dllAdd_295 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[295].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_DL_NODE_Ptr].obj->name);
 }
  wtxCtx[295].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[295]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[295]);
  return TCL_ERROR;
 } // end jWrap_dllAdd295

 // Interface jTcl to C++ for public dllInsert C/C++ function/method
 static int jTcl_dllInsert_296 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[296].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_DL_NODE_Ptr].obj->name);
 }
  wtxCtx[296].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_DL_NODE_Ptr].obj->name);
 }
  wtxCtx[296].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[296]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[296]);
  return TCL_ERROR;
 } // end jWrap_dllInsert296

 // Interface jTcl to C++ for public dllRemove C/C++ function/method
 static int jTcl_dllRemove_297 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_LIST_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_LIST_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_LIST_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_DL_LIST_Ptr].obj->name);
 }
  wtxCtx[297].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_DL_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_DL_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_DL_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_DL_NODE_Ptr].obj->name);
 }
  wtxCtx[297].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[297]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[297]);
  return TCL_ERROR;
 } // end jWrap_dllRemove297

 // Interface jTcl to C++ for public qFifoCreate C/C++ function/method
 static int jTcl_qFifoCreate_298 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[298]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[298]);
  return TCL_ERROR;
 } // end jWrap_qFifoCreate298

 // Interface jTcl to C++ for public qFifoGet C/C++ function/method
 static int jTcl_qFifoGet_299 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[299].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[299]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_Q_FIFO_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[299]);
  return TCL_ERROR;
 } // end jWrap_qFifoGet299

 // Interface jTcl to C++ for public qFifoDelete C/C++ function/method
 static int jTcl_qFifoDelete_300 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[300].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[300]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[300]);
  return TCL_ERROR;
 } // end jWrap_qFifoDelete300

 // Interface jTcl to C++ for public qFifoInit C/C++ function/method
 static int jTcl_qFifoInit_301 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[301].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[301]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[301]);
  return TCL_ERROR;
 } // end jWrap_qFifoInit301

 // Interface jTcl to C++ for public qFifoInfo C/C++ function/method
 static int jTcl_qFifoInfo_302 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[302].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[302].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[302].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[302]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[302]);
  return TCL_ERROR;
 } // end jWrap_qFifoInfo302

 // Interface jTcl to C++ for public qFifoPut C/C++ function/method
 static int jTcl_qFifoPut_303 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[303].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_NODE_Ptr].obj->name);
 }
  wtxCtx[303].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_ULONG].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_ULONG].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_ULONG].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_ULONG].obj->name);
 }
  wtxCtx[303].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[303]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[303]);
  return TCL_ERROR;
 } // end jWrap_qFifoPut303

 // Interface jTcl to C++ for public qFifoRemove C/C++ function/method
 static int jTcl_qFifoRemove_304 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[304].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_NODE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_NODE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_NODE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_NODE_Ptr].obj->name);
 }
  wtxCtx[304].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[304]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[304]);
  return TCL_ERROR;
 } // end jWrap_qFifoRemove304

 // Interface jTcl to C++ for public qFifoEach C/C++ function/method
 static int jTcl_qFifoEach_305 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Q_FIFO_HEAD_Ptr].obj->name);
 }
  wtxCtx[305].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[305].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[305].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[305]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_Q_FIFO_NODE_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[305]);
  return TCL_ERROR;
 } // end jWrap_qFifoEach305

 // Interface jTcl to C++ for public semGive C/C++ function/method
 static int jTcl_semGive_306 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[306].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[306]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[306]);
  return TCL_ERROR;
 } // end jWrap_semGive306

 // Interface jTcl to C++ for public semTake C/C++ function/method
 static int jTcl_semTake_307 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[307].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[307].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[307]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[307]);
  return TCL_ERROR;
 } // end jWrap_semTake307

 // Interface jTcl to C++ for public semFlush C/C++ function/method
 static int jTcl_semFlush_308 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[308].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[308]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[308]);
  return TCL_ERROR;
 } // end jWrap_semFlush308

 // Interface jTcl to C++ for public semDelete C/C++ function/method
 static int jTcl_semDelete_309 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[309].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[309]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[309]);
  return TCL_ERROR;
 } // end jWrap_semDelete309

 // Interface jTcl to C++ for public semInfo C/C++ function/method
 static int jTcl_semInfo_310 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[310].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[310].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[310].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[310]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[310]);
  return TCL_ERROR;
 } // end jWrap_semInfo310

 // Interface jTcl to C++ for public semBLibInit C/C++ function/method
 static int jTcl_semBLibInit_311 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[311]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[311]);
  return TCL_ERROR;
 } // end jWrap_semBLibInit311

 // Interface jTcl to C++ for public semBCreate C/C++ function/method
 static int jTcl_semBCreate_312 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[312].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_B_STATE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_B_STATE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_B_STATE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SEM_B_STATE].obj->name);
 }
  wtxCtx[312].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[312]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEM_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[312]);
  return TCL_ERROR;
 } // end jWrap_semBCreate312

 // Interface jTcl to C++ for public semCLibInit C/C++ function/method
 static int jTcl_semCLibInit_313 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[313]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[313]);
  return TCL_ERROR;
 } // end jWrap_semCLibInit313

 // Interface jTcl to C++ for public semCCreate C/C++ function/method
 static int jTcl_semCCreate_314 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[314].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[314].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[314]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEM_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[314]);
  return TCL_ERROR;
 } // end jWrap_semCCreate314

 // Interface jTcl to C++ for public semMLibInit C/C++ function/method
 static int jTcl_semMLibInit_315 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[315]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[315]);
  return TCL_ERROR;
 } // end jWrap_semMLibInit315

 // Interface jTcl to C++ for public semMCreate C/C++ function/method
 static int jTcl_semMCreate_316 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[316].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[316]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEM_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[316]);
  return TCL_ERROR;
 } // end jWrap_semMCreate316

 // Interface jTcl to C++ for public semMGiveForce C/C++ function/method
 static int jTcl_semMGiveForce_317 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[317].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[317]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[317]);
  return TCL_ERROR;
 } // end jWrap_semMGiveForce317

 // Interface jTcl to C++ for public semOLibInit C/C++ function/method
 static int jTcl_semOLibInit_318 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[318]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[318]);
  return TCL_ERROR;
 } // end jWrap_semOLibInit318

 // Interface jTcl to C++ for public semCreate C/C++ function/method
 static int jTcl_semCreate_319 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[319]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEM_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[319]);
  return TCL_ERROR;
 } // end jWrap_semCreate319

 // Interface jTcl to C++ for public semShowInit C/C++ function/method
 static int jTcl_semShowInit_320 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[320]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[320]);
  return TCL_ERROR;
 } // end jWrap_semShowInit320

 // Interface jTcl to C++ for public semShow C/C++ function/method
 static int jTcl_semShow_321 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEM_ID].obj->name);
 }
  wtxCtx[321].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[321].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[321]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[321]);
  return TCL_ERROR;
 } // end jWrap_semShow321

 // Interface jTcl to C++ for public envLibInit C/C++ function/method
 static int jTcl_envLibInit_322 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[322]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[322]);
  return TCL_ERROR;
 } // end jWrap_envLibInit322

 // Interface jTcl to C++ for public envPrivateCreate C/C++ function/method
 static int jTcl_envPrivateCreate_323 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[323]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[323]);
  return TCL_ERROR;
 } // end jWrap_envPrivateCreate323

 // Interface jTcl to C++ for public envPrivateDestroy C/C++ function/method
 static int jTcl_envPrivateDestroy_324 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[324]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[324]);
  return TCL_ERROR;
 } // end jWrap_envPrivateDestroy324

 // Interface jTcl to C++ for public putenv C/C++ function/method
 static int jTcl_putenv_325 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[325]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[325]);
  return TCL_ERROR;
 } // end jWrap_putenv325

 // Interface jTcl to C++ for public envShow C/C++ function/method
 static int jTcl_envShow_326 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[326]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[326]);
  return TCL_ERROR;
 } // end jWrap_envShow326

 // Interface jTcl to C++ for public errnoOfTaskSet C/C++ function/method
 static int jTcl_errnoOfTaskSet_327 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[327].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[327].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[327]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[327]);
  return TCL_ERROR;
 } // end jWrap_errnoOfTaskSet327

 // Interface jTcl to C++ for public errnoSet C/C++ function/method
 static int jTcl_errnoSet_328 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[328].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[328]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[328]);
  return TCL_ERROR;
 } // end jWrap_errnoSet328

 // Interface jTcl to C++ for public errnoGet C/C++ function/method
 static int jTcl_errnoGet_329 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[329]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[329]);
  return TCL_ERROR;
 } // end jWrap_errnoGet329

 // Interface jTcl to C++ for public errnoOfTaskGet C/C++ function/method
 static int jTcl_errnoOfTaskGet_330 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[330].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[330]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[330]);
  return TCL_ERROR;
 } // end jWrap_errnoOfTaskGet330

 // Interface jTcl to C++ for public etherAddrResolve C/C++ function/method
 static int jTcl_etherAddrResolve_331 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_ifnet_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_ifnet_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_ifnet_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_ifnet_Ptr].obj->name);
 }
  wtxCtx[331].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[331].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[331].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[331].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[331].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[331]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[331]);
  return TCL_ERROR;
 } // end jWrap_etherAddrResolve331

 // Interface jTcl to C++ for public etherInputHookAdd C/C++ function/method
 static int jTcl_etherInputHookAdd_332 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[332].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[332]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[332]);
  return TCL_ERROR;
 } // end jWrap_etherInputHookAdd332

 // Interface jTcl to C++ for public etherOutput C/C++ function/method
 static int jTcl_etherOutput_333 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_ifnet_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_ifnet_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_ifnet_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_ifnet_Ptr].obj->name);
 }
  wtxCtx[333].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_ether_header_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_ether_header_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_ether_header_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_ether_header_Ptr].obj->name);
 }
  wtxCtx[333].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[333].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[333].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[333]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[333]);
  return TCL_ERROR;
 } // end jWrap_etherOutput333

 // Interface jTcl to C++ for public etherOutputHookAdd C/C++ function/method
 static int jTcl_etherOutputHookAdd_334 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[334].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[334]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[334]);
  return TCL_ERROR;
 } // end jWrap_etherOutputHookAdd334

 // Interface jTcl to C++ for public etherInputHookDelete C/C++ function/method
 static int jTcl_etherInputHookDelete_335 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[335]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[335]);
  return TCL_ERROR;
 } // end jWrap_etherInputHookDelete335

 // Interface jTcl to C++ for public etherOutputHookDelete C/C++ function/method
 static int jTcl_etherOutputHookDelete_336 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[336]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[336]);
  return TCL_ERROR;
 } // end jWrap_etherOutputHookDelete336

 // Interface jTcl to C++ for public evtBufferIsEmpty C/C++ function/method
 static int jTcl_evtBufferIsEmpty_337 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[337]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[337]);
  return TCL_ERROR;
 } // end jWrap_evtBufferIsEmpty337

 // Interface jTcl to C++ for public evtBufferAddress C/C++ function/method
 static int jTcl_evtBufferAddress_338 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[338]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[338]);
  return TCL_ERROR;
 } // end jWrap_evtBufferAddress338

 // Interface jTcl to C++ for public evtBufferToFile C/C++ function/method
 static int jTcl_evtBufferToFile_339 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[339].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[339]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[339]);
  return TCL_ERROR;
 } // end jWrap_evtBufferToFile339

 // Interface jTcl to C++ for public evtBufferUpLoad C/C++ function/method
 static int jTcl_evtBufferUpLoad_340 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[340]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[340]);
  return TCL_ERROR;
 } // end jWrap_evtBufferUpLoad340

 // Interface jTcl to C++ for public excVecInit C/C++ function/method
 static int jTcl_excVecInit_341 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[341]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[341]);
  return TCL_ERROR;
 } // end jWrap_excVecInit341

 // Interface jTcl to C++ for public excShowInit C/C++ function/method
 static int jTcl_excShowInit_342 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[342]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[342]);
  return TCL_ERROR;
 } // end jWrap_excShowInit342

 // Interface jTcl to C++ for public excInit C/C++ function/method
 static int jTcl_excInit_343 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[343]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[343]);
  return TCL_ERROR;
 } // end jWrap_excInit343

 // Interface jTcl to C++ for public excHookAdd C/C++ function/method
 static int jTcl_excHookAdd_344 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[344].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[344]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[344]);
  return TCL_ERROR;
 } // end jWrap_excHookAdd344

 // Interface jTcl to C++ for public excTask C/C++ function/method
 static int jTcl_excTask_345 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[345]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[345]);
  return TCL_ERROR;
 } // end jWrap_excTask345

 // Interface jTcl to C++ for public excJobAdd C/C++ function/method
 static int jTcl_excJobAdd_346 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 8) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_VOIDFUNCPTR].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_VOIDFUNCPTR].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_VOIDFUNCPTR].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_VOIDFUNCPTR].obj->name);
 }
  wtxCtx[346].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[346].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[346].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[346].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[346].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[346].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[346].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[346]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[346]);
  return TCL_ERROR;
 } // end jWrap_excJobAdd346

 // Interface jTcl to C++ for public ftpLogin C/C++ function/method
 static int jTcl_ftpLogin_347 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[347].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[347].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[347].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[347].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[347]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[347]);
  return TCL_ERROR;
 } // end jWrap_ftpLogin347

 // Interface jTcl to C++ for public ftpXfer C/C++ function/method
 static int jTcl_ftpXfer_348 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 10) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[348].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[348].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[348].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[348]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[348]);
  return TCL_ERROR;
 } // end jWrap_ftpXfer348

 // Interface jTcl to C++ for public ftpCommand C/C++ function/method
 static int jTcl_ftpCommand_349 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 9) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[349].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[349].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[349]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[349]);
  return TCL_ERROR;
 } // end jWrap_ftpCommand349

 // Interface jTcl to C++ for public ftpDataConnGet C/C++ function/method
 static int jTcl_ftpDataConnGet_350 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[350].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[350]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[350]);
  return TCL_ERROR;
 } // end jWrap_ftpDataConnGet350

 // Interface jTcl to C++ for public ftpDataConnInit C/C++ function/method
 static int jTcl_ftpDataConnInit_351 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[351].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[351]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[351]);
  return TCL_ERROR;
 } // end jWrap_ftpDataConnInit351

 // Interface jTcl to C++ for public ftpHookup C/C++ function/method
 static int jTcl_ftpHookup_352 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[352].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[352]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[352]);
  return TCL_ERROR;
 } // end jWrap_ftpHookup352

 // Interface jTcl to C++ for public ftpReplyGet C/C++ function/method
 static int jTcl_ftpReplyGet_353 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[353].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[353].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[353]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[353]);
  return TCL_ERROR;
 } // end jWrap_ftpReplyGet353

 // Interface jTcl to C++ for public ftpdInit C/C++ function/method
 static int jTcl_ftpdInit_354 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[354].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[354]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[354]);
  return TCL_ERROR;
 } // end jWrap_ftpdInit354

 // Interface jTcl to C++ for public ftpdTask C/C++ function/method
 static int jTcl_ftpdTask_355 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[355]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[355]);
  return TCL_ERROR;
 } // end jWrap_ftpdTask355

 // Interface jTcl to C++ for public ftpdDelete C/C++ function/method
 static int jTcl_ftpdDelete_356 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[356]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[356]);
  return TCL_ERROR;
 } // end jWrap_ftpdDelete356

 // Interface jTcl to C++ for public ifAddrSet C/C++ function/method
 static int jTcl_ifAddrSet_357 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[357].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[357].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[357]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[357]);
  return TCL_ERROR;
 } // end jWrap_ifAddrSet357

 // Interface jTcl to C++ for public ifAddrGet C/C++ function/method
 static int jTcl_ifAddrGet_358 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[358].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[358].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[358]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[358]);
  return TCL_ERROR;
 } // end jWrap_ifAddrGet358

 // Interface jTcl to C++ for public ifBroadcastSet C/C++ function/method
 static int jTcl_ifBroadcastSet_359 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[359].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[359].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[359]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[359]);
  return TCL_ERROR;
 } // end jWrap_ifBroadcastSet359

 // Interface jTcl to C++ for public ifBroadcastGet C/C++ function/method
 static int jTcl_ifBroadcastGet_360 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[360].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[360].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[360]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[360]);
  return TCL_ERROR;
 } // end jWrap_ifBroadcastGet360

 // Interface jTcl to C++ for public ifDstAddrSet C/C++ function/method
 static int jTcl_ifDstAddrSet_361 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[361].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[361].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[361]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[361]);
  return TCL_ERROR;
 } // end jWrap_ifDstAddrSet361

 // Interface jTcl to C++ for public ifDstAddrGet C/C++ function/method
 static int jTcl_ifDstAddrGet_362 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[362].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[362].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[362]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[362]);
  return TCL_ERROR;
 } // end jWrap_ifDstAddrGet362

 // Interface jTcl to C++ for public ifMaskSet C/C++ function/method
 static int jTcl_ifMaskSet_363 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[363].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[363].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[363]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[363]);
  return TCL_ERROR;
 } // end jWrap_ifMaskSet363

 // Interface jTcl to C++ for public ifMaskGet C/C++ function/method
 static int jTcl_ifMaskGet_364 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[364].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[364].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[364]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[364]);
  return TCL_ERROR;
 } // end jWrap_ifMaskGet364

 // Interface jTcl to C++ for public ifFlagChange C/C++ function/method
 static int jTcl_ifFlagChange_365 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[365].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[365].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[365].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[365]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[365]);
  return TCL_ERROR;
 } // end jWrap_ifFlagChange365

 // Interface jTcl to C++ for public ifFlagSet C/C++ function/method
 static int jTcl_ifFlagSet_366 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[366].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[366].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[366]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[366]);
  return TCL_ERROR;
 } // end jWrap_ifFlagSet366

 // Interface jTcl to C++ for public ifFlagGet C/C++ function/method
 static int jTcl_ifFlagGet_367 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[367].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[367].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[367]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[367]);
  return TCL_ERROR;
 } // end jWrap_ifFlagGet367

 // Interface jTcl to C++ for public ifMetricSet C/C++ function/method
 static int jTcl_ifMetricSet_368 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[368].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[368].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[368]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[368]);
  return TCL_ERROR;
 } // end jWrap_ifMetricSet368

 // Interface jTcl to C++ for public ifMetricGet C/C++ function/method
 static int jTcl_ifMetricGet_369 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[369].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[369].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[369]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[369]);
  return TCL_ERROR;
 } // end jWrap_ifMetricGet369

 // Interface jTcl to C++ for public ifRouteDelete C/C++ function/method
 static int jTcl_ifRouteDelete_370 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[370].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[370].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[370]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[370]);
  return TCL_ERROR;
 } // end jWrap_ifRouteDelete370

 // Interface jTcl to C++ for public ifunit C/C++ function/method
 static int jTcl_ifunit_371 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[371].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[371]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_ifnet_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[371]);
  return TCL_ERROR;
 } // end jWrap_ifunit371

 // Interface jTcl to C++ for public bpattach C/C++ function/method
 static int jTcl_bpattach_372 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 8) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[372].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[372].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[372].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[372].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[372].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[372].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[372].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[372]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[372]);
  return TCL_ERROR;
 } // end jWrap_bpattach372

 // Interface jTcl to C++ for public bpInit C/C++ function/method
 static int jTcl_bpInit_373 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[373].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[373].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[373].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[373].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[373]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[373]);
  return TCL_ERROR;
 } // end jWrap_bpInit373

 // Interface jTcl to C++ for public bpShow C/C++ function/method
 static int jTcl_bpShow_374 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[374].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[374].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[374]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[374]);
  return TCL_ERROR;
 } // end jWrap_bpShow374

 // Interface jTcl to C++ for public slipInit C/C++ function/method
 static int jTcl_slipInit_375 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 9) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[375].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[375].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[375].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[375].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[375].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[375].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[375].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[375].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[375]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[375]);
  return TCL_ERROR;
 } // end jWrap_slipInit375

 // Interface jTcl to C++ for public slipBaudSet C/C++ function/method
 static int jTcl_slipBaudSet_376 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[376].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[376].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[376]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[376]);
  return TCL_ERROR;
 } // end jWrap_slipBaudSet376

 // Interface jTcl to C++ for public intConnect C/C++ function/method
 static int jTcl_intConnect_377 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[377].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[377].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[377].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[377]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[377]);
  return TCL_ERROR;
 } // end jWrap_intConnect377

 // Interface jTcl to C++ for public intHandlerCreate C/C++ function/method
 static int jTcl_intHandlerCreate_378 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[378].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[378].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[378]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[378]);
  return TCL_ERROR;
 } // end jWrap_intHandlerCreate378

 // Interface jTcl to C++ for public intLockLevelSet C/C++ function/method
 static int jTcl_intLockLevelSet_379 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[379].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[379]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[379]);
  return TCL_ERROR;
 } // end jWrap_intLockLevelSet379

 // Interface jTcl to C++ for public intLockLevelGet C/C++ function/method
 static int jTcl_intLockLevelGet_380 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[380]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[380]);
  return TCL_ERROR;
 } // end jWrap_intLockLevelGet380

 // Interface jTcl to C++ for public intContext C/C++ function/method
 static int jTcl_intContext_381 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[381]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[381]);
  return TCL_ERROR;
 } // end jWrap_intContext381

 // Interface jTcl to C++ for public intCount C/C++ function/method
 static int jTcl_intCount_382 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[382]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[382]);
  return TCL_ERROR;
 } // end jWrap_intCount382

 // Interface jTcl to C++ for public intVecBaseSet C/C++ function/method
 static int jTcl_intVecBaseSet_383 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[383].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[383]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[383]);
  return TCL_ERROR;
 } // end jWrap_intVecBaseSet383

 // Interface jTcl to C++ for public intVecBaseGet C/C++ function/method
 static int jTcl_intVecBaseGet_384 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[384]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[384]);
  return TCL_ERROR;
 } // end jWrap_intVecBaseGet384

 // Interface jTcl to C++ for public intVecSet C/C++ function/method
 static int jTcl_intVecSet_385 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[385].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[385].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[385]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[385]);
  return TCL_ERROR;
 } // end jWrap_intVecSet385

 // Interface jTcl to C++ for public intVecGet C/C++ function/method
 static int jTcl_intVecGet_386 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[386].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[386]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[386]);
  return TCL_ERROR;
 } // end jWrap_intVecGet386

 // Interface jTcl to C++ for public intLevelSet C/C++ function/method
 static int jTcl_intLevelSet_387 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[387].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[387]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[387]);
  return TCL_ERROR;
 } // end jWrap_intLevelSet387

 // Interface jTcl to C++ for public intLock C/C++ function/method
 static int jTcl_intLock_388 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[388]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[388]);
  return TCL_ERROR;
 } // end jWrap_intLock388

 // Interface jTcl to C++ for public intUnlock C/C++ function/method
 static int jTcl_intUnlock_389 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[389].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[389]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[389]);
  return TCL_ERROR;
 } // end jWrap_intUnlock389

 // Interface jTcl to C++ for public intVecTableWriteProtect C/C++ function/method
 static int jTcl_intVecTableWriteProtect_390 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[390]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[390]);
  return TCL_ERROR;
 } // end jWrap_intVecTableWriteProtect390

 // Interface jTcl to C++ for public intCRGet C/C++ function/method
 static int jTcl_intCRGet_391 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[391]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[391]);
  return TCL_ERROR;
 } // end jWrap_intCRGet391

 // Interface jTcl to C++ for public intCRSet C/C++ function/method
 static int jTcl_intCRSet_392 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[392].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[392]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[392]);
  return TCL_ERROR;
 } // end jWrap_intCRSet392

 // Interface jTcl to C++ for public intSRGet C/C++ function/method
 static int jTcl_intSRGet_393 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[393]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[393]);
  return TCL_ERROR;
 } // end jWrap_intSRGet393

 // Interface jTcl to C++ for public intSRSet C/C++ function/method
 static int jTcl_intSRSet_394 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[394].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[394]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[394]);
  return TCL_ERROR;
 } // end jWrap_intSRSet394

 // Interface jTcl to C++ for public intAckConfig C/C++ function/method
 static int jTcl_intAckConfig_395 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[395]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[395]);
  return TCL_ERROR;
 } // end jWrap_intAckConfig395

 // Interface jTcl to C++ for public intTBRSet C/C++ function/method
 static int jTcl_intTBRSet_396 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[396].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[396]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[396]);
  return TCL_ERROR;
 } // end jWrap_intTBRSet396

 // Interface jTcl to C++ for public intVecTableWriteEnable C/C++ function/method
 static int jTcl_intVecTableWriteEnable_397 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[397]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[397]);
  return TCL_ERROR;
 } // end jWrap_intVecTableWriteEnable397

 // Interface jTcl to C++ for public intHandlerCreateAm29k C/C++ function/method
 static int jTcl_intHandlerCreateAm29k_398 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[398].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[398].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[398].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[398]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[398]);
  return TCL_ERROR;
 } // end jWrap_intHandlerCreateAm29k398

 // Interface jTcl to C++ for public am29200Intr3DeMuxConnect C/C++ function/method
 static int jTcl_am29200Intr3DeMuxConnect_399 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_VOIDFUNCPTR].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_VOIDFUNCPTR].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_VOIDFUNCPTR].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_VOIDFUNCPTR].obj->name);
 }
  wtxCtx[399].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[399].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[399]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[399]);
  return TCL_ERROR;
 } // end jWrap_am29200Intr3DeMuxConnect399

 // Interface jTcl to C++ for public intDisable C/C++ function/method
 static int jTcl_intDisable_400 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[400].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[400]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[400]);
  return TCL_ERROR;
 } // end jWrap_intDisable400

 // Interface jTcl to C++ for public intEnable C/C++ function/method
 static int jTcl_intEnable_401 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[401].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[401]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[401]);
  return TCL_ERROR;
 } // end jWrap_intEnable401

 // Interface jTcl to C++ for public loadModule C/C++ function/method
 static int jTcl_loadModule_402 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[402].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[402].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[402]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[402]);
  return TCL_ERROR;
 } // end jWrap_loadModule402

 // Interface jTcl to C++ for public loadModuleGet C/C++ function/method
 static int jTcl_loadModuleGet_403 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[403].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[403].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[403].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[403]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[403]);
  return TCL_ERROR;
 } // end jWrap_loadModuleGet403

 // Interface jTcl to C++ for public addSegNames C/C++ function/method
 static int jTcl_addSegNames_404 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 7) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[404].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[404].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[404].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[404].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[404].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[404].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[404]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[404]);
  return TCL_ERROR;
 } // end jWrap_addSegNames404

 // Interface jTcl to C++ for public loadSegmentsAllocate C/C++ function/method
 static int jTcl_loadSegmentsAllocate_405 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEG_INFO_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEG_INFO_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEG_INFO_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEG_INFO_Ptr].obj->name);
 }
  wtxCtx[405].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[405]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[405]);
  return TCL_ERROR;
 } // end jWrap_loadSegmentsAllocate405

 // Interface jTcl to C++ for public loginDefaultEncrypt C/C++ function/method
 static int jTcl_loginDefaultEncrypt_406 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[406].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[406].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[406]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[406]);
  return TCL_ERROR;
 } // end jWrap_loginDefaultEncrypt406

 // Interface jTcl to C++ for public loginPrompt C/C++ function/method
 static int jTcl_loginPrompt_407 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[407].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[407]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[407]);
  return TCL_ERROR;
 } // end jWrap_loginPrompt407

 // Interface jTcl to C++ for public loginUserAdd C/C++ function/method
 static int jTcl_loginUserAdd_408 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[408].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[408].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[408]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[408]);
  return TCL_ERROR;
 } // end jWrap_loginUserAdd408

 // Interface jTcl to C++ for public loginUserDelete C/C++ function/method
 static int jTcl_loginUserDelete_409 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[409].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[409].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[409]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[409]);
  return TCL_ERROR;
 } // end jWrap_loginUserDelete409

 // Interface jTcl to C++ for public loginUserVerify C/C++ function/method
 static int jTcl_loginUserVerify_410 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[410].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[410].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[410]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[410]);
  return TCL_ERROR;
 } // end jWrap_loginUserVerify410

 // Interface jTcl to C++ for public loginEncryptInstall C/C++ function/method
 static int jTcl_loginEncryptInstall_411 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[411].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[411].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[411]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[411]);
  return TCL_ERROR;
 } // end jWrap_loginEncryptInstall411

 // Interface jTcl to C++ for public loginInit C/C++ function/method
 static int jTcl_loginInit_412 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[412]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[412]);
  return TCL_ERROR;
 } // end jWrap_loginInit412

 // Interface jTcl to C++ for public loginStringSet C/C++ function/method
 static int jTcl_loginStringSet_413 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[413].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[413]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[413]);
  return TCL_ERROR;
 } // end jWrap_loginStringSet413

 // Interface jTcl to C++ for public loginUserShow C/C++ function/method
 static int jTcl_loginUserShow_414 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[414]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[414]);
  return TCL_ERROR;
 } // end jWrap_loginUserShow414

 // Interface jTcl to C++ for public logFdAdd C/C++ function/method
 static int jTcl_logFdAdd_415 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[415].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[415]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[415]);
  return TCL_ERROR;
 } // end jWrap_logFdAdd415

 // Interface jTcl to C++ for public logFdDelete C/C++ function/method
 static int jTcl_logFdDelete_416 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[416].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[416]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[416]);
  return TCL_ERROR;
 } // end jWrap_logFdDelete416

 // Interface jTcl to C++ for public logInit C/C++ function/method
 static int jTcl_logInit_417 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[417].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[417].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[417]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[417]);
  return TCL_ERROR;
 } // end jWrap_logInit417

 // Interface jTcl to C++ for public logMsg C/C++ function/method
 static int jTcl_logMsg_418 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 8) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[418].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[418].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[418].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[418].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[418].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[418].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[418].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[418]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[418]);
  return TCL_ERROR;
 } // end jWrap_logMsg418

 // Interface jTcl to C++ for public logFdSet C/C++ function/method
 static int jTcl_logFdSet_419 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[419].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[419]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[419]);
  return TCL_ERROR;
 } // end jWrap_logFdSet419

 // Interface jTcl to C++ for public logShow C/C++ function/method
 static int jTcl_logShow_420 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[420]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[420]);
  return TCL_ERROR;
 } // end jWrap_logShow420

 // Interface jTcl to C++ for public logTask C/C++ function/method
 static int jTcl_logTask_421 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[421]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[421]);
  return TCL_ERROR;
 } // end jWrap_logTask421

 // Interface jTcl to C++ for public memDrv C/C++ function/method
 static int jTcl_memDrv_422 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[422]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[422]);
  return TCL_ERROR;
 } // end jWrap_memDrv422

 // Interface jTcl to C++ for public memDevCreate C/C++ function/method
 static int jTcl_memDevCreate_423 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[423].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[423].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[423].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[423]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[423]);
  return TCL_ERROR;
 } // end jWrap_memDevCreate423

 // Interface jTcl to C++ for public memInit C/C++ function/method
 static int jTcl_memInit_424 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[424].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[424].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[424]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[424]);
  return TCL_ERROR;
 } // end jWrap_memInit424

 // Interface jTcl to C++ for public memPartLibInit C/C++ function/method
 static int jTcl_memPartLibInit_425 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[425].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[425].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[425]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[425]);
  return TCL_ERROR;
 } // end jWrap_memPartLibInit425

 // Interface jTcl to C++ for public memPartCreate C/C++ function/method
 static int jTcl_memPartCreate_426 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[426].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[426].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[426]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_PART_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[426]);
  return TCL_ERROR;
 } // end jWrap_memPartCreate426

 // Interface jTcl to C++ for public memPartInit C/C++ function/method
 static int jTcl_memPartInit_427 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[427].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[427].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[427].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[427]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[427]);
  return TCL_ERROR;
 } // end jWrap_memPartInit427

 // Interface jTcl to C++ for public memPartAddToPool C/C++ function/method
 static int jTcl_memPartAddToPool_428 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[428].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[428].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[428].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[428]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[428]);
  return TCL_ERROR;
 } // end jWrap_memPartAddToPool428

 // Interface jTcl to C++ for public memAddToPool C/C++ function/method
 static int jTcl_memAddToPool_429 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[429].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[429].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[429]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[429]);
  return TCL_ERROR;
 } // end jWrap_memAddToPool429

 // Interface jTcl to C++ for public memPartAlloc C/C++ function/method
 static int jTcl_memPartAlloc_430 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[430].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[430].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[430]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[430]);
  return TCL_ERROR;
 } // end jWrap_memPartAlloc430

 // Interface jTcl to C++ for public memPartAlignedAlloc C/C++ function/method
 static int jTcl_memPartAlignedAlloc_431 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[431].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[431].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[431].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[431]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[431]);
  return TCL_ERROR;
 } // end jWrap_memPartAlignedAlloc431

 // Interface jTcl to C++ for public memalign C/C++ function/method
 static int jTcl_memalign_432 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[432].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[432].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[432]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[432]);
  return TCL_ERROR;
 } // end jWrap_memalign432

 // Interface jTcl to C++ for public valloc C/C++ function/method
 static int jTcl_valloc_433 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[433].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[433]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[433]);
  return TCL_ERROR;
 } // end jWrap_valloc433

 // Interface jTcl to C++ for public memPartFree C/C++ function/method
 static int jTcl_memPartFree_434 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[434].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[434].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[434]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[434]);
  return TCL_ERROR;
 } // end jWrap_memPartFree434

 // Interface jTcl to C++ for public memPartOptionsSet C/C++ function/method
 static int jTcl_memPartOptionsSet_435 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[435].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[435].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[435]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[435]);
  return TCL_ERROR;
 } // end jWrap_memPartOptionsSet435

 // Interface jTcl to C++ for public memFindMax C/C++ function/method
 static int jTcl_memFindMax_436 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[436]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[436]);
  return TCL_ERROR;
 } // end jWrap_memFindMax436

 // Interface jTcl to C++ for public memPartFindMax C/C++ function/method
 static int jTcl_memPartFindMax_437 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[437].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[437]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[437]);
  return TCL_ERROR;
 } // end jWrap_memPartFindMax437

 // Interface jTcl to C++ for public memPartRealloc C/C++ function/method
 static int jTcl_memPartRealloc_438 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[438].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[438].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[438].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[438]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[438]);
  return TCL_ERROR;
 } // end jWrap_memPartRealloc438

 // Interface jTcl to C++ for public memOptionsSet C/C++ function/method
 static int jTcl_memOptionsSet_439 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[439].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[439]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[439]);
  return TCL_ERROR;
 } // end jWrap_memOptionsSet439

 // Interface jTcl to C++ for public cfree C/C++ function/method
 static int jTcl_cfree_440 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[440].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[440]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[440]);
  return TCL_ERROR;
 } // end jWrap_cfree440

 // Interface jTcl to C++ for public memShowInit C/C++ function/method
 static int jTcl_memShowInit_441 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[441]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[441]);
  return TCL_ERROR;
 } // end jWrap_memShowInit441

 // Interface jTcl to C++ for public memShow C/C++ function/method
 static int jTcl_memShow_442 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[442].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[442]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[442]);
  return TCL_ERROR;
 } // end jWrap_memShow442

 // Interface jTcl to C++ for public memPartShow C/C++ function/method
 static int jTcl_memPartShow_443 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[443].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[443].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[443]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[443]);
  return TCL_ERROR;
 } // end jWrap_memPartShow443

 // Interface jTcl to C++ for public memPartInfoGet C/C++ function/method
 static int jTcl_memPartInfoGet_444 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[444].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MEM_PART_STATS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MEM_PART_STATS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MEM_PART_STATS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_MEM_PART_STATS_Ptr].obj->name);
 }
  wtxCtx[444].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[444]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[444]);
  return TCL_ERROR;
 } // end jWrap_memPartInfoGet444

 // Interface jTcl to C++ for public moduleLibInit C/C++ function/method
 static int jTcl_moduleLibInit_445 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[445]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[445]);
  return TCL_ERROR;
 } // end jWrap_moduleLibInit445

 // Interface jTcl to C++ for public moduleCreate C/C++ function/method
 static int jTcl_moduleCreate_446 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[446].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[446].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[446].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[446]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[446]);
  return TCL_ERROR;
 } // end jWrap_moduleCreate446

 // Interface jTcl to C++ for public moduleInit C/C++ function/method
 static int jTcl_moduleInit_447 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[447].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[447].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[447].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[447].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[447]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[447]);
  return TCL_ERROR;
 } // end jWrap_moduleInit447

 // Interface jTcl to C++ for public moduleTerminate C/C++ function/method
 static int jTcl_moduleTerminate_448 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[448].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[448]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[448]);
  return TCL_ERROR;
 } // end jWrap_moduleTerminate448

 // Interface jTcl to C++ for public moduleDelete C/C++ function/method
 static int jTcl_moduleDelete_449 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[449].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[449]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[449]);
  return TCL_ERROR;
 } // end jWrap_moduleDelete449

 // Interface jTcl to C++ for public moduleIdFigure C/C++ function/method
 static int jTcl_moduleIdFigure_450 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[450].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[450]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[450]);
  return TCL_ERROR;
 } // end jWrap_moduleIdFigure450

 // Interface jTcl to C++ for public moduleShow C/C++ function/method
 static int jTcl_moduleShow_451 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[451].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[451].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[451]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[451]);
  return TCL_ERROR;
 } // end jWrap_moduleShow451

 // Interface jTcl to C++ for public moduleSegAdd C/C++ function/method
 static int jTcl_moduleSegAdd_452 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[452].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[452].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[452].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[452].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[452].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[452]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[452]);
  return TCL_ERROR;
 } // end jWrap_moduleSegAdd452

 // Interface jTcl to C++ for public moduleSegGet C/C++ function/method
 static int jTcl_moduleSegGet_453 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[453].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[453]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEGMENT_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[453]);
  return TCL_ERROR;
 } // end jWrap_moduleSegGet453

 // Interface jTcl to C++ for public moduleSegFirst C/C++ function/method
 static int jTcl_moduleSegFirst_454 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[454].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[454]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEGMENT_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[454]);
  return TCL_ERROR;
 } // end jWrap_moduleSegFirst454

 // Interface jTcl to C++ for public moduleSegNext C/C++ function/method
 static int jTcl_moduleSegNext_455 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEGMENT_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEGMENT_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEGMENT_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SEGMENT_ID].obj->name);
 }
  wtxCtx[455].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[455]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEGMENT_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[455]);
  return TCL_ERROR;
 } // end jWrap_moduleSegNext455

 // Interface jTcl to C++ for public moduleSegEach C/C++ function/method
 static int jTcl_moduleSegEach_456 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[456].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[456].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[456].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[456]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEGMENT_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[456]);
  return TCL_ERROR;
 } // end jWrap_moduleSegEach456

 // Interface jTcl to C++ for public moduleCreateHookAdd C/C++ function/method
 static int jTcl_moduleCreateHookAdd_457 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[457].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[457]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[457]);
  return TCL_ERROR;
 } // end jWrap_moduleCreateHookAdd457

 // Interface jTcl to C++ for public moduleCreateHookDelete C/C++ function/method
 static int jTcl_moduleCreateHookDelete_458 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[458].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[458]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[458]);
  return TCL_ERROR;
 } // end jWrap_moduleCreateHookDelete458

 // Interface jTcl to C++ for public moduleFindByName C/C++ function/method
 static int jTcl_moduleFindByName_459 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[459].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[459]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[459]);
  return TCL_ERROR;
 } // end jWrap_moduleFindByName459

 // Interface jTcl to C++ for public moduleFindByNameAndPath C/C++ function/method
 static int jTcl_moduleFindByNameAndPath_460 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[460].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[460].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[460]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[460]);
  return TCL_ERROR;
 } // end jWrap_moduleFindByNameAndPath460

 // Interface jTcl to C++ for public moduleFindByGroup C/C++ function/method
 static int jTcl_moduleFindByGroup_461 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[461].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[461]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[461]);
  return TCL_ERROR;
 } // end jWrap_moduleFindByGroup461

 // Interface jTcl to C++ for public moduleEach C/C++ function/method
 static int jTcl_moduleEach_462 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[462].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[462].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[462]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[462]);
  return TCL_ERROR;
 } // end jWrap_moduleEach462

 // Interface jTcl to C++ for public moduleIdListGet C/C++ function/method
 static int jTcl_moduleIdListGet_463 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID_Ptr].obj->name);
 }
  wtxCtx[463].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[463].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[463]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[463]);
  return TCL_ERROR;
 } // end jWrap_moduleIdListGet463

 // Interface jTcl to C++ for public moduleInfoGet C/C++ function/method
 static int jTcl_moduleInfoGet_464 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[464].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_INFO_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_INFO_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_INFO_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_MODULE_INFO_Ptr].obj->name);
 }
  wtxCtx[464].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[464]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[464]);
  return TCL_ERROR;
 } // end jWrap_moduleInfoGet464

 // Interface jTcl to C++ for public moduleNameGet C/C++ function/method
 static int jTcl_moduleNameGet_465 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[465].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[465]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[465]);
  return TCL_ERROR;
 } // end jWrap_moduleNameGet465

 // Interface jTcl to C++ for public moduleFlagsGet C/C++ function/method
 static int jTcl_moduleFlagsGet_466 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[466].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[466]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[466]);
  return TCL_ERROR;
 } // end jWrap_moduleFlagsGet466

 // Interface jTcl to C++ for public moduleCheck C/C++ function/method
 static int jTcl_moduleCheck_467 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[467].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[467]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[467]);
  return TCL_ERROR;
 } // end jWrap_moduleCheck467

 // Interface jTcl to C++ for public mountdInit C/C++ function/method
 static int jTcl_mountdInit_468 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[468].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[468].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[468].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[468].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[468].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[468]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[468]);
  return TCL_ERROR;
 } // end jWrap_mountdInit468

 // Interface jTcl to C++ for public mountd C/C++ function/method
 static int jTcl_mountd_469 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[469]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[469]);
  return TCL_ERROR;
 } // end jWrap_mountd469

 // Interface jTcl to C++ for public nfsExport C/C++ function/method
 static int jTcl_nfsExport_470 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[470].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[470].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[470].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[470].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[470]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[470]);
  return TCL_ERROR;
 } // end jWrap_nfsExport470

 // Interface jTcl to C++ for public nfsUnexport C/C++ function/method
 static int jTcl_nfsUnexport_471 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[471].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[471]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[471]);
  return TCL_ERROR;
 } // end jWrap_nfsUnexport471

 // Interface jTcl to C++ for public nfsExportFindByName C/C++ function/method
 static int jTcl_nfsExportFindByName_472 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[472].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[472]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NFS_EXPORT_ENTRY_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[472]);
  return TCL_ERROR;
 } // end jWrap_nfsExportFindByName472

 // Interface jTcl to C++ for public nfsExportFindById C/C++ function/method
 static int jTcl_nfsExportFindById_473 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[473].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[473]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_NFS_EXPORT_ENTRY_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[473]);
  return TCL_ERROR;
 } // end jWrap_nfsExportFindById473

 // Interface jTcl to C++ for public fdToInode C/C++ function/method
 static int jTcl_fdToInode_474 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[474].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[474]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[474]);
  return TCL_ERROR;
 } // end jWrap_fdToInode474

 // Interface jTcl to C++ for public nameToInode C/C++ function/method
 static int jTcl_nameToInode_475 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[475].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[475]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[475]);
  return TCL_ERROR;
 } // end jWrap_nameToInode475

 // Interface jTcl to C++ for public mq_close C/C++ function/method
 static int jTcl_mq_close_476 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mqd_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mqd_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mqd_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_mqd_t].obj->name);
 }
  wtxCtx[476].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[476]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[476]);
  return TCL_ERROR;
 } // end jWrap_mq_close476

 // Interface jTcl to C++ for public mq_unlink C/C++ function/method
 static int jTcl_mq_unlink_477 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[477].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[477]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[477]);
  return TCL_ERROR;
 } // end jWrap_mq_unlink477

 // Interface jTcl to C++ for public mq_send C/C++ function/method
 static int jTcl_mq_send_478 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mqd_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mqd_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mqd_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_mqd_t].obj->name);
 }
  wtxCtx[478].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[478].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[478].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[478].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[478]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[478]);
  return TCL_ERROR;
 } // end jWrap_mq_send478

 // Interface jTcl to C++ for public mq_receive C/C++ function/method
 static int jTcl_mq_receive_479 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mqd_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mqd_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mqd_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_mqd_t].obj->name);
 }
  wtxCtx[479].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[479].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[479].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[479].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[479]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[479]);
  return TCL_ERROR;
 } // end jWrap_mq_receive479

 // Interface jTcl to C++ for public mq_notify C/C++ function/method
 static int jTcl_mq_notify_480 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mqd_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mqd_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mqd_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_mqd_t].obj->name);
 }
  wtxCtx[480].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sigevent_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sigevent_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sigevent_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sigevent_Ptr].obj->name);
 }
  wtxCtx[480].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[480]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[480]);
  return TCL_ERROR;
 } // end jWrap_mq_notify480

 // Interface jTcl to C++ for public mq_setattr C/C++ function/method
 static int jTcl_mq_setattr_481 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mqd_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mqd_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mqd_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_mqd_t].obj->name);
 }
  wtxCtx[481].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mq_attr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mq_attr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mq_attr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_mq_attr_Ptr].obj->name);
 }
  wtxCtx[481].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mq_attr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mq_attr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mq_attr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_mq_attr_Ptr].obj->name);
 }
  wtxCtx[481].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[481]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[481]);
  return TCL_ERROR;
 } // end jWrap_mq_setattr481

 // Interface jTcl to C++ for public mq_getattr C/C++ function/method
 static int jTcl_mq_getattr_482 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mqd_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mqd_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mqd_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_mqd_t].obj->name);
 }
  wtxCtx[482].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_mq_attr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_mq_attr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_mq_attr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_mq_attr_Ptr].obj->name);
 }
  wtxCtx[482].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[482]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[482]);
  return TCL_ERROR;
 } // end jWrap_mq_getattr482

 // Interface jTcl to C++ for public msgQLibInit C/C++ function/method
 static int jTcl_msgQLibInit_483 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[483]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[483]);
  return TCL_ERROR;
 } // end jWrap_msgQLibInit483

 // Interface jTcl to C++ for public msgQCreate C/C++ function/method
 static int jTcl_msgQCreate_484 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[484].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[484].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[484].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[484]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[484]);
  return TCL_ERROR;
 } // end jWrap_msgQCreate484

 // Interface jTcl to C++ for public msgQDelete C/C++ function/method
 static int jTcl_msgQDelete_485 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_ID].obj->name);
 }
  wtxCtx[485].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[485]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[485]);
  return TCL_ERROR;
 } // end jWrap_msgQDelete485

 // Interface jTcl to C++ for public msgQSend C/C++ function/method
 static int jTcl_msgQSend_486 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_ID].obj->name);
 }
  wtxCtx[486].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[486].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[486].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[486].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[486].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[486]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[486]);
  return TCL_ERROR;
 } // end jWrap_msgQSend486

 // Interface jTcl to C++ for public msgQReceive C/C++ function/method
 static int jTcl_msgQReceive_487 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_ID].obj->name);
 }
  wtxCtx[487].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[487].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[487].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[487].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[487]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[487]);
  return TCL_ERROR;
 } // end jWrap_msgQReceive487

 // Interface jTcl to C++ for public msgQInfoGet C/C++ function/method
 static int jTcl_msgQInfoGet_488 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_ID].obj->name);
 }
  wtxCtx[488].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_INFO_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_INFO_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_INFO_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_INFO_Ptr].obj->name);
 }
  wtxCtx[488].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[488]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[488]);
  return TCL_ERROR;
 } // end jWrap_msgQInfoGet488

 // Interface jTcl to C++ for public msgQNumMsgs C/C++ function/method
 static int jTcl_msgQNumMsgs_489 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_ID].obj->name);
 }
  wtxCtx[489].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[489]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[489]);
  return TCL_ERROR;
 } // end jWrap_msgQNumMsgs489

 // Interface jTcl to C++ for public msgQShowInit C/C++ function/method
 static int jTcl_msgQShowInit_490 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[490]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[490]);
  return TCL_ERROR;
 } // end jWrap_msgQShowInit490

 // Interface jTcl to C++ for public msgQShow C/C++ function/method
 static int jTcl_msgQShow_491 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MSG_Q_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MSG_Q_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MSG_Q_ID].obj->name);
 }
  wtxCtx[491].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[491].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[491]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[491]);
  return TCL_ERROR;
 } // end jWrap_msgQShow491

 // Interface jTcl to C++ for public msgQSmCreate C/C++ function/method
 static int jTcl_msgQSmCreate_492 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[492].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[492].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[492].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[492]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MSG_Q_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[492]);
  return TCL_ERROR;
 } // end jWrap_msgQSmCreate492

 // Interface jTcl to C++ for public msgQSmShowInit C/C++ function/method
 static int jTcl_msgQSmShowInit_493 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[493]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[493]);
  return TCL_ERROR;
 } // end jWrap_msgQSmShowInit493

 // Interface jTcl to C++ for public arptabShow C/C++ function/method
 static int jTcl_arptabShow_494 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[494]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[494]);
  return TCL_ERROR;
 } // end jWrap_arptabShow494

 // Interface jTcl to C++ for public arpShow C/C++ function/method
 static int jTcl_arpShow_495 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[495]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[495]);
  return TCL_ERROR;
 } // end jWrap_arpShow495

 // Interface jTcl to C++ for public icmpstatShow C/C++ function/method
 static int jTcl_icmpstatShow_496 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[496]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[496]);
  return TCL_ERROR;
 } // end jWrap_icmpstatShow496

 // Interface jTcl to C++ for public ifShow C/C++ function/method
 static int jTcl_ifShow_497 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[497].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[497]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[497]);
  return TCL_ERROR;
 } // end jWrap_ifShow497

 // Interface jTcl to C++ for public inetstatShow C/C++ function/method
 static int jTcl_inetstatShow_498 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[498]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[498]);
  return TCL_ERROR;
 } // end jWrap_inetstatShow498

 // Interface jTcl to C++ for public ipstatShow C/C++ function/method
 static int jTcl_ipstatShow_499 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[499].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[499]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[499]);
  return TCL_ERROR;
 } // end jWrap_ipstatShow499

 // Interface jTcl to C++ for public mbufShow C/C++ function/method
 static int jTcl_mbufShow_500 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[500]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[500]);
  return TCL_ERROR;
 } // end jWrap_mbufShow500

 // Interface jTcl to C++ for public netShowInit C/C++ function/method
 static int jTcl_netShowInit_501 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[501]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[501]);
  return TCL_ERROR;
 } // end jWrap_netShowInit501

 // Interface jTcl to C++ for public tcpDebugShow C/C++ function/method
 static int jTcl_tcpDebugShow_502 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[502].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[502].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[502]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[502]);
  return TCL_ERROR;
 } // end jWrap_tcpDebugShow502

 // Interface jTcl to C++ for public tcpstatShow C/C++ function/method
 static int jTcl_tcpstatShow_503 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[503]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[503]);
  return TCL_ERROR;
 } // end jWrap_tcpstatShow503

 // Interface jTcl to C++ for public udpstatShow C/C++ function/method
 static int jTcl_udpstatShow_504 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[504]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[504]);
  return TCL_ERROR;
 } // end jWrap_udpstatShow504

 // Interface jTcl to C++ for public routeShow C/C++ function/method
 static int jTcl_routeShow_505 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[505]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[505]);
  return TCL_ERROR;
 } // end jWrap_routeShow505

 // Interface jTcl to C++ for public hostShow C/C++ function/method
 static int jTcl_hostShow_506 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[506]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[506]);
  return TCL_ERROR;
 } // end jWrap_hostShow506

 // Interface jTcl to C++ for public nfsdInit C/C++ function/method
 static int jTcl_nfsdInit_507 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 7) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[507].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[507].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[507].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[507].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[507].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[507].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[507]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[507]);
  return TCL_ERROR;
 } // end jWrap_nfsdInit507

 // Interface jTcl to C++ for public nfsdRequestProcess C/C++ function/method
 static int jTcl_nfsdRequestProcess_508 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[508]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[508]);
  return TCL_ERROR;
 } // end jWrap_nfsdRequestProcess508

 // Interface jTcl to C++ for public nfsd C/C++ function/method
 static int jTcl_nfsd_509 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[509]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[509]);
  return TCL_ERROR;
 } // end jWrap_nfsd509

 // Interface jTcl to C++ for public nfsdStatusGet C/C++ function/method
 static int jTcl_nfsdStatusGet_510 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_SERVER_STATUS_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_SERVER_STATUS_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_SERVER_STATUS_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NFS_SERVER_STATUS_Ptr].obj->name);
 }
  wtxCtx[510].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[510]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[510]);
  return TCL_ERROR;
 } // end jWrap_nfsdStatusGet510

 // Interface jTcl to C++ for public nfsdStatusShow C/C++ function/method
 static int jTcl_nfsdStatusShow_511 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[511].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[511]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[511]);
  return TCL_ERROR;
 } // end jWrap_nfsdStatusShow511

 // Interface jTcl to C++ for public nfsdFhCreate C/C++ function/method
 static int jTcl_nfsdFhCreate_512 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->name);
 }
  wtxCtx[512].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[512].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->name);
 }
  wtxCtx[512].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[512]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[512]);
  return TCL_ERROR;
 } // end jWrap_nfsdFhCreate512

 // Interface jTcl to C++ for public nfsdFhToName C/C++ function/method
 static int jTcl_nfsdFhToName_513 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->name);
 }
  wtxCtx[513].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[513].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[513]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[513]);
  return TCL_ERROR;
 } // end jWrap_nfsdFhToName513

 // Interface jTcl to C++ for public nfsdFattrGet C/C++ function/method
 static int jTcl_nfsdFattrGet_514 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->name);
 }
  wtxCtx[514].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_fattr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_fattr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_fattr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_fattr_Ptr].obj->name);
 }
  wtxCtx[514].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[514]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[514]);
  return TCL_ERROR;
 } // end jWrap_nfsdFattrGet514

 // Interface jTcl to C++ for public nfsdFhHton C/C++ function/method
 static int jTcl_nfsdFhHton_515 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->name);
 }
  wtxCtx[515].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[515]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[515]);
  return TCL_ERROR;
 } // end jWrap_nfsdFhHton515

 // Interface jTcl to C++ for public nfsdFhNtoh C/C++ function/method
 static int jTcl_nfsdFhNtoh_516 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_NFS_FILE_HANDLE_Ptr].obj->name);
 }
  wtxCtx[516].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[516]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[516]);
  return TCL_ERROR;
 } // end jWrap_nfsdFhNtoh516

 // Interface jTcl to C++ for public nfsExportShow C/C++ function/method
 static int jTcl_nfsExportShow_517 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[517].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[517]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[517]);
  return TCL_ERROR;
 } // end jWrap_nfsExportShow517

 // Interface jTcl to C++ for public nfsAuthUnixGet C/C++ function/method
 static int jTcl_nfsAuthUnixGet_518 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[518].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[518].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[518].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[518].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[518].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[518]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[518]);
  return TCL_ERROR;
 } // end jWrap_nfsAuthUnixGet518

 // Interface jTcl to C++ for public nfsAuthUnixSet C/C++ function/method
 static int jTcl_nfsAuthUnixSet_519 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[519].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[519].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[519].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[519].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[519].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[519]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[519]);
  return TCL_ERROR;
 } // end jWrap_nfsAuthUnixSet519

 // Interface jTcl to C++ for public nfsAuthUnixPrompt C/C++ function/method
 static int jTcl_nfsAuthUnixPrompt_520 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[520]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[520]);
  return TCL_ERROR;
 } // end jWrap_nfsAuthUnixPrompt520

 // Interface jTcl to C++ for public nfsAuthUnixShow C/C++ function/method
 static int jTcl_nfsAuthUnixShow_521 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[521]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[521]);
  return TCL_ERROR;
 } // end jWrap_nfsAuthUnixShow521

 // Interface jTcl to C++ for public nfsHelp C/C++ function/method
 static int jTcl_nfsHelp_522 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[522]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[522]);
  return TCL_ERROR;
 } // end jWrap_nfsHelp522

 // Interface jTcl to C++ for public nfsIdSet C/C++ function/method
 static int jTcl_nfsIdSet_523 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[523].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[523]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[523]);
  return TCL_ERROR;
 } // end jWrap_nfsIdSet523

 // Interface jTcl to C++ for public nfsDrv C/C++ function/method
 static int jTcl_nfsDrv_524 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[524]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[524]);
  return TCL_ERROR;
 } // end jWrap_nfsDrv524

 // Interface jTcl to C++ for public nfsMount C/C++ function/method
 static int jTcl_nfsMount_525 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[525].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[525].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[525].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[525]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[525]);
  return TCL_ERROR;
 } // end jWrap_nfsMount525

 // Interface jTcl to C++ for public nfsMountAll C/C++ function/method
 static int jTcl_nfsMountAll_526 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[526].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[526].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[526].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[526]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[526]);
  return TCL_ERROR;
 } // end jWrap_nfsMountAll526

 // Interface jTcl to C++ for public nfsDevShow C/C++ function/method
 static int jTcl_nfsDevShow_527 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[527]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[527]);
  return TCL_ERROR;
 } // end jWrap_nfsDevShow527

 // Interface jTcl to C++ for public nfsUnmount C/C++ function/method
 static int jTcl_nfsUnmount_528 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[528].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[528]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[528]);
  return TCL_ERROR;
 } // end jWrap_nfsUnmount528

 // Interface jTcl to C++ for public nfsDevListGet C/C++ function/method
 static int jTcl_nfsDevListGet_529 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long_Ptr].obj->name);
 }
  wtxCtx[529].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[529].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[529]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[529]);
  return TCL_ERROR;
 } // end jWrap_nfsDevListGet529

 // Interface jTcl to C++ for public nfsDevInfoGet C/C++ function/method
 static int jTcl_nfsDevInfoGet_530 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_long].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_long].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_long].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_long].obj->name);
 }
  wtxCtx[530].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_NFS_DEV_INFO_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_NFS_DEV_INFO_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_NFS_DEV_INFO_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_NFS_DEV_INFO_Ptr].obj->name);
 }
  wtxCtx[530].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[530]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[530]);
  return TCL_ERROR;
 } // end jWrap_nfsDevInfoGet530

 // Interface jTcl to C++ for public pingLibInit C/C++ function/method
 static int jTcl_pingLibInit_531 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[531]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[531]);
  return TCL_ERROR;
 } // end jWrap_pingLibInit531

 // Interface jTcl to C++ for public ping C/C++ function/method
 static int jTcl_ping_532 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[532].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[532].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_ULONG].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_ULONG].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_ULONG].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_ULONG].obj->name);
 }
  wtxCtx[532].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[532]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[532]);
  return TCL_ERROR;
 } // end jWrap_ping532

 // Interface jTcl to C++ for public pipeDevCreate C/C++ function/method
 static int jTcl_pipeDevCreate_533 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[533].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[533].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[533].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[533]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[533]);
  return TCL_ERROR;
 } // end jWrap_pipeDevCreate533

 // Interface jTcl to C++ for public pipeDrv C/C++ function/method
 static int jTcl_pipeDrv_534 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[534]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[534]);
  return TCL_ERROR;
 } // end jWrap_pipeDrv534

 // Interface jTcl to C++ for public proxyArpLibInit C/C++ function/method
 static int jTcl_proxyArpLibInit_535 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[535].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[535].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[535]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[535]);
  return TCL_ERROR;
 } // end jWrap_proxyArpLibInit535

 // Interface jTcl to C++ for public proxyPortShow C/C++ function/method
 static int jTcl_proxyPortShow_536 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[536]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[536]);
  return TCL_ERROR;
 } // end jWrap_proxyPortShow536

 // Interface jTcl to C++ for public proxyPortFwdOn C/C++ function/method
 static int jTcl_proxyPortFwdOn_537 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[537].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[537]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[537]);
  return TCL_ERROR;
 } // end jWrap_proxyPortFwdOn537

 // Interface jTcl to C++ for public proxyPortFwdOff C/C++ function/method
 static int jTcl_proxyPortFwdOff_538 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[538].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[538]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[538]);
  return TCL_ERROR;
 } // end jWrap_proxyPortFwdOff538

 // Interface jTcl to C++ for public proxyNetCreate C/C++ function/method
 static int jTcl_proxyNetCreate_539 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[539].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[539].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[539]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[539]);
  return TCL_ERROR;
 } // end jWrap_proxyNetCreate539

 // Interface jTcl to C++ for public proxyNetDelete C/C++ function/method
 static int jTcl_proxyNetDelete_540 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[540].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[540]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[540]);
  return TCL_ERROR;
 } // end jWrap_proxyNetDelete540

 // Interface jTcl to C++ for public proxyClientAdd C/C++ function/method
 static int jTcl_proxyClientAdd_541 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_in_addr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_in_addr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_in_addr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_in_addr_Ptr].obj->name);
 }
  wtxCtx[541].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_in_addr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_in_addr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_in_addr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_in_addr_Ptr].obj->name);
 }
  wtxCtx[541].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[541]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[541]);
  return TCL_ERROR;
 } // end jWrap_proxyClientAdd541

 // Interface jTcl to C++ for public proxyClientDelete C/C++ function/method
 static int jTcl_proxyClientDelete_542 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_in_addr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_in_addr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_in_addr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_in_addr_Ptr].obj->name);
 }
  wtxCtx[542].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[542]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[542]);
  return TCL_ERROR;
 } // end jWrap_proxyClientDelete542

 // Interface jTcl to C++ for public proxyReg C/C++ function/method
 static int jTcl_proxyReg_543 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[543].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[543].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[543]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[543]);
  return TCL_ERROR;
 } // end jWrap_proxyReg543

 // Interface jTcl to C++ for public proxyUnreg C/C++ function/method
 static int jTcl_proxyUnreg_544 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[544].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[544].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[544]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[544]);
  return TCL_ERROR;
 } // end jWrap_proxyUnreg544

 // Interface jTcl to C++ for public ramDrv C/C++ function/method
 static int jTcl_ramDrv_545 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[545]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[545]);
  return TCL_ERROR;
 } // end jWrap_ramDrv545

 // Interface jTcl to C++ for public ramDevCreate C/C++ function/method
 static int jTcl_ramDevCreate_546 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[546].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[546].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[546].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[546].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[546].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[546]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_BLK_DEV_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[546]);
  return TCL_ERROR;
 } // end jWrap_ramDevCreate546

 // Interface jTcl to C++ for public rebootHookAdd C/C++ function/method
 static int jTcl_rebootHookAdd_547 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[547].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[547]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[547]);
  return TCL_ERROR;
 } // end jWrap_rebootHookAdd547

 // Interface jTcl to C++ for public reboot C/C++ function/method
 static int jTcl_reboot_548 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[548].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[548]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[548]);
  return TCL_ERROR;
 } // end jWrap_reboot548

 // Interface jTcl to C++ for public bindresvport C/C++ function/method
 static int jTcl_bindresvport_549 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[549].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_in_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_in_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_in_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_in_Ptr].obj->name);
 }
  wtxCtx[549].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[549]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[549]);
  return TCL_ERROR;
 } // end jWrap_bindresvport549

 // Interface jTcl to C++ for public iam C/C++ function/method
 static int jTcl_iam_550 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[550].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[550].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[550]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[550]);
  return TCL_ERROR;
 } // end jWrap_iam550

 // Interface jTcl to C++ for public remCurIdSet C/C++ function/method
 static int jTcl_remCurIdSet_551 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[551].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[551].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[551]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[551]);
  return TCL_ERROR;
 } // end jWrap_remCurIdSet551

 // Interface jTcl to C++ for public rcmd C/C++ function/method
 static int jTcl_rcmd_552 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 7) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[552].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[552].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[552].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[552].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[552].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[552].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[552]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[552]);
  return TCL_ERROR;
 } // end jWrap_rcmd552

 // Interface jTcl to C++ for public rresvport C/C++ function/method
 static int jTcl_rresvport_553 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[553].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[553]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[553]);
  return TCL_ERROR;
 } // end jWrap_rresvport553

 // Interface jTcl to C++ for public remCurIdGet C/C++ function/method
 static int jTcl_remCurIdGet_554 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[554].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[554].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[554]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[554]);
  return TCL_ERROR;
 } // end jWrap_remCurIdGet554

 // Interface jTcl to C++ for public whoami C/C++ function/method
 static int jTcl_whoami_555 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[555]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[555]);
  return TCL_ERROR;
 } // end jWrap_whoami555

 // Interface jTcl to C++ for public rlogInit C/C++ function/method
 static int jTcl_rlogInit_556 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[556]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[556]);
  return TCL_ERROR;
 } // end jWrap_rlogInit556

 // Interface jTcl to C++ for public rlogin C/C++ function/method
 static int jTcl_rlogin_557 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[557].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[557]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[557]);
  return TCL_ERROR;
 } // end jWrap_rlogin557

 // Interface jTcl to C++ for public rlogChildTask C/C++ function/method
 static int jTcl_rlogChildTask_558 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[558]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[558]);
  return TCL_ERROR;
 } // end jWrap_rlogChildTask558

 // Interface jTcl to C++ for public rlogInTask C/C++ function/method
 static int jTcl_rlogInTask_559 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[559].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[559].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[559]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[559]);
  return TCL_ERROR;
 } // end jWrap_rlogInTask559

 // Interface jTcl to C++ for public rlogOutTask C/C++ function/method
 static int jTcl_rlogOutTask_560 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[560].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[560].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[560]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[560]);
  return TCL_ERROR;
 } // end jWrap_rlogOutTask560

 // Interface jTcl to C++ for public rlogind C/C++ function/method
 static int jTcl_rlogind_561 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[561]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[561]);
  return TCL_ERROR;
 } // end jWrap_rlogind561

 // Interface jTcl to C++ for public rngIsEmpty C/C++ function/method
 static int jTcl_rngIsEmpty_562 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[562].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[562]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[562]);
  return TCL_ERROR;
 } // end jWrap_rngIsEmpty562

 // Interface jTcl to C++ for public rngIsFull C/C++ function/method
 static int jTcl_rngIsFull_563 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[563].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[563]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[563]);
  return TCL_ERROR;
 } // end jWrap_rngIsFull563

 // Interface jTcl to C++ for public rngCreate C/C++ function/method
 static int jTcl_rngCreate_564 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[564].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[564]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_RING_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[564]);
  return TCL_ERROR;
 } // end jWrap_rngCreate564

 // Interface jTcl to C++ for public rngBufGet C/C++ function/method
 static int jTcl_rngBufGet_565 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[565].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[565].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[565].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[565]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[565]);
  return TCL_ERROR;
 } // end jWrap_rngBufGet565

 // Interface jTcl to C++ for public rngBufPut C/C++ function/method
 static int jTcl_rngBufPut_566 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[566].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[566].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[566].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[566]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[566]);
  return TCL_ERROR;
 } // end jWrap_rngBufPut566

 // Interface jTcl to C++ for public rngFreeBytes C/C++ function/method
 static int jTcl_rngFreeBytes_567 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[567].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[567]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[567]);
  return TCL_ERROR;
 } // end jWrap_rngFreeBytes567

 // Interface jTcl to C++ for public rngNBytes C/C++ function/method
 static int jTcl_rngNBytes_568 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[568].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[568]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[568]);
  return TCL_ERROR;
 } // end jWrap_rngNBytes568

 // Interface jTcl to C++ for public rngDelete C/C++ function/method
 static int jTcl_rngDelete_569 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[569].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[569]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[569]);
  return TCL_ERROR;
 } // end jWrap_rngDelete569

 // Interface jTcl to C++ for public rngFlush C/C++ function/method
 static int jTcl_rngFlush_570 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[570].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[570]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[570]);
  return TCL_ERROR;
 } // end jWrap_rngFlush570

 // Interface jTcl to C++ for public rngMoveAhead C/C++ function/method
 static int jTcl_rngMoveAhead_571 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[571].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[571].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[571]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[571]);
  return TCL_ERROR;
 } // end jWrap_rngMoveAhead571

 // Interface jTcl to C++ for public rngPutAhead C/C++ function/method
 static int jTcl_rngPutAhead_572 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_RING_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_RING_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_RING_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_RING_ID].obj->name);
 }
  wtxCtx[572].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char].obj->name);
 }
  wtxCtx[572].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[572].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[572]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[572]);
  return TCL_ERROR;
 } // end jWrap_rngPutAhead572

 // Interface jTcl to C++ for public routeAdd C/C++ function/method
 static int jTcl_routeAdd_573 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[573].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[573].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[573]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[573]);
  return TCL_ERROR;
 } // end jWrap_routeAdd573

 // Interface jTcl to C++ for public routeDelete C/C++ function/method
 static int jTcl_routeDelete_574 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[574].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[574].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[574]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[574]);
  return TCL_ERROR;
 } // end jWrap_routeDelete574

 // Interface jTcl to C++ for public routeNetAdd C/C++ function/method
 static int jTcl_routeNetAdd_575 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[575].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[575].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[575]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[575]);
  return TCL_ERROR;
 } // end jWrap_routeNetAdd575

 // Interface jTcl to C++ for public routeCmd C/C++ function/method
 static int jTcl_routeCmd_576 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[576].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[576].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[576].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[576]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[576]);
  return TCL_ERROR;
 } // end jWrap_routeCmd576

 // Interface jTcl to C++ for public semBSmCreate C/C++ function/method
 static int jTcl_semBSmCreate_577 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[577].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SEM_B_STATE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SEM_B_STATE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SEM_B_STATE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SEM_B_STATE].obj->name);
 }
  wtxCtx[577].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[577]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEM_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[577]);
  return TCL_ERROR;
 } // end jWrap_semBSmCreate577

 // Interface jTcl to C++ for public semCSmCreate C/C++ function/method
 static int jTcl_semCSmCreate_578 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[578].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[578].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[578]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SEM_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[578]);
  return TCL_ERROR;
 } // end jWrap_semCSmCreate578

 // Interface jTcl to C++ for public semSmShowInit C/C++ function/method
 static int jTcl_semSmShowInit_579 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[579]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[579]);
  return TCL_ERROR;
 } // end jWrap_semSmShowInit579

 // Interface jTcl to C++ for public memPartSmCreate C/C++ function/method
 static int jTcl_memPartSmCreate_580 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[580].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[580].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[580]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_PART_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[580]);
  return TCL_ERROR;
 } // end jWrap_memPartSmCreate580

 // Interface jTcl to C++ for public smMemFree C/C++ function/method
 static int jTcl_smMemFree_581 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[581].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[581]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[581]);
  return TCL_ERROR;
 } // end jWrap_smMemFree581

 // Interface jTcl to C++ for public smMemFindMax C/C++ function/method
 static int jTcl_smMemFindMax_582 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[582]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[582]);
  return TCL_ERROR;
 } // end jWrap_smMemFindMax582

 // Interface jTcl to C++ for public smMemMalloc C/C++ function/method
 static int jTcl_smMemMalloc_583 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[583].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[583]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[583]);
  return TCL_ERROR;
 } // end jWrap_smMemMalloc583

 // Interface jTcl to C++ for public smMemCalloc C/C++ function/method
 static int jTcl_smMemCalloc_584 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[584].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[584].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[584]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[584]);
  return TCL_ERROR;
 } // end jWrap_smMemCalloc584

 // Interface jTcl to C++ for public smMemRealloc C/C++ function/method
 static int jTcl_smMemRealloc_585 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[585].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[585].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[585]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[585]);
  return TCL_ERROR;
 } // end jWrap_smMemRealloc585

 // Interface jTcl to C++ for public smMemAddToPool C/C++ function/method
 static int jTcl_smMemAddToPool_586 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[586].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[586].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[586]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[586]);
  return TCL_ERROR;
 } // end jWrap_smMemAddToPool586

 // Interface jTcl to C++ for public smMemOptionsSet C/C++ function/method
 static int jTcl_smMemOptionsSet_587 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[587].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[587]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[587]);
  return TCL_ERROR;
 } // end jWrap_smMemOptionsSet587

 // Interface jTcl to C++ for public smMemShowInit C/C++ function/method
 static int jTcl_smMemShowInit_588 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[588]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[588]);
  return TCL_ERROR;
 } // end jWrap_smMemShowInit588

 // Interface jTcl to C++ for public smMemShow C/C++ function/method
 static int jTcl_smMemShow_589 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[589].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[589]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[589]);
  return TCL_ERROR;
 } // end jWrap_smMemShow589

 // Interface jTcl to C++ for public smNameAdd C/C++ function/method
 static int jTcl_smNameAdd_590 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[590].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[590].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[590].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[590]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[590]);
  return TCL_ERROR;
 } // end jWrap_smNameAdd590

 // Interface jTcl to C++ for public smNameFind C/C++ function/method
 static int jTcl_smNameFind_591 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[591].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr_Ptr].obj->name);
 }
  wtxCtx[591].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[591].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[591].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[591]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[591]);
  return TCL_ERROR;
 } // end jWrap_smNameFind591

 // Interface jTcl to C++ for public smNameFindByValue C/C++ function/method
 static int jTcl_smNameFindByValue_592 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[592].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[592].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[592].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[592].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[592]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[592]);
  return TCL_ERROR;
 } // end jWrap_smNameFindByValue592

 // Interface jTcl to C++ for public smNameRemove C/C++ function/method
 static int jTcl_smNameRemove_593 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[593].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[593]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[593]);
  return TCL_ERROR;
 } // end jWrap_smNameRemove593

 // Interface jTcl to C++ for public smNameShowInit C/C++ function/method
 static int jTcl_smNameShowInit_594 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[594]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[594]);
  return TCL_ERROR;
 } // end jWrap_smNameShowInit594

 // Interface jTcl to C++ for public smNameShow C/C++ function/method
 static int jTcl_smNameShow_595 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[595].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[595]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[595]);
  return TCL_ERROR;
 } // end jWrap_smNameShow595

 // Interface jTcl to C++ for public smObjLibInit C/C++ function/method
 static int jTcl_smObjLibInit_596 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[596]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[596]);
  return TCL_ERROR;
 } // end jWrap_smObjLibInit596

 // Interface jTcl to C++ for public smObjLocalToGlobal C/C++ function/method
 static int jTcl_smObjLocalToGlobal_597 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[597].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[597]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[597]);
  return TCL_ERROR;
 } // end jWrap_smObjLocalToGlobal597

 // Interface jTcl to C++ for public smObjGlobalToLocal C/C++ function/method
 static int jTcl_smObjGlobalToLocal_598 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[598].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[598]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[598]);
  return TCL_ERROR;
 } // end jWrap_smObjGlobalToLocal598

 // Interface jTcl to C++ for public smObjTimeoutLogEnable C/C++ function/method
 static int jTcl_smObjTimeoutLogEnable_599 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[599].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[599]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[599]);
  return TCL_ERROR;
 } // end jWrap_smObjTimeoutLogEnable599

 // Interface jTcl to C++ for public smObjShowInit C/C++ function/method
 static int jTcl_smObjShowInit_600 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[600]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[600]);
  return TCL_ERROR;
 } // end jWrap_smObjShowInit600

 // Interface jTcl to C++ for public smObjShow C/C++ function/method
 static int jTcl_smObjShow_601 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[601]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[601]);
  return TCL_ERROR;
 } // end jWrap_smObjShow601

 // Interface jTcl to C++ for public sockLibInit C/C++ function/method
 static int jTcl_sockLibInit_602 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[602].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[602]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[602]);
  return TCL_ERROR;
 } // end jWrap_sockLibInit602

 // Interface jTcl to C++ for public sockLibAdd C/C++ function/method
 static int jTcl_sockLibAdd_603 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[603].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[603].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[603].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[603]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[603]);
  return TCL_ERROR;
 } // end jWrap_sockLibAdd603

 // Interface jTcl to C++ for public bind C/C++ function/method
 static int jTcl_bind_604 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[604].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[604].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[604].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[604]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[604]);
  return TCL_ERROR;
 } // end jWrap_bind604

 // Interface jTcl to C++ for public connect C/C++ function/method
 static int jTcl_connect_605 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[605].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[605].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[605].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[605]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[605]);
  return TCL_ERROR;
 } // end jWrap_connect605

 // Interface jTcl to C++ for public connectWithTimeout C/C++ function/method
 static int jTcl_connectWithTimeout_606 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[606].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[606].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[606].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_timeval_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_timeval_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_timeval_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_timeval_Ptr].obj->name);
 }
  wtxCtx[606].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[606]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[606]);
  return TCL_ERROR;
 } // end jWrap_connectWithTimeout606

 // Interface jTcl to C++ for public getpeername C/C++ function/method
 static int jTcl_getpeername_607 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[607].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[607].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[607].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[607]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[607]);
  return TCL_ERROR;
 } // end jWrap_getpeername607

 // Interface jTcl to C++ for public getsockname C/C++ function/method
 static int jTcl_getsockname_608 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[608].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[608].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[608].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[608]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[608]);
  return TCL_ERROR;
 } // end jWrap_getsockname608

 // Interface jTcl to C++ for public getsockopt C/C++ function/method
 static int jTcl_getsockopt_609 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[609].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[609].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[609].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[609].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[609].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[609]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[609]);
  return TCL_ERROR;
 } // end jWrap_getsockopt609

 // Interface jTcl to C++ for public listen C/C++ function/method
 static int jTcl_listen_610 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[610].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[610].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[610]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[610]);
  return TCL_ERROR;
 } // end jWrap_listen610

 // Interface jTcl to C++ for public setsockopt C/C++ function/method
 static int jTcl_setsockopt_611 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[611].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[611].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[611].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[611].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[611].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[611]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[611]);
  return TCL_ERROR;
 } // end jWrap_setsockopt611

 // Interface jTcl to C++ for public shutdown C/C++ function/method
 static int jTcl_shutdown_612 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[612].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[612].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[612]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[612]);
  return TCL_ERROR;
 } // end jWrap_shutdown612

 // Interface jTcl to C++ for public accept C/C++ function/method
 static int jTcl_accept_613 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[613].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[613].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[613].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[613]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[613]);
  return TCL_ERROR;
 } // end jWrap_accept613

 // Interface jTcl to C++ for public recv C/C++ function/method
 static int jTcl_recv_614 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[614].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[614].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[614].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[614].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[614]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[614]);
  return TCL_ERROR;
 } // end jWrap_recv614

 // Interface jTcl to C++ for public recvfrom C/C++ function/method
 static int jTcl_recvfrom_615 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 7) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[615].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[615].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[615].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[615].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[615].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[615].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[615]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[615]);
  return TCL_ERROR;
 } // end jWrap_recvfrom615

 // Interface jTcl to C++ for public recvmsg C/C++ function/method
 static int jTcl_recvmsg_616 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[616].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_msghdr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_msghdr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_msghdr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_msghdr_Ptr].obj->name);
 }
  wtxCtx[616].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[616].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[616]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[616]);
  return TCL_ERROR;
 } // end jWrap_recvmsg616

 // Interface jTcl to C++ for public send C/C++ function/method
 static int jTcl_send_617 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[617].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[617].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[617].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[617].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[617]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[617]);
  return TCL_ERROR;
 } // end jWrap_send617

 // Interface jTcl to C++ for public sendmsg C/C++ function/method
 static int jTcl_sendmsg_618 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[618].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_msghdr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_msghdr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_msghdr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_msghdr_Ptr].obj->name);
 }
  wtxCtx[618].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[618].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[618]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[618]);
  return TCL_ERROR;
 } // end jWrap_sendmsg618

 // Interface jTcl to C++ for public sendto C/C++ function/method
 static int jTcl_sendto_619 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 7) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[619].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_caddr_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_caddr_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_caddr_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_caddr_t].obj->name);
 }
  wtxCtx[619].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[619].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[619].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_sockaddr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_sockaddr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_sockaddr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_sockaddr_Ptr].obj->name);
 }
  wtxCtx[619].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[619].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[619]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[619]);
  return TCL_ERROR;
 } // end jWrap_sendto619

 // Interface jTcl to C++ for public socket C/C++ function/method
 static int jTcl_socket_620 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[620].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[620].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[620].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[620]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[620]);
  return TCL_ERROR;
 } // end jWrap_socket620

 // Interface jTcl to C++ for public spyLibInit C/C++ function/method
 static int jTcl_spyLibInit_621 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[621]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[621]);
  return TCL_ERROR;
 } // end jWrap_spyLibInit621

 // Interface jTcl to C++ for public spyClkStartCommon C/C++ function/method
 static int jTcl_spyClkStartCommon_622 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[622].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[622].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[622]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[622]);
  return TCL_ERROR;
 } // end jWrap_spyClkStartCommon622

 // Interface jTcl to C++ for public spyCommon C/C++ function/method
 static int jTcl_spyCommon_623 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[623].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[623].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[623].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[623]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[623]);
  return TCL_ERROR;
 } // end jWrap_spyCommon623

 // Interface jTcl to C++ for public spyClkStopCommon C/C++ function/method
 static int jTcl_spyClkStopCommon_624 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[624]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[624]);
  return TCL_ERROR;
 } // end jWrap_spyClkStopCommon624

 // Interface jTcl to C++ for public spyReportCommon C/C++ function/method
 static int jTcl_spyReportCommon_625 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[625].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[625]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[625]);
  return TCL_ERROR;
 } // end jWrap_spyReportCommon625

 // Interface jTcl to C++ for public spyStopCommon C/C++ function/method
 static int jTcl_spyStopCommon_626 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[626]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[626]);
  return TCL_ERROR;
 } // end jWrap_spyStopCommon626

 // Interface jTcl to C++ for public spyComTask C/C++ function/method
 static int jTcl_spyComTask_627 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[627].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[627].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[627]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[627]);
  return TCL_ERROR;
 } // end jWrap_spyComTask627

 // Interface jTcl to C++ for public symLibInit C/C++ function/method
 static int jTcl_symLibInit_628 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[628]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[628]);
  return TCL_ERROR;
 } // end jWrap_symLibInit628

 // Interface jTcl to C++ for public symEach C/C++ function/method
 static int jTcl_symEach_629 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[629].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[629].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[629].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[629]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SYMBOL_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[629]);
  return TCL_ERROR;
 } // end jWrap_symEach629

 // Interface jTcl to C++ for public symName C/C++ function/method
 static int jTcl_symName_630 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[630].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[630].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[630]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[630]);
  return TCL_ERROR;
 } // end jWrap_symName630

 // Interface jTcl to C++ for public symShowInit C/C++ function/method
 static int jTcl_symShowInit_631 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[631]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[631]);
  return TCL_ERROR;
 } // end jWrap_symShowInit631

 // Interface jTcl to C++ for public symShow C/C++ function/method
 static int jTcl_symShow_632 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[632].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[632].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[632]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[632]);
  return TCL_ERROR;
 } // end jWrap_symShow632

 // Interface jTcl to C++ for public symTblDelete C/C++ function/method
 static int jTcl_symTblDelete_633 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[633].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[633]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[633]);
  return TCL_ERROR;
 } // end jWrap_symTblDelete633

 // Interface jTcl to C++ for public symTblTerminate C/C++ function/method
 static int jTcl_symTblTerminate_634 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[634].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[634]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[634]);
  return TCL_ERROR;
 } // end jWrap_symTblTerminate634

 // Interface jTcl to C++ for public symTblDestroy C/C++ function/method
 static int jTcl_symTblDestroy_635 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[635].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[635].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[635]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[635]);
  return TCL_ERROR;
 } // end jWrap_symTblDestroy635

 // Interface jTcl to C++ for public symFree C/C++ function/method
 static int jTcl_symFree_636 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[636].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMBOL_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMBOL_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMBOL_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SYMBOL_Ptr].obj->name);
 }
  wtxCtx[636].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[636]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[636]);
  return TCL_ERROR;
 } // end jWrap_symFree636

 // Interface jTcl to C++ for public symSAdd C/C++ function/method
 static int jTcl_symSAdd_637 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[637].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[637].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[637].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[637].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[637].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[637]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[637]);
  return TCL_ERROR;
 } // end jWrap_symSAdd637

 // Interface jTcl to C++ for public symAdd C/C++ function/method
 static int jTcl_symAdd_638 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[638].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[638].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[638].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[638].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[638].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[638]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[638]);
  return TCL_ERROR;
 } // end jWrap_symAdd638

 // Interface jTcl to C++ for public symTblAdd C/C++ function/method
 static int jTcl_symTblAdd_639 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[639].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMBOL_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMBOL_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMBOL_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SYMBOL_Ptr].obj->name);
 }
  wtxCtx[639].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[639]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[639]);
  return TCL_ERROR;
 } // end jWrap_symTblAdd639

 // Interface jTcl to C++ for public symRemove C/C++ function/method
 static int jTcl_symRemove_640 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[640].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[640].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[640].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[640]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[640]);
  return TCL_ERROR;
 } // end jWrap_symRemove640

 // Interface jTcl to C++ for public symTblRemove C/C++ function/method
 static int jTcl_symTblRemove_641 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[641].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMBOL_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMBOL_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMBOL_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_SYMBOL_Ptr].obj->name);
 }
  wtxCtx[641].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[641]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[641]);
  return TCL_ERROR;
 } // end jWrap_symTblRemove641

 // Interface jTcl to C++ for public symInit C/C++ function/method
 static int jTcl_symInit_642 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMBOL_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMBOL_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMBOL_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMBOL_Ptr].obj->name);
 }
  wtxCtx[642].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[642].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[642].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[642].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[642].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[642]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[642]);
  return TCL_ERROR;
 } // end jWrap_symInit642

 // Interface jTcl to C++ for public symAlloc C/C++ function/method
 static int jTcl_symAlloc_643 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[643].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[643].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[643].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[643].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[643].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[643]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SYMBOL_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[643]);
  return TCL_ERROR;
 } // end jWrap_symAlloc643

 // Interface jTcl to C++ for public symTblInit C/C++ function/method
 static int jTcl_symTblInit_644 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[644].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[644].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[644].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_HASH_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_HASH_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_HASH_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_HASH_ID].obj->name);
 }
  wtxCtx[644].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[644]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[644]);
  return TCL_ERROR;
 } // end jWrap_symTblInit644

 // Interface jTcl to C++ for public symTblCreate C/C++ function/method
 static int jTcl_symTblCreate_645 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[645].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[645].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_PART_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_PART_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_PART_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_PART_ID].obj->name);
 }
  wtxCtx[645].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[645]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[645]);
  return TCL_ERROR;
 } // end jWrap_symTblCreate645

 // Interface jTcl to C++ for public symFindSymbol C/C++ function/method
 static int jTcl_symFindSymbol_646 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[646].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[646].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[646].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[646].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMBOL_Ptr_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMBOL_Ptr_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMBOL_Ptr_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_SYMBOL_Ptr_Ptr].obj->name);
 }
  wtxCtx[646].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[646]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[646]);
  return TCL_ERROR;
 } // end jWrap_symFindSymbol646

 // Interface jTcl to C++ for public symFindByValue C/C++ function/method
 static int jTcl_symFindByValue_647 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 6) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[647].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[647].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[647].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[647].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE_Ptr].obj->name);
 }
  wtxCtx[647].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[647]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[647]);
  return TCL_ERROR;
 } // end jWrap_symFindByValue647

 // Interface jTcl to C++ for public symFindByValueAndType C/C++ function/method
 static int jTcl_symFindByValueAndType_648 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 8) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYMTAB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYMTAB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYMTAB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_SYMTAB_ID].obj->name);
 }
  wtxCtx[648].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_UINT].obj->name);
 }
  wtxCtx[648].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[648].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[648].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE_Ptr].obj->name);
 }
  wtxCtx[648].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[648].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_SYM_TYPE].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_SYM_TYPE].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_SYM_TYPE].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_SYM_TYPE].obj->name);
 }
  wtxCtx[648].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[648]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[648]);
  return TCL_ERROR;
 } // end jWrap_symFindByValueAndType648

 // Interface jTcl to C++ for public sysModel C/C++ function/method
 static int jTcl_sysModel_649 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[649]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[649]);
  return TCL_ERROR;
 } // end jWrap_sysModel649

 // Interface jTcl to C++ for public sysBspRev C/C++ function/method
 static int jTcl_sysBspRev_650 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[650]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[650]);
  return TCL_ERROR;
 } // end jWrap_sysBspRev650

 // Interface jTcl to C++ for public sysMemTop C/C++ function/method
 static int jTcl_sysMemTop_651 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[651]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[651]);
  return TCL_ERROR;
 } // end jWrap_sysMemTop651

 // Interface jTcl to C++ for public sysPhysMemTop C/C++ function/method
 static int jTcl_sysPhysMemTop_652 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[652]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[652]);
  return TCL_ERROR;
 } // end jWrap_sysPhysMemTop652

 // Interface jTcl to C++ for public sysToMonitor C/C++ function/method
 static int jTcl_sysToMonitor_653 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[653].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[653]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[653]);
  return TCL_ERROR;
 } // end jWrap_sysToMonitor653

 // Interface jTcl to C++ for public sysProcNumGet C/C++ function/method
 static int jTcl_sysProcNumGet_654 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[654]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[654]);
  return TCL_ERROR;
 } // end jWrap_sysProcNumGet654

 // Interface jTcl to C++ for public sysProcNumSet C/C++ function/method
 static int jTcl_sysProcNumSet_655 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[655].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[655]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[655]);
  return TCL_ERROR;
 } // end jWrap_sysProcNumSet655

 // Interface jTcl to C++ for public sysBusTas C/C++ function/method
 static int jTcl_sysBusTas_656 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[656].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[656]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[656]);
  return TCL_ERROR;
 } // end jWrap_sysBusTas656

 // Interface jTcl to C++ for public sysNvRamGet C/C++ function/method
 static int jTcl_sysNvRamGet_657 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[657].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[657].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[657].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[657]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[657]);
  return TCL_ERROR;
 } // end jWrap_sysNvRamGet657

 // Interface jTcl to C++ for public sysNvRamSet C/C++ function/method
 static int jTcl_sysNvRamSet_658 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[658].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[658].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[658].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[658]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[658]);
  return TCL_ERROR;
 } // end jWrap_sysNvRamSet658

 // Interface jTcl to C++ for public sysSerialReset C/C++ function/method
 static int jTcl_sysSerialReset_659 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[659]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[659]);
  return TCL_ERROR;
 } // end jWrap_sysSerialReset659

 // Interface jTcl to C++ for public sysBusIntAck C/C++ function/method
 static int jTcl_sysBusIntAck_660 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[660].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[660]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[660]);
  return TCL_ERROR;
 } // end jWrap_sysBusIntAck660

 // Interface jTcl to C++ for public sysBusIntGen C/C++ function/method
 static int jTcl_sysBusIntGen_661 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[661].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[661].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[661]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[661]);
  return TCL_ERROR;
 } // end jWrap_sysBusIntGen661

 // Interface jTcl to C++ for public sysMailboxConnect C/C++ function/method
 static int jTcl_sysMailboxConnect_662 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[662].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[662].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[662]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[662]);
  return TCL_ERROR;
 } // end jWrap_sysMailboxConnect662

 // Interface jTcl to C++ for public sysMailboxEnable C/C++ function/method
 static int jTcl_sysMailboxEnable_663 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[663].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[663]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[663]);
  return TCL_ERROR;
 } // end jWrap_sysMailboxEnable663

 // Interface jTcl to C++ for public taskHookInit C/C++ function/method
 static int jTcl_taskHookInit_664 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[664]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[664]);
  return TCL_ERROR;
 } // end jWrap_taskHookInit664

 // Interface jTcl to C++ for public taskCreateHookAdd C/C++ function/method
 static int jTcl_taskCreateHookAdd_665 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[665].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[665]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[665]);
  return TCL_ERROR;
 } // end jWrap_taskCreateHookAdd665

 // Interface jTcl to C++ for public taskCreateHookDelete C/C++ function/method
 static int jTcl_taskCreateHookDelete_666 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[666].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[666]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[666]);
  return TCL_ERROR;
 } // end jWrap_taskCreateHookDelete666

 // Interface jTcl to C++ for public taskDeleteHookAdd C/C++ function/method
 static int jTcl_taskDeleteHookAdd_667 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[667].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[667]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[667]);
  return TCL_ERROR;
 } // end jWrap_taskDeleteHookAdd667

 // Interface jTcl to C++ for public taskDeleteHookDelete C/C++ function/method
 static int jTcl_taskDeleteHookDelete_668 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[668].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[668]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[668]);
  return TCL_ERROR;
 } // end jWrap_taskDeleteHookDelete668

 // Interface jTcl to C++ for public taskSwapHookAdd C/C++ function/method
 static int jTcl_taskSwapHookAdd_669 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[669].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[669]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[669]);
  return TCL_ERROR;
 } // end jWrap_taskSwapHookAdd669

 // Interface jTcl to C++ for public taskSwapHookAttach C/C++ function/method
 static int jTcl_taskSwapHookAttach_670 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[670].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[670].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[670].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[670].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[670]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[670]);
  return TCL_ERROR;
 } // end jWrap_taskSwapHookAttach670

 // Interface jTcl to C++ for public taskSwapHookDelete C/C++ function/method
 static int jTcl_taskSwapHookDelete_671 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[671].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[671]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[671]);
  return TCL_ERROR;
 } // end jWrap_taskSwapHookDelete671

 // Interface jTcl to C++ for public taskSwapHookDetach C/C++ function/method
 static int jTcl_taskSwapHookDetach_672 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[672].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[672].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[672].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[672].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[672]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[672]);
  return TCL_ERROR;
 } // end jWrap_taskSwapHookDetach672

 // Interface jTcl to C++ for public taskSwitchHookAdd C/C++ function/method
 static int jTcl_taskSwitchHookAdd_673 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[673].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[673]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[673]);
  return TCL_ERROR;
 } // end jWrap_taskSwitchHookAdd673

 // Interface jTcl to C++ for public taskSwitchHookDelete C/C++ function/method
 static int jTcl_taskSwitchHookDelete_674 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[674].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[674]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[674]);
  return TCL_ERROR;
 } // end jWrap_taskSwitchHookDelete674

 // Interface jTcl to C++ for public taskHookShowInit C/C++ function/method
 static int jTcl_taskHookShowInit_675 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[675]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[675]);
  return TCL_ERROR;
 } // end jWrap_taskHookShowInit675

 // Interface jTcl to C++ for public taskCreateHookShow C/C++ function/method
 static int jTcl_taskCreateHookShow_676 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[676]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[676]);
  return TCL_ERROR;
 } // end jWrap_taskCreateHookShow676

 // Interface jTcl to C++ for public taskDeleteHookShow C/C++ function/method
 static int jTcl_taskDeleteHookShow_677 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[677]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[677]);
  return TCL_ERROR;
 } // end jWrap_taskDeleteHookShow677

 // Interface jTcl to C++ for public taskSwapHookShow C/C++ function/method
 static int jTcl_taskSwapHookShow_678 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[678]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[678]);
  return TCL_ERROR;
 } // end jWrap_taskSwapHookShow678

 // Interface jTcl to C++ for public taskSwitchHookShow C/C++ function/method
 static int jTcl_taskSwitchHookShow_679 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[679]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[679]);
  return TCL_ERROR;
 } // end jWrap_taskSwitchHookShow679

 // Interface jTcl to C++ for public taskSpawn C/C++ function/method
 static int jTcl_taskSpawn_680 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 16) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[680].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[680].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[11]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[11]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[11]->bytes;
   tmpCgetObj.length  = objv[11]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[11];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,10,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[10] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[12]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[12]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[12]->bytes;
   tmpCgetObj.length  = objv[12]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[12];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,11,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[11] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[13]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[13]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[13]->bytes;
   tmpCgetObj.length  = objv[13]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[13];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,12,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[12] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[14]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[14]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[14]->bytes;
   tmpCgetObj.length  = objv[14]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[14];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,13,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[13] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[15]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[15]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[15]->bytes;
   tmpCgetObj.length  = objv[15]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[15];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,14,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[680].args[14] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[680]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[680]);
  return TCL_ERROR;
 } // end jWrap_taskSpawn680

 // Interface jTcl to C++ for public taskInit C/C++ function/method
 static int jTcl_taskInit_681 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 18) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_WIND_TCB_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_WIND_TCB_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_WIND_TCB_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_WIND_TCB_ID].obj->name);
 }
  wtxCtx[681].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[681].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[681].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[681].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[11]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[11]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[11]->bytes;
   tmpCgetObj.length  = objv[11]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[11];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,10,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[10] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[12]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[12]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[12]->bytes;
   tmpCgetObj.length  = objv[12]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[12];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,11,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[11] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[13]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[13]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[13]->bytes;
   tmpCgetObj.length  = objv[13]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[13];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,12,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[12] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[14]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[14]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[14]->bytes;
   tmpCgetObj.length  = objv[14]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[14];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,13,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[13] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[15]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[15]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[15]->bytes;
   tmpCgetObj.length  = objv[15]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[15];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,14,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[14] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[16]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[16]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[16]->bytes;
   tmpCgetObj.length  = objv[16]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[16];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,15,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[15] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[17]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[17]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[17]->bytes;
   tmpCgetObj.length  = objv[17]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[17];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,16,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[681].args[16] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[681]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[681]);
  return TCL_ERROR;
 } // end jWrap_taskInit681

 // Interface jTcl to C++ for public taskActivate C/C++ function/method
 static int jTcl_taskActivate_682 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[682].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[682]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[682]);
  return TCL_ERROR;
 } // end jWrap_taskActivate682

 // Interface jTcl to C++ for public taskDelete C/C++ function/method
 static int jTcl_taskDelete_683 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[683].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[683]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[683]);
  return TCL_ERROR;
 } // end jWrap_taskDelete683

 // Interface jTcl to C++ for public taskDeleteForce C/C++ function/method
 static int jTcl_taskDeleteForce_684 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[684].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[684]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[684]);
  return TCL_ERROR;
 } // end jWrap_taskDeleteForce684

 // Interface jTcl to C++ for public taskSuspend C/C++ function/method
 static int jTcl_taskSuspend_685 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[685].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[685]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[685]);
  return TCL_ERROR;
 } // end jWrap_taskSuspend685

 // Interface jTcl to C++ for public taskResume C/C++ function/method
 static int jTcl_taskResume_686 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[686].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[686]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[686]);
  return TCL_ERROR;
 } // end jWrap_taskResume686

 // Interface jTcl to C++ for public taskRestart C/C++ function/method
 static int jTcl_taskRestart_687 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[687].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[687]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[687]);
  return TCL_ERROR;
 } // end jWrap_taskRestart687

 // Interface jTcl to C++ for public taskPrioritySet C/C++ function/method
 static int jTcl_taskPrioritySet_688 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[688].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[688].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[688]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[688]);
  return TCL_ERROR;
 } // end jWrap_taskPrioritySet688

 // Interface jTcl to C++ for public taskPriorityGet C/C++ function/method
 static int jTcl_taskPriorityGet_689 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[689].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[689].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[689]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[689]);
  return TCL_ERROR;
 } // end jWrap_taskPriorityGet689

 // Interface jTcl to C++ for public taskLock C/C++ function/method
 static int jTcl_taskLock_690 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[690]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[690]);
  return TCL_ERROR;
 } // end jWrap_taskLock690

 // Interface jTcl to C++ for public taskUnlock C/C++ function/method
 static int jTcl_taskUnlock_691 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[691]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[691]);
  return TCL_ERROR;
 } // end jWrap_taskUnlock691

 // Interface jTcl to C++ for public taskSafe C/C++ function/method
 static int jTcl_taskSafe_692 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[692]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[692]);
  return TCL_ERROR;
 } // end jWrap_taskSafe692

 // Interface jTcl to C++ for public taskUnsafe C/C++ function/method
 static int jTcl_taskUnsafe_693 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[693]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[693]);
  return TCL_ERROR;
 } // end jWrap_taskUnsafe693

 // Interface jTcl to C++ for public taskDelay C/C++ function/method
 static int jTcl_taskDelay_694 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[694].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[694]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[694]);
  return TCL_ERROR;
 } // end jWrap_taskDelay694

 // Interface jTcl to C++ for public taskOptionsSet C/C++ function/method
 static int jTcl_taskOptionsSet_695 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[695].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[695].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[695].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[695]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[695]);
  return TCL_ERROR;
 } // end jWrap_taskOptionsSet695

 // Interface jTcl to C++ for public taskOptionsGet C/C++ function/method
 static int jTcl_taskOptionsGet_696 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[696].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[696].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[696]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[696]);
  return TCL_ERROR;
 } // end jWrap_taskOptionsGet696

 // Interface jTcl to C++ for public taskName C/C++ function/method
 static int jTcl_taskName_697 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[697].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[697]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_char_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[697]);
  return TCL_ERROR;
 } // end jWrap_taskName697

 // Interface jTcl to C++ for public taskNameToId C/C++ function/method
 static int jTcl_taskNameToId_698 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[698].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[698]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[698]);
  return TCL_ERROR;
 } // end jWrap_taskNameToId698

 // Interface jTcl to C++ for public taskIdVerify C/C++ function/method
 static int jTcl_taskIdVerify_699 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[699].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[699]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[699]);
  return TCL_ERROR;
 } // end jWrap_taskIdVerify699

 // Interface jTcl to C++ for public taskIdSelf C/C++ function/method
 static int jTcl_taskIdSelf_700 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[700]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[700]);
  return TCL_ERROR;
 } // end jWrap_taskIdSelf700

 // Interface jTcl to C++ for public taskIdDefault C/C++ function/method
 static int jTcl_taskIdDefault_701 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[701].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[701]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[701]);
  return TCL_ERROR;
 } // end jWrap_taskIdDefault701

 // Interface jTcl to C++ for public taskIsReady C/C++ function/method
 static int jTcl_taskIsReady_702 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[702].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[702]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[702]);
  return TCL_ERROR;
 } // end jWrap_taskIsReady702

 // Interface jTcl to C++ for public taskIsSuspended C/C++ function/method
 static int jTcl_taskIsSuspended_703 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[703].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[703]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[703]);
  return TCL_ERROR;
 } // end jWrap_taskIsSuspended703

 // Interface jTcl to C++ for public taskTcb C/C++ function/method
 static int jTcl_taskTcb_704 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[704].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[704]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_WIND_TCB_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[704]);
  return TCL_ERROR;
 } // end jWrap_taskTcb704

 // Interface jTcl to C++ for public taskIdListGet C/C++ function/method
 static int jTcl_taskIdListGet_705 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[705].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[705].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[705]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[705]);
  return TCL_ERROR;
 } // end jWrap_taskIdListGet705

 // Interface jTcl to C++ for public taskInfoGet C/C++ function/method
 static int jTcl_taskInfoGet_706 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[706].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_TASK_DESC_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_TASK_DESC_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_TASK_DESC_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_TASK_DESC_Ptr].obj->name);
 }
  wtxCtx[706].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[706]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[706]);
  return TCL_ERROR;
 } // end jWrap_taskInfoGet706

 // Interface jTcl to C++ for public taskStatusString C/C++ function/method
 static int jTcl_taskStatusString_707 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[707].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[707].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[707]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[707]);
  return TCL_ERROR;
 } // end jWrap_taskStatusString707

 // Interface jTcl to C++ for public taskOptionsString C/C++ function/method
 static int jTcl_taskOptionsString_708 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[708].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[708].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[708]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[708]);
  return TCL_ERROR;
 } // end jWrap_taskOptionsString708

 // Interface jTcl to C++ for public taskRegsShow C/C++ function/method
 static int jTcl_taskRegsShow_709 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[709].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[709]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[709]);
  return TCL_ERROR;
 } // end jWrap_taskRegsShow709

 // Interface jTcl to C++ for public taskStackAllot C/C++ function/method
 static int jTcl_taskStackAllot_710 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[710].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[710].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[710]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[710]);
  return TCL_ERROR;
 } // end jWrap_taskStackAllot710

 // Interface jTcl to C++ for public taskShowInit C/C++ function/method
 static int jTcl_taskShowInit_711 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[711]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[711]);
  return TCL_ERROR;
 } // end jWrap_taskShowInit711

 // Interface jTcl to C++ for public taskShow C/C++ function/method
 static int jTcl_taskShow_712 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[712].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[712].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[712]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[712]);
  return TCL_ERROR;
 } // end jWrap_taskShow712

 // Interface jTcl to C++ for public taskVarAdd C/C++ function/method
 static int jTcl_taskVarAdd_713 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[713].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[713].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[713]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[713]);
  return TCL_ERROR;
 } // end jWrap_taskVarAdd713

 // Interface jTcl to C++ for public taskVarDelete C/C++ function/method
 static int jTcl_taskVarDelete_714 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[714].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[714].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[714]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[714]);
  return TCL_ERROR;
 } // end jWrap_taskVarDelete714

 // Interface jTcl to C++ for public taskVarInit C/C++ function/method
 static int jTcl_taskVarInit_715 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[715]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[715]);
  return TCL_ERROR;
 } // end jWrap_taskVarInit715

 // Interface jTcl to C++ for public taskVarSet C/C++ function/method
 static int jTcl_taskVarSet_716 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[716].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[716].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[716].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[716]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[716]);
  return TCL_ERROR;
 } // end jWrap_taskVarSet716

 // Interface jTcl to C++ for public taskVarGet C/C++ function/method
 static int jTcl_taskVarGet_717 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[717].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int_Ptr].obj->name);
 }
  wtxCtx[717].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[717]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[717]);
  return TCL_ERROR;
 } // end jWrap_taskVarGet717

 // Interface jTcl to C++ for public taskVarInfo C/C++ function/method
 static int jTcl_taskVarInfo_718 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[718].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_TASK_VAR_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_TASK_VAR_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_TASK_VAR_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_TASK_VAR_Ptr].obj->name);
 }
  wtxCtx[718].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[718].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[718]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[718]);
  return TCL_ERROR;
 } // end jWrap_taskVarInfo718

 // Interface jTcl to C++ for public tickAnnounce C/C++ function/method
 static int jTcl_tickAnnounce_719 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[719]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[719]);
  return TCL_ERROR;
 } // end jWrap_tickAnnounce719

 // Interface jTcl to C++ for public tickSet C/C++ function/method
 static int jTcl_tickSet_720 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_ULONG].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_ULONG].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_ULONG].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_ULONG].obj->name);
 }
  wtxCtx[720].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[720]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[720]);
  return TCL_ERROR;
 } // end jWrap_tickSet720

 // Interface jTcl to C++ for public tickGet C/C++ function/method
 static int jTcl_tickGet_721 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[721]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_ULONG].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[721]);
  return TCL_ERROR;
 } // end jWrap_tickGet721

 // Interface jTcl to C++ for public timex C/C++ function/method
 static int jTcl_timex_722 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 10) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[722].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[722].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[722]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[722]);
  return TCL_ERROR;
 } // end jWrap_timex722

 // Interface jTcl to C++ for public timexClear C/C++ function/method
 static int jTcl_timexClear_723 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[723]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[723]);
  return TCL_ERROR;
 } // end jWrap_timexClear723

 // Interface jTcl to C++ for public timexFunc C/C++ function/method
 static int jTcl_timexFunc_724 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[724].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[724].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[724]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[724]);
  return TCL_ERROR;
 } // end jWrap_timexFunc724

 // Interface jTcl to C++ for public timexHelp C/C++ function/method
 static int jTcl_timexHelp_725 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[725]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[725]);
  return TCL_ERROR;
 } // end jWrap_timexHelp725

 // Interface jTcl to C++ for public timexInit C/C++ function/method
 static int jTcl_timexInit_726 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[726]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[726]);
  return TCL_ERROR;
 } // end jWrap_timexInit726

 // Interface jTcl to C++ for public timexN C/C++ function/method
 static int jTcl_timexN_727 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 10) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[727].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[727].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[727]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[727]);
  return TCL_ERROR;
 } // end jWrap_timexN727

 // Interface jTcl to C++ for public timexPost C/C++ function/method
 static int jTcl_timexPost_728 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[728].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[728].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[728]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[728]);
  return TCL_ERROR;
 } // end jWrap_timexPost728

 // Interface jTcl to C++ for public timexPre C/C++ function/method
 static int jTcl_timexPre_729 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[729].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[729].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[729]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[729]);
  return TCL_ERROR;
 } // end jWrap_timexPre729

 // Interface jTcl to C++ for public timexShow C/C++ function/method
 static int jTcl_timexShow_730 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[730]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[730]);
  return TCL_ERROR;
 } // end jWrap_timexShow730

 // Interface jTcl to C++ for public unld C/C++ function/method
 static int jTcl_unld_731 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[731].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[731].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[731]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[731]);
  return TCL_ERROR;
 } // end jWrap_unld731

 // Interface jTcl to C++ for public unldByNameAndPath C/C++ function/method
 static int jTcl_unldByNameAndPath_732 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[732].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[732].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[732].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[732]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[732]);
  return TCL_ERROR;
 } // end jWrap_unldByNameAndPath732

 // Interface jTcl to C++ for public unldByGroup C/C++ function/method
 static int jTcl_unldByGroup_733 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_UINT16].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_UINT16].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_UINT16].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_UINT16].obj->name);
 }
  wtxCtx[733].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[733].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[733]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[733]);
  return TCL_ERROR;
 } // end jWrap_unldByGroup733

 // Interface jTcl to C++ for public unldByModuleId C/C++ function/method
 static int jTcl_unldByModuleId_734 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_MODULE_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_MODULE_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_MODULE_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_MODULE_ID].obj->name);
 }
  wtxCtx[734].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[734].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[734]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[734]);
  return TCL_ERROR;
 } // end jWrap_unldByModuleId734

 // Interface jTcl to C++ for public reld C/C++ function/method
 static int jTcl_reld_735 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[735].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[735].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[735]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[735]);
  return TCL_ERROR;
 } // end jWrap_reld735

 // Interface jTcl to C++ for public help C/C++ function/method
 static int jTcl_help_736 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[736]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[736]);
  return TCL_ERROR;
 } // end jWrap_help736

 // Interface jTcl to C++ for public netHelp C/C++ function/method
 static int jTcl_netHelp_737 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[737]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[737]);
  return TCL_ERROR;
 } // end jWrap_netHelp737

 // Interface jTcl to C++ for public bootChange C/C++ function/method
 static int jTcl_bootChange_738 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[738]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[738]);
  return TCL_ERROR;
 } // end jWrap_bootChange738

 // Interface jTcl to C++ for public periodRun C/C++ function/method
 static int jTcl_periodRun_739 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[739].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[739].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[739]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[739]);
  return TCL_ERROR;
 } // end jWrap_periodRun739

 // Interface jTcl to C++ for public period C/C++ function/method
 static int jTcl_period_740 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[740].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[740].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[740]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[740]);
  return TCL_ERROR;
 } // end jWrap_period740

 // Interface jTcl to C++ for public repeatRun C/C++ function/method
 static int jTcl_repeatRun_741 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[741].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[741].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[741]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[741]);
  return TCL_ERROR;
 } // end jWrap_repeatRun741

 // Interface jTcl to C++ for public repeat C/C++ function/method
 static int jTcl_repeat_742 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[742].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[742].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[742]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[742]);
  return TCL_ERROR;
 } // end jWrap_repeat742

 // Interface jTcl to C++ for public sp C/C++ function/method
 static int jTcl_sp_743 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 11) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[743].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[5]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[5]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[5]->bytes;
   tmpCgetObj.length  = objv[5]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[5];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,4,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[4] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[6]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[6]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[6]->bytes;
   tmpCgetObj.length  = objv[6]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[6];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,5,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[5] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[7]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[7]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[7]->bytes;
   tmpCgetObj.length  = objv[7]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[7];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,6,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[6] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[8]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[8]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[8]->bytes;
   tmpCgetObj.length  = objv[8]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[8];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,7,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[7] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[9]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[9]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[9]->bytes;
   tmpCgetObj.length  = objv[9]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[9];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,8,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[8] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[10]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[10]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[10]->bytes;
   tmpCgetObj.length  = objv[10]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[10];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,9,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[743].args[9] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[743]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[743]);
  return TCL_ERROR;
 } // end jWrap_sp743

 // Interface jTcl to C++ for public taskIdFigure C/C++ function/method
 static int jTcl_taskIdFigure_744 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[744].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[744]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[744]);
  return TCL_ERROR;
 } // end jWrap_taskIdFigure744

 // Interface jTcl to C++ for public checkStack C/C++ function/method
 static int jTcl_checkStack_745 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[745].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[745]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[745]);
  return TCL_ERROR;
 } // end jWrap_checkStack745

 // Interface jTcl to C++ for public i C/C++ function/method
 static int jTcl_i_746 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[746].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[746]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[746]);
  return TCL_ERROR;
 } // end jWrap_i746

 // Interface jTcl to C++ for public ts C/C++ function/method
 static int jTcl_ts_747 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[747].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[747]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[747]);
  return TCL_ERROR;
 } // end jWrap_ts747

 // Interface jTcl to C++ for public tr C/C++ function/method
 static int jTcl_tr_748 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[748].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[748]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[748]);
  return TCL_ERROR;
 } // end jWrap_tr748

 // Interface jTcl to C++ for public td C/C++ function/method
 static int jTcl_td_749 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[749].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[749]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[749]);
  return TCL_ERROR;
 } // end jWrap_td749

 // Interface jTcl to C++ for public ti C/C++ function/method
 static int jTcl_ti_750 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[750].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[750]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[750]);
  return TCL_ERROR;
 } // end jWrap_ti750

 // Interface jTcl to C++ for public version C/C++ function/method
 static int jTcl_version_751 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[751]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[751]);
  return TCL_ERROR;
 } // end jWrap_version751

 // Interface jTcl to C++ for public m C/C++ function/method
 static int jTcl_m_752 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[752].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[752].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[752]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[752]);
  return TCL_ERROR;
 } // end jWrap_m752

 // Interface jTcl to C++ for public d C/C++ function/method
 static int jTcl_d_753 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[753].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[753].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[753].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[753]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[753]);
  return TCL_ERROR;
 } // end jWrap_d753

 // Interface jTcl to C++ for public cd C/C++ function/method
 static int jTcl_cd_754 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[754].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[754]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[754]);
  return TCL_ERROR;
 } // end jWrap_cd754

 // Interface jTcl to C++ for public pwd C/C++ function/method
 static int jTcl_pwd_755 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[755]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[755]);
  return TCL_ERROR;
 } // end jWrap_pwd755

 // Interface jTcl to C++ for public copy C/C++ function/method
 static int jTcl_copy_756 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[756].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[756].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[756]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[756]);
  return TCL_ERROR;
 } // end jWrap_copy756

 // Interface jTcl to C++ for public copyStreams C/C++ function/method
 static int jTcl_copyStreams_757 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[757].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[757].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[757]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[757]);
  return TCL_ERROR;
 } // end jWrap_copyStreams757

 // Interface jTcl to C++ for public diskFormat C/C++ function/method
 static int jTcl_diskFormat_758 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[758].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[758]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[758]);
  return TCL_ERROR;
 } // end jWrap_diskFormat758

 // Interface jTcl to C++ for public diskInit C/C++ function/method
 static int jTcl_diskInit_759 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[759].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[759]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[759]);
  return TCL_ERROR;
 } // end jWrap_diskInit759

 // Interface jTcl to C++ for public squeeze C/C++ function/method
 static int jTcl_squeeze_760 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[760].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[760]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[760]);
  return TCL_ERROR;
 } // end jWrap_squeeze760

 // Interface jTcl to C++ for public ld C/C++ function/method
 static int jTcl_ld_761 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[761].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[761].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[761].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[761]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_MODULE_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[761]);
  return TCL_ERROR;
 } // end jWrap_ld761

 // Interface jTcl to C++ for public ls C/C++ function/method
 static int jTcl_ls_762 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[762].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[762].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[762]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[762]);
  return TCL_ERROR;
 } // end jWrap_ls762

 // Interface jTcl to C++ for public ll C/C++ function/method
 static int jTcl_ll_763 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[763].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[763]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[763]);
  return TCL_ERROR;
 } // end jWrap_ll763

 // Interface jTcl to C++ for public lsOld C/C++ function/method
 static int jTcl_lsOld_764 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[764].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[764]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[764]);
  return TCL_ERROR;
 } // end jWrap_lsOld764

 // Interface jTcl to C++ for public rm C/C++ function/method
 static int jTcl_rm_765 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[765].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[765]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[765]);
  return TCL_ERROR;
 } // end jWrap_rm765

 // Interface jTcl to C++ for public devs C/C++ function/method
 static int jTcl_devs_766 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[766]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[766]);
  return TCL_ERROR;
 } // end jWrap_devs766

 // Interface jTcl to C++ for public lkup C/C++ function/method
 static int jTcl_lkup_767 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[767].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[767]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[767]);
  return TCL_ERROR;
 } // end jWrap_lkup767

 // Interface jTcl to C++ for public lkAddr C/C++ function/method
 static int jTcl_lkAddr_768 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[768].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[768]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[768]);
  return TCL_ERROR;
 } // end jWrap_lkAddr768

 // Interface jTcl to C++ for public mRegs C/C++ function/method
 static int jTcl_mRegs_769 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[769].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[769].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[769]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[769]);
  return TCL_ERROR;
 } // end jWrap_mRegs769

 // Interface jTcl to C++ for public printErrno C/C++ function/method
 static int jTcl_printErrno_770 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[770].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[770]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[770]);
  return TCL_ERROR;
 } // end jWrap_printErrno770

 // Interface jTcl to C++ for public printLogo C/C++ function/method
 static int jTcl_printLogo_771 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[771]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[771]);
  return TCL_ERROR;
 } // end jWrap_printLogo771

 // Interface jTcl to C++ for public logout C/C++ function/method
 static int jTcl_logout_772 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[772]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[772]);
  return TCL_ERROR;
 } // end jWrap_logout772

 // Interface jTcl to C++ for public h C/C++ function/method
 static int jTcl_h_773 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[773].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[773]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[773]);
  return TCL_ERROR;
 } // end jWrap_h773

 // Interface jTcl to C++ for public pc C/C++ function/method
 static int jTcl_pc_774 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[774].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[774]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[774]);
  return TCL_ERROR;
 } // end jWrap_pc774

 // Interface jTcl to C++ for public show C/C++ function/method
 static int jTcl_show_775 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[775].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[775].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[775]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[775]);
  return TCL_ERROR;
 } // end jWrap_show775

 // Interface jTcl to C++ for public spyClkStart C/C++ function/method
 static int jTcl_spyClkStart_776 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[776].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[776]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[776]);
  return TCL_ERROR;
 } // end jWrap_spyClkStart776

 // Interface jTcl to C++ for public spyClkStop C/C++ function/method
 static int jTcl_spyClkStop_777 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[777]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[777]);
  return TCL_ERROR;
 } // end jWrap_spyClkStop777

 // Interface jTcl to C++ for public spy C/C++ function/method
 static int jTcl_spy_778 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[778].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[778].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[778]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[778]);
  return TCL_ERROR;
 } // end jWrap_spy778

 // Interface jTcl to C++ for public spyStop C/C++ function/method
 static int jTcl_spyStop_779 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[779]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[779]);
  return TCL_ERROR;
 } // end jWrap_spyStop779

 // Interface jTcl to C++ for public spyHelp C/C++ function/method
 static int jTcl_spyHelp_780 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[780]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[780]);
  return TCL_ERROR;
 } // end jWrap_spyHelp780

 // Interface jTcl to C++ for public spyReport C/C++ function/method
 static int jTcl_spyReport_781 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[781]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[781]);
  return TCL_ERROR;
 } // end jWrap_spyReport781

 // Interface jTcl to C++ for public spyTask C/C++ function/method
 static int jTcl_spyTask_782 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[782].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[782]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[782]);
  return TCL_ERROR;
 } // end jWrap_spyTask782

 // Interface jTcl to C++ for public sysMemProbe C/C++ function/method
 static int jTcl_sysMemProbe_783 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[783].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[783]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[783]);
  return TCL_ERROR;
 } // end jWrap_sysMemProbe783

 // Interface jTcl to C++ for public vxMemProbe C/C++ function/method
 static int jTcl_vxMemProbe_784 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[784].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[784].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[784].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[784].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[784]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[784]);
  return TCL_ERROR;
 } // end jWrap_vxMemProbe784

 // Interface jTcl to C++ for public vxTas C/C++ function/method
 static int jTcl_vxTas_785 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[785].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[785]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[785]);
  return TCL_ERROR;
 } // end jWrap_vxTas785

 // Interface jTcl to C++ for public wdLibInit C/C++ function/method
 static int jTcl_wdLibInit_786 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[786]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[786]);
  return TCL_ERROR;
 } // end jWrap_wdLibInit786

 // Interface jTcl to C++ for public wdCreate C/C++ function/method
 static int jTcl_wdCreate_787 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[787]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_WDOG_ID].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[787]);
  return TCL_ERROR;
 } // end jWrap_wdCreate787

 // Interface jTcl to C++ for public wdDelete C/C++ function/method
 static int jTcl_wdDelete_788 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_WDOG_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_WDOG_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_WDOG_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_WDOG_ID].obj->name);
 }
  wtxCtx[788].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[788]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[788]);
  return TCL_ERROR;
 } // end jWrap_wdDelete788

 // Interface jTcl to C++ for public wdStart C/C++ function/method
 static int jTcl_wdStart_789 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 5) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_WDOG_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_WDOG_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_WDOG_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_WDOG_ID].obj->name);
 }
  wtxCtx[789].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[789].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[789].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[4]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[4]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[4]->bytes;
   tmpCgetObj.length  = objv[4]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[4];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,3,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[789].args[3] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[789]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[789]);
  return TCL_ERROR;
 } // end jWrap_wdStart789

 // Interface jTcl to C++ for public wdCancel C/C++ function/method
 static int jTcl_wdCancel_790 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_WDOG_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_WDOG_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_WDOG_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_WDOG_ID].obj->name);
 }
  wtxCtx[790].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[790]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[790]);
  return TCL_ERROR;
 } // end jWrap_wdCancel790

 // Interface jTcl to C++ for public wdShowInit C/C++ function/method
 static int jTcl_wdShowInit_791 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[791]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[791]);
  return TCL_ERROR;
 } // end jWrap_wdShowInit791

 // Interface jTcl to C++ for public wdShow C/C++ function/method
 static int jTcl_wdShow_792 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_WDOG_ID].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_WDOG_ID].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_WDOG_ID].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_WDOG_ID].obj->name);
 }
  wtxCtx[792].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[792]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[792]);
  return TCL_ERROR;
 } // end jWrap_wdShow792

 // Interface jTcl to C++ for public wvEvtLogEnable C/C++ function/method
 static int jTcl_wvEvtLogEnable_793 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[793].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[793]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[793]);
  return TCL_ERROR;
 } // end jWrap_wvEvtLogEnable793

 // Interface jTcl to C++ for public wvEvtLogDisable C/C++ function/method
 static int jTcl_wvEvtLogDisable_794 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[794]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[794]);
  return TCL_ERROR;
 } // end jWrap_wvEvtLogDisable794

 // Interface jTcl to C++ for public wvOn C/C++ function/method
 static int jTcl_wvOn_795 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[795].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[795]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[795]);
  return TCL_ERROR;
 } // end jWrap_wvOn795

 // Interface jTcl to C++ for public wvOff C/C++ function/method
 static int jTcl_wvOff_796 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[796]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[796]);
  return TCL_ERROR;
 } // end jWrap_wvOff796

 // Interface jTcl to C++ for public wvEvtLogStop C/C++ function/method
 static int jTcl_wvEvtLogStop_797 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[797]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[797]);
  return TCL_ERROR;
 } // end jWrap_wvEvtLogStop797

 // Interface jTcl to C++ for public wvEvtTaskInit C/C++ function/method
 static int jTcl_wvEvtTaskInit_798 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[798].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[798].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[798]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[798]);
  return TCL_ERROR;
 } // end jWrap_wvEvtTaskInit798

 // Interface jTcl to C++ for public wvInstInit C/C++ function/method
 static int jTcl_wvInstInit_799 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[799].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_size_t].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_size_t].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_size_t].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_size_t].obj->name);
 }
  wtxCtx[799].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[799].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[799]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_void_Ptr].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[799]);
  return TCL_ERROR;
 } // end jWrap_wvInstInit799

 // Interface jTcl to C++ for public wvLibInit C/C++ function/method
 static int jTcl_wvLibInit_800 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 1) goto errorNumArg;

 // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[800]);

 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[800]);
  return TCL_ERROR;
 } // end jWrap_wvLibInit800

 // Interface jTcl to C++ for public wvObjInstModeSet C/C++ function/method
 static int jTcl_wvObjInstModeSet_801 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[801].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[801]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[801]);
  return TCL_ERROR;
 } // end jWrap_wvObjInstModeSet801

 // Interface jTcl to C++ for public wvObjInst C/C++ function/method
 static int jTcl_wvObjInst_802 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 4) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[802].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_void_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_void_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_void_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_void_Ptr].obj->name);
 }
  wtxCtx[802].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[3]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[3]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[3]->bytes;
   tmpCgetObj.length  = objv[3]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[3];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,2,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[802].args[2] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[802]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[802]);
  return TCL_ERROR;
 } // end jWrap_wvObjInst802

 // Interface jTcl to C++ for public wvSigInst C/C++ function/method
 static int jTcl_wvSigInst_803 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[803].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[803]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[803]);
  return TCL_ERROR;
 } // end jWrap_wvSigInst803

 // Interface jTcl to C++ for public wvHostInfoInit C/C++ function/method
 static int jTcl_wvHostInfoInit_804 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_char_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_char_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_char_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_char_Ptr].obj->name);
 }
  wtxCtx[804].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[804].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[804]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[804]);
  return TCL_ERROR;
 } // end jWrap_wvHostInfoInit804

 // Interface jTcl to C++ for public wvServerInit C/C++ function/method
 static int jTcl_wvServerInit_805 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 3) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[805].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // Check for user application object
 if (objv[2]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[2]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[2]->bytes;
   tmpCgetObj.length  = objv[2]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[2];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_int].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_int].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_int].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,1,currentObj->typePtr->name,usedType[JTYPE_int].obj->name);
 }
  wtxCtx[805].args[1] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[805]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[805]);
  return TCL_ERROR;
 } // end jWrap_wvServerInit805

 // Interface jTcl to C++ for public customInit C/C++ function/method
 static int jTcl_customInit_806 (
  ClientData cld, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
 {
 int status;
 Tcl_Obj *currentObj;
 Tcl_Obj tmpCgetObj;
 Tcl_Obj *resultPtr;
 void  *result;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   if (jWrapStaticMessage[0] != '\0') {
     Tcl_SetResult (interp,jWrapStaticMessage,TCL_STATIC);
   }
   return TCL_ERROR;
 }

 // First check if params number is OK
 if (objc != 2) goto errorNumArg;

 // Check for user application object
 if (objv[1]->typePtr == &jWrapTypeTclObj) {
   JWRAP_cgets* cget;
   cget = (JWRAP_cgets*)objv[1]->internalRep.twoPtrValue.ptr1;
   // create a tempry object with cget slot
   tmpCgetObj.bytes   = objv[1]->bytes;
   tmpCgetObj.length  = objv[1]->length;
   tmpCgetObj.typePtr = cget->type;
   tmpCgetObj.internalRep.otherValuePtr = cget->valueAdr;
   currentObj    = &tmpCgetObj;
 } else {
   currentObj  = objv[1];
 }
 // convert to our wanted application type
 if (currentObj->typePtr == NULL) {
   status = ((Function*)usedType[JTYPE_Tcl_Interp_Ptr].obj->setFromAnyProc)
            (interp, currentObj, NULL);
   if (status != TCL_OK) return status;
   currentObj->typePtr = usedType[JTYPE_Tcl_Interp_Ptr].obj;
 } else if (currentObj->typePtr->updateStringProc
     != usedType[JTYPE_Tcl_Interp_Ptr].obj->updateStringProc) {
  jWrapPanic (interp,errTypeFmt  ,0,currentObj->typePtr->name,usedType[JTYPE_Tcl_Interp_Ptr].obj->name);
 }
  wtxCtx[806].args[0] = (TGT_ARG_T)currentObj->internalRep.longValue;
   // effectivelly call routine on target
 result = tornadoExecFuncCall (&tornadoId, &wtxCtx[806]);

 resultPtr = Tcl_GetObjResult (interp);
 // copy result in Tcl internal value without checking it
 resultPtr->internalRep.twoPtrValue.ptr1 = result;
 resultPtr->bytes = NULL;
 resultPtr->typePtr = usedType[JTYPE_int].obj;
 return TCL_OK;

 errorNumArg:
  Tcl_WrongNumArgs (interp,1,objv, helpCmd[806]);
  return TCL_ERROR;
 } // end jWrap_customInit806


/* ***  Tcl Register Section *** */
#ifdef __cplusplus
extern "C" {
#endif

/* ***  Tcl Register Section *** */
#ifdef __cplusplus
extern "C" {
#endif
PUBLIC int Vxworks_Init (Tcl_Interp *interp) {
 // Dont init twice
 if (initDone) return TCL_OK;
 initDone = 1;

 /* --- Build module handle & register it in jWrap --- */

 tornadoInfo.magic         = TORNADO_INFO_MAGIC;
 tornadoInfo.wtxCtx        = wtxCtx;
 tornadoInfo.nameCmd       = nameCmd;
 tornadoInfo.tornadoId         = &tornadoId;
 tornadoInfo.stringType    = &stringPtrType;
 tornadoInfo.tornadoFree       = (void*)freeTornadoLocal;

 module.magic        = JWRAP_MODULE;
 module.name           = "VxWorks";
 module.help           = "VxWorks Target interface thru target server";
 module.helpCmd        = helpCmd;
 module.nbCmd          = 807;
 module.hashTable      = NULL;
 module.version        = VxWorks_CUSTOM_STAMP;
 module.structures   = structures;
 module.enumerations = enumerations;
 module.info           = (ClientData) &tornadoInfo;

 // prepare emergency panic return
 if (setjmp (jWrapCheckPoint)) {
   return TCL_ERROR;
 }
 // Register Target string type
 Tcl_RegisterObjType (&stringType);
 Tcl_RegisterObjType (&stringPtrType);


 // init routines user or default
#ifdef VxWorks_CUSTOM_INIT
 VxWorks_CUSTOM_INIT;
#else
 if (Tornado_Init (interp) != TCL_OK) return TCL_ERROR;
#endif
 jWrapModuleRegister (interp,&module);

 jWrapEnumRegister (&module,&Define_VxWorks_enum,&Define_VxWorks_type);

 /* --- Enumeration Section --- */

 jWrapEnumRegister (&module, &Enum_VxWorks_0_enum,&Enum_VxWorks_0_type);
 jWrapEnumRegister (&module, &Enum_VxWorks_1_enum,&Enum_VxWorks_1_type);
 
 /* *** Type Structs/Unions Section *** */
 {  // Compute Struct_VxWorks_0 structure offset
  struct Struct_VxWorks_0 dummy4offset;
  Struct_VxWorks_0_slotOffsets [0] = (char*)&dummy4offset.quot - (char*)&dummy4offset;
  Struct_VxWorks_0_slotOffsets [1] = (char*)&dummy4offset.rem - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_0_struct,&Struct_VxWorks_0_type,&Struct_VxWorks_0_ptr );
 };
 {  // Compute aiocb structure offset
  struct aiocb dummy4offset;
  aiocb_slotOffsets [0] = (char*)&dummy4offset.aio_fildes - (char*)&dummy4offset;
  aiocb_slotOffsets [1] = (char*)&dummy4offset.aio_offset - (char*)&dummy4offset;
  aiocb_slotOffsets [2] = (char*)&dummy4offset.aio_buf - (char*)&dummy4offset;
  aiocb_slotOffsets [3] = (char*)&dummy4offset.aio_nbytes - (char*)&dummy4offset;
  aiocb_slotOffsets [4] = (char*)&dummy4offset.aio_reqprio - (char*)&dummy4offset;
  aiocb_slotOffsets [5] = (char*)&dummy4offset.aio_sigevent - (char*)&dummy4offset;
  aiocb_slotOffsets [6] = (char*)&dummy4offset.aio_lio_opcode - (char*)&dummy4offset;
  aiocb_slotOffsets [7] = (char*)&dummy4offset.aio_sys - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&aiocb_struct,&aiocb_type,&aiocb_ptr );
 };
 {  // Compute utimbuf structure offset
  struct utimbuf dummy4offset;
  utimbuf_slotOffsets [0] = (char*)&dummy4offset.actime - (char*)&dummy4offset;
  utimbuf_slotOffsets [1] = (char*)&dummy4offset.modtime - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&utimbuf_struct,&utimbuf_type,&utimbuf_ptr );
 };
 {  // Compute tm structure offset
  struct tm dummy4offset;
  tm_slotOffsets [0] = (char*)&dummy4offset.tm_sec - (char*)&dummy4offset;
  tm_slotOffsets [1] = (char*)&dummy4offset.tm_min - (char*)&dummy4offset;
  tm_slotOffsets [2] = (char*)&dummy4offset.tm_hour - (char*)&dummy4offset;
  tm_slotOffsets [3] = (char*)&dummy4offset.tm_mday - (char*)&dummy4offset;
  tm_slotOffsets [4] = (char*)&dummy4offset.tm_mon - (char*)&dummy4offset;
  tm_slotOffsets [5] = (char*)&dummy4offset.tm_year - (char*)&dummy4offset;
  tm_slotOffsets [6] = (char*)&dummy4offset.tm_wday - (char*)&dummy4offset;
  tm_slotOffsets [7] = (char*)&dummy4offset.tm_yday - (char*)&dummy4offset;
  tm_slotOffsets [8] = (char*)&dummy4offset.tm_isdst - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&tm_struct,&tm_type,&tm_ptr );
 };
 {  // Compute vx_timespec structure offset
  struct vx_timespec dummy4offset;
  vx_timespec_slotOffsets [0] = (char*)&dummy4offset.tv_sec - (char*)&dummy4offset;
  vx_timespec_slotOffsets [1] = (char*)&dummy4offset.tv_nsec - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&vx_timespec_struct,&vx_timespec_type,&vx_timespec_ptr );
 };
 {  // Compute itimerspec structure offset
  struct itimerspec dummy4offset;
  itimerspec_slotOffsets [0] = (char*)&dummy4offset.it_interval - (char*)&dummy4offset;
  itimerspec_slotOffsets [1] = (char*)&dummy4offset.it_value - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&itimerspec_struct,&itimerspec_type,&itimerspec_ptr );
 };
 {  // Compute sigevent structure offset
  struct sigevent dummy4offset;
  sigevent_slotOffsets [0] = (char*)&dummy4offset.sigev_signo - (char*)&dummy4offset;
  sigevent_slotOffsets [1] = (char*)&dummy4offset.sigev_value - (char*)&dummy4offset;
  sigevent_slotOffsets [2] = (char*)&dummy4offset.sigev_notify - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&sigevent_struct,&sigevent_type,&sigevent_ptr );
 };
 {  // Compute siginfo structure offset
  struct siginfo dummy4offset;
  siginfo_slotOffsets [0] = (char*)&dummy4offset.si_signo - (char*)&dummy4offset;
  siginfo_slotOffsets [1] = (char*)&dummy4offset.si_code - (char*)&dummy4offset;
  siginfo_slotOffsets [2] = (char*)&dummy4offset.si_value - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&siginfo_struct,&siginfo_type,&siginfo_ptr );
 };
 {  // Compute sigaction structure offset
  struct sigaction dummy4offset;
  sigaction_slotOffsets [0] = (char*)&dummy4offset.sa_u - (char*)&dummy4offset;
  sigaction_slotOffsets [1] = (char*)&dummy4offset.sa_mask - (char*)&dummy4offset;
  sigaction_slotOffsets [2] = (char*)&dummy4offset.sa_flags - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&sigaction_struct,&sigaction_type,&sigaction_ptr );
 };
 {  // Compute node structure offset
  struct node dummy4offset;
  node_slotOffsets [0] = (char*)&dummy4offset.next - (char*)&dummy4offset;
  node_slotOffsets [1] = (char*)&dummy4offset.previous - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&node_struct,&node_type,&node_ptr );
 };
 {  // Compute Struct_VxWorks_1 structure offset
  struct Struct_VxWorks_1 dummy4offset;
  Struct_VxWorks_1_slotOffsets [0] = (char*)&dummy4offset.node - (char*)&dummy4offset;
  Struct_VxWorks_1_slotOffsets [1] = (char*)&dummy4offset.count - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_1_struct,&Struct_VxWorks_1_type,&Struct_VxWorks_1_ptr );
 };
 {  // Compute Struct_VxWorks_2 structure offset
  struct Struct_VxWorks_2 dummy4offset;
  Struct_VxWorks_2_slotOffsets [0] = (char*)&dummy4offset.bootDev - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [1] = (char*)&dummy4offset.hostName - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [2] = (char*)&dummy4offset.targetName - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [3] = (char*)&dummy4offset.ead - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [4] = (char*)&dummy4offset.bad - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [5] = (char*)&dummy4offset.had - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [6] = (char*)&dummy4offset.gad - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [7] = (char*)&dummy4offset.bootFile - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [8] = (char*)&dummy4offset.startupScript - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [9] = (char*)&dummy4offset.usr - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [10] = (char*)&dummy4offset.passwd - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [11] = (char*)&dummy4offset.other - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [12] = (char*)&dummy4offset.procNum - (char*)&dummy4offset;
  Struct_VxWorks_2_slotOffsets [13] = (char*)&dummy4offset.flags - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_2_struct,&Struct_VxWorks_2_type,&Struct_VxWorks_2_ptr );
 };
 {  // Compute in_addr structure offset
  struct in_addr dummy4offset;
  in_addr_slotOffsets [0] = (char*)&dummy4offset.s_addr - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&in_addr_struct,&in_addr_type,&in_addr_ptr );
 };
 {  // Compute sockaddr_in structure offset
  struct sockaddr_in dummy4offset;
  sockaddr_in_slotOffsets [0] = (char*)&dummy4offset.sin_family - (char*)&dummy4offset;
  sockaddr_in_slotOffsets [1] = (char*)&dummy4offset.sin_port - (char*)&dummy4offset;
  sockaddr_in_slotOffsets [2] = (char*)&dummy4offset.sin_addr - (char*)&dummy4offset;
  sockaddr_in_slotOffsets [3] = (char*)&dummy4offset.sin_zero - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&sockaddr_in_struct,&sockaddr_in_type,&sockaddr_in_ptr );
 };
 {  // Compute hostname_struct structure offset
  struct hostname_struct dummy4offset;
  hostname_struct_slotOffsets [0] = (char*)&dummy4offset.link - (char*)&dummy4offset;
  hostname_struct_slotOffsets [1] = (char*)&dummy4offset.name - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&hostname_struct_struct,&hostname_struct_type,&hostname_struct_ptr );
 };
 {  // Compute Struct_VxWorks_3 structure offset
  struct Struct_VxWorks_3 dummy4offset;
  Struct_VxWorks_3_slotOffsets [0] = (char*)&dummy4offset.node - (char*)&dummy4offset;
  Struct_VxWorks_3_slotOffsets [1] = (char*)&dummy4offset.hostName - (char*)&dummy4offset;
  Struct_VxWorks_3_slotOffsets [2] = (char*)&dummy4offset.netAddr - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_3_struct,&Struct_VxWorks_3_type,&Struct_VxWorks_3_ptr );
 };
 {  // Compute bootp_msg structure offset
  struct bootp_msg dummy4offset;
  bootp_msg_slotOffsets [0] = (char*)&dummy4offset.bp_op - (char*)&dummy4offset;
  bootp_msg_slotOffsets [1] = (char*)&dummy4offset.bp_htype - (char*)&dummy4offset;
  bootp_msg_slotOffsets [2] = (char*)&dummy4offset.bp_hlen - (char*)&dummy4offset;
  bootp_msg_slotOffsets [3] = (char*)&dummy4offset.bp_hops - (char*)&dummy4offset;
  bootp_msg_slotOffsets [4] = (char*)&dummy4offset.bp_xid - (char*)&dummy4offset;
  bootp_msg_slotOffsets [5] = (char*)&dummy4offset.bp_secs - (char*)&dummy4offset;
  bootp_msg_slotOffsets [6] = (char*)&dummy4offset.bp_unused - (char*)&dummy4offset;
  bootp_msg_slotOffsets [7] = (char*)&dummy4offset.bp_ciaddr - (char*)&dummy4offset;
  bootp_msg_slotOffsets [8] = (char*)&dummy4offset.bp_yiaddr - (char*)&dummy4offset;
  bootp_msg_slotOffsets [9] = (char*)&dummy4offset.bp_siaddr - (char*)&dummy4offset;
  bootp_msg_slotOffsets [10] = (char*)&dummy4offset.bp_giaddr - (char*)&dummy4offset;
  bootp_msg_slotOffsets [11] = (char*)&dummy4offset.bp_chaddr - (char*)&dummy4offset;
  bootp_msg_slotOffsets [12] = (char*)&dummy4offset.bp_sname - (char*)&dummy4offset;
  bootp_msg_slotOffsets [13] = (char*)&dummy4offset.bp_file - (char*)&dummy4offset;
  bootp_msg_slotOffsets [14] = (char*)&dummy4offset.bp_vend - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&bootp_msg_struct,&bootp_msg_type,&bootp_msg_ptr );
 };
 {  // Compute Struct_VxWorks_4 structure offset
  struct Struct_VxWorks_4 dummy4offset;
  Struct_VxWorks_4_slotOffsets [0] = (char*)&dummy4offset.enableRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [1] = (char*)&dummy4offset.disableRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [2] = (char*)&dummy4offset.lockRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [3] = (char*)&dummy4offset.unlockRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [4] = (char*)&dummy4offset.flushRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [5] = (char*)&dummy4offset.invalidateRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [6] = (char*)&dummy4offset.clearRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [7] = (char*)&dummy4offset.textUpdateRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [8] = (char*)&dummy4offset.pipeFlushRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [9] = (char*)&dummy4offset.dmaMallocRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [10] = (char*)&dummy4offset.dmaFreeRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [11] = (char*)&dummy4offset.dmaVirtToPhysRtn - (char*)&dummy4offset;
  Struct_VxWorks_4_slotOffsets [12] = (char*)&dummy4offset.dmaPhysToVirtRtn - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_4_struct,&Struct_VxWorks_4_type,&Struct_VxWorks_4_ptr );
 };
 {  // Compute Struct_VxWorks_5 structure offset
  struct Struct_VxWorks_5 dummy4offset;
  Struct_VxWorks_5_slotOffsets [0] = (char*)&dummy4offset.flushRtn - (char*)&dummy4offset;
  Struct_VxWorks_5_slotOffsets [1] = (char*)&dummy4offset.invalidateRtn - (char*)&dummy4offset;
  Struct_VxWorks_5_slotOffsets [2] = (char*)&dummy4offset.virtToPhysRtn - (char*)&dummy4offset;
  Struct_VxWorks_5_slotOffsets [3] = (char*)&dummy4offset.physToVirtRtn - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_5_struct,&Struct_VxWorks_5_type,&Struct_VxWorks_5_ptr );
 };
 {  // Compute dirent structure offset
  struct dirent dummy4offset;
  dirent_slotOffsets [0] = (char*)&dummy4offset.d_name - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&dirent_struct,&dirent_type,&dirent_ptr );
 };
 {  // Compute slnode structure offset
  struct slnode dummy4offset;
  slnode_slotOffsets [0] = (char*)&dummy4offset.next - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&slnode_struct,&slnode_type,&slnode_ptr );
 };
 {  // Compute Struct_VxWorks_6 structure offset
  struct Struct_VxWorks_6 dummy4offset;
  Struct_VxWorks_6_slotOffsets [0] = (char*)&dummy4offset.node - (char*)&dummy4offset;
  Struct_VxWorks_6_slotOffsets [1] = (char*)&dummy4offset.key - (char*)&dummy4offset;
  Struct_VxWorks_6_slotOffsets [2] = (char*)&dummy4offset.data - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_6_struct,&Struct_VxWorks_6_type,&Struct_VxWorks_6_ptr );
 };
 {  // Compute Struct_VxWorks_7 structure offset
  struct Struct_VxWorks_7 dummy4offset;
  Struct_VxWorks_7_slotOffsets [0] = (char*)&dummy4offset.node - (char*)&dummy4offset;
  Struct_VxWorks_7_slotOffsets [1] = (char*)&dummy4offset.string - (char*)&dummy4offset;
  Struct_VxWorks_7_slotOffsets [2] = (char*)&dummy4offset.data - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_7_struct,&Struct_VxWorks_7_type,&Struct_VxWorks_7_ptr );
 };
 {  // Compute dlnode structure offset
  struct dlnode dummy4offset;
  dlnode_slotOffsets [0] = (char*)&dummy4offset.next - (char*)&dummy4offset;
  dlnode_slotOffsets [1] = (char*)&dummy4offset.previous - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&dlnode_struct,&dlnode_type,&dlnode_ptr );
 };
 {  // Compute Struct_VxWorks_8 structure offset
  struct Struct_VxWorks_8 dummy4offset;
  Struct_VxWorks_8_slotOffsets [0] = (char*)&dummy4offset.node - (char*)&dummy4offset;
  Struct_VxWorks_8_slotOffsets [1] = (char*)&dummy4offset.drvNum - (char*)&dummy4offset;
  Struct_VxWorks_8_slotOffsets [2] = (char*)&dummy4offset.name - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_8_struct,&Struct_VxWorks_8_type,&Struct_VxWorks_8_ptr );
 };
 {  // Compute Struct_VxWorks_9 structure offset
  struct Struct_VxWorks_9 dummy4offset;
  Struct_VxWorks_9_slotOffsets [0] = (char*)&dummy4offset.dospt_status - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [1] = (char*)&dummy4offset.dospt_startHead - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [2] = (char*)&dummy4offset.dospt_startSec - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [3] = (char*)&dummy4offset.dospt_type - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [4] = (char*)&dummy4offset.dospt_endHead - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [5] = (char*)&dummy4offset.dospt_endSec - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [6] = (char*)&dummy4offset.dospt_absSec - (char*)&dummy4offset;
  Struct_VxWorks_9_slotOffsets [7] = (char*)&dummy4offset.dospt_nSectors - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_9_struct,&Struct_VxWorks_9_type,&Struct_VxWorks_9_ptr );
 };
 {  // Compute Struct_VxWorks_10 structure offset
  struct Struct_VxWorks_10 dummy4offset;
  Struct_VxWorks_10_slotOffsets [0] = (char*)&dummy4offset.dosdde_name - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [1] = (char*)&dummy4offset.dosdde_ext - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [2] = (char*)&dummy4offset.dosdde_attrib - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [3] = (char*)&dummy4offset.dosdde_reserved - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [4] = (char*)&dummy4offset.dosdde_time - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [5] = (char*)&dummy4offset.dosdde_date - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [6] = (char*)&dummy4offset.dosdde_cluster - (char*)&dummy4offset;
  Struct_VxWorks_10_slotOffsets [7] = (char*)&dummy4offset.dosdde_size - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_10_struct,&Struct_VxWorks_10_type,&Struct_VxWorks_10_ptr );
 };
 {  // Compute Struct_VxWorks_11 structure offset
  struct Struct_VxWorks_11 dummy4offset;
  Struct_VxWorks_11_slotOffsets [0] = (char*)&dummy4offset.dosdee_name - (char*)&dummy4offset;
  Struct_VxWorks_11_slotOffsets [1] = (char*)&dummy4offset.dosdee_reserved - (char*)&dummy4offset;
  Struct_VxWorks_11_slotOffsets [2] = (char*)&dummy4offset.dosdee_attrib - (char*)&dummy4offset;
  Struct_VxWorks_11_slotOffsets [3] = (char*)&dummy4offset.dosdee_time - (char*)&dummy4offset;
  Struct_VxWorks_11_slotOffsets [4] = (char*)&dummy4offset.dosdee_date - (char*)&dummy4offset;
  Struct_VxWorks_11_slotOffsets [5] = (char*)&dummy4offset.dosdee_cluster - (char*)&dummy4offset;
  Struct_VxWorks_11_slotOffsets [6] = (char*)&dummy4offset.dosdee_size - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_11_struct,&Struct_VxWorks_11_type,&Struct_VxWorks_11_ptr );
 };
 {  // Compute Struct_VxWorks_12 structure offset
  struct Struct_VxWorks_12 dummy4offset;
  Struct_VxWorks_12_slotOffsets [0] = (char*)&dummy4offset.dosvc_mediaByte - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [1] = (char*)&dummy4offset.dosvc_secPerClust - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [2] = (char*)&dummy4offset.dosvc_nResrvd - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [3] = (char*)&dummy4offset.dosvc_nFats - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [4] = (char*)&dummy4offset.dosvc_secPerFat - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [5] = (char*)&dummy4offset.dosvc_maxRootEnts - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [6] = (char*)&dummy4offset.dosvc_nHidden - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [7] = (char*)&dummy4offset.dosvc_options - (char*)&dummy4offset;
  Struct_VxWorks_12_slotOffsets [8] = (char*)&dummy4offset.dosvc_reserved - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_12_struct,&Struct_VxWorks_12_type,&Struct_VxWorks_12_ptr );
 };
 {  // Compute Struct_VxWorks_13 structure offset
  struct Struct_VxWorks_13 dummy4offset;
  Struct_VxWorks_13_slotOffsets [0] = (char*)&dummy4offset.dosvd_devHdr - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [1] = (char*)&dummy4offset.dosvd_status - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [2] = (char*)&dummy4offset.dosvd_sysId - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [3] = (char*)&dummy4offset.dosvd_semId - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [4] = (char*)&dummy4offset.dosvd_pBlkDev - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [5] = (char*)&dummy4offset.dosvd_mediaByte - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [6] = (char*)&dummy4offset.dosvd_secPerClust - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [7] = (char*)&dummy4offset.dosvd_bytesPerClust - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [8] = (char*)&dummy4offset.dosvd_nFats - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [9] = (char*)&dummy4offset.dosvd_secPerFat - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [10] = (char*)&dummy4offset.dosvd_nFatEnts - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [11] = (char*)&dummy4offset.dosvd_fat12Bit - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [12] = (char*)&dummy4offset.dosvd_fatModified - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [13] = (char*)&dummy4offset.dosvd_pFatBuf - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [14] = (char*)&dummy4offset.dosvd_fatEntFreeCnt - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [15] = (char*)&dummy4offset.dosvd_maxRootEnts - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [16] = (char*)&dummy4offset.dosvd_nRootEnts - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [17] = (char*)&dummy4offset.dosvd_rootSec - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [18] = (char*)&dummy4offset.dosvd_pRoot - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [19] = (char*)&dummy4offset.dosvd_nResrvdSecs - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [20] = (char*)&dummy4offset.dosvd_nHiddenSecs - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [21] = (char*)&dummy4offset.dosvd_dataSec - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [22] = (char*)&dummy4offset.dosvd_driveNum - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [23] = (char*)&dummy4offset.dosvd_bootSigRec - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [24] = (char*)&dummy4offset.dosvd_volId - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [25] = (char*)&dummy4offset.dosvd_volLabel - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [26] = (char*)&dummy4offset.dosvd_state - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [27] = (char*)&dummy4offset.dosvd_retry - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [28] = (char*)&dummy4offset.dosvd_options - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [29] = (char*)&dummy4offset.dosvd_pFatModTbl - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [30] = (char*)&dummy4offset.dosvd_hashTbl - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [31] = (char*)&dummy4offset.dosvd_uid - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [32] = (char*)&dummy4offset.dosvd_gid - (char*)&dummy4offset;
  Struct_VxWorks_13_slotOffsets [33] = (char*)&dummy4offset.dosvd_mode - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_13_struct,&Struct_VxWorks_13_type,&Struct_VxWorks_13_ptr );
 };
 {  // Compute Struct_VxWorks_14 structure offset
  struct Struct_VxWorks_14 dummy4offset;
  Struct_VxWorks_14_slotOffsets [0] = (char*)&dummy4offset.dosdt_year - (char*)&dummy4offset;
  Struct_VxWorks_14_slotOffsets [1] = (char*)&dummy4offset.dosdt_month - (char*)&dummy4offset;
  Struct_VxWorks_14_slotOffsets [2] = (char*)&dummy4offset.dosdt_day - (char*)&dummy4offset;
  Struct_VxWorks_14_slotOffsets [3] = (char*)&dummy4offset.dosdt_hour - (char*)&dummy4offset;
  Struct_VxWorks_14_slotOffsets [4] = (char*)&dummy4offset.dosdt_minute - (char*)&dummy4offset;
  Struct_VxWorks_14_slotOffsets [5] = (char*)&dummy4offset.dosdt_second - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_14_struct,&Struct_VxWorks_14_type,&Struct_VxWorks_14_ptr );
 };
 {  // Compute buffers structure offset
  struct buffers dummy4offset;
  buffers_slotOffsets [0] = (char*)&dummy4offset.bufferIndexInUse - (char*)&dummy4offset;
  buffers_slotOffsets [1] = (char*)&dummy4offset.bufferInUse - (char*)&dummy4offset;
  buffers_slotOffsets [2] = (char*)&dummy4offset.bufferInReserve - (char*)&dummy4offset;
  buffers_slotOffsets [3] = (char*)&dummy4offset.bufferIndexInReserve - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&buffers_struct,&buffers_type,&buffers_ptr );
 };
 {  // Compute excfaultTab structure offset
  struct excfaultTab dummy4offset;
  excfaultTab_slotOffsets [0] = (char*)&dummy4offset.faultType - (char*)&dummy4offset;
  excfaultTab_slotOffsets [1] = (char*)&dummy4offset.subtype - (char*)&dummy4offset;
  excfaultTab_slotOffsets [2] = (char*)&dummy4offset.signal - (char*)&dummy4offset;
  excfaultTab_slotOffsets [3] = (char*)&dummy4offset.code - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&excfaultTab_struct,&excfaultTab_type,&excfaultTab_ptr );
 };
 {  // Compute Struct_VxWorks_15 structure offset
  struct Struct_VxWorks_15 dummy4offset;
  Struct_VxWorks_15_slotOffsets [0] = (char*)&dummy4offset.addrText - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [1] = (char*)&dummy4offset.addrData - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [2] = (char*)&dummy4offset.addrBss - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [3] = (char*)&dummy4offset.sizeText - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [4] = (char*)&dummy4offset.sizeProtectedText - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [5] = (char*)&dummy4offset.sizeData - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [6] = (char*)&dummy4offset.sizeBss - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [7] = (char*)&dummy4offset.flagsText - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [8] = (char*)&dummy4offset.flagsData - (char*)&dummy4offset;
  Struct_VxWorks_15_slotOffsets [9] = (char*)&dummy4offset.flagsBss - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_15_struct,&Struct_VxWorks_15_type,&Struct_VxWorks_15_ptr );
 };
 {  // Compute Struct_VxWorks_16 structure offset
  struct Struct_VxWorks_16 dummy4offset;
  Struct_VxWorks_16_slotOffsets [0] = (char*)&dummy4offset.numBytesFree - (char*)&dummy4offset;
  Struct_VxWorks_16_slotOffsets [1] = (char*)&dummy4offset.numBlocksFree - (char*)&dummy4offset;
  Struct_VxWorks_16_slotOffsets [2] = (char*)&dummy4offset.maxBlockSizeFree - (char*)&dummy4offset;
  Struct_VxWorks_16_slotOffsets [3] = (char*)&dummy4offset.numBytesAlloc - (char*)&dummy4offset;
  Struct_VxWorks_16_slotOffsets [4] = (char*)&dummy4offset.numBlocksAlloc - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_16_struct,&Struct_VxWorks_16_type,&Struct_VxWorks_16_ptr );
 };
 {  // Compute Struct_VxWorks_17 structure offset
  struct Struct_VxWorks_17 dummy4offset;
  Struct_VxWorks_17_slotOffsets [0] = (char*)&dummy4offset.segmentNode - (char*)&dummy4offset;
  Struct_VxWorks_17_slotOffsets [1] = (char*)&dummy4offset.address - (char*)&dummy4offset;
  Struct_VxWorks_17_slotOffsets [2] = (char*)&dummy4offset.size - (char*)&dummy4offset;
  Struct_VxWorks_17_slotOffsets [3] = (char*)&dummy4offset.type - (char*)&dummy4offset;
  Struct_VxWorks_17_slotOffsets [4] = (char*)&dummy4offset.flags - (char*)&dummy4offset;
  Struct_VxWorks_17_slotOffsets [5] = (char*)&dummy4offset.checksum - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_17_struct,&Struct_VxWorks_17_type,&Struct_VxWorks_17_ptr );
 };
 {  // Compute Struct_VxWorks_18 structure offset
  struct Struct_VxWorks_18 dummy4offset;
  Struct_VxWorks_18_slotOffsets [0] = (char*)&dummy4offset.textAddr - (char*)&dummy4offset;
  Struct_VxWorks_18_slotOffsets [1] = (char*)&dummy4offset.dataAddr - (char*)&dummy4offset;
  Struct_VxWorks_18_slotOffsets [2] = (char*)&dummy4offset.bssAddr - (char*)&dummy4offset;
  Struct_VxWorks_18_slotOffsets [3] = (char*)&dummy4offset.textSize - (char*)&dummy4offset;
  Struct_VxWorks_18_slotOffsets [4] = (char*)&dummy4offset.dataSize - (char*)&dummy4offset;
  Struct_VxWorks_18_slotOffsets [5] = (char*)&dummy4offset.bssSize - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_18_struct,&Struct_VxWorks_18_type,&Struct_VxWorks_18_ptr );
 };
 {  // Compute Struct_VxWorks_19 structure offset
  struct Struct_VxWorks_19 dummy4offset;
  Struct_VxWorks_19_slotOffsets [0] = (char*)&dummy4offset.name - (char*)&dummy4offset;
  Struct_VxWorks_19_slotOffsets [1] = (char*)&dummy4offset.format - (char*)&dummy4offset;
  Struct_VxWorks_19_slotOffsets [2] = (char*)&dummy4offset.group - (char*)&dummy4offset;
  Struct_VxWorks_19_slotOffsets [3] = (char*)&dummy4offset.segInfo - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_19_struct,&Struct_VxWorks_19_type,&Struct_VxWorks_19_ptr );
 };
 {  // Compute Struct_VxWorks_20 structure offset
  struct Struct_VxWorks_20 dummy4offset;
  Struct_VxWorks_20_slotOffsets [0] = (char*)&dummy4offset.next - (char*)&dummy4offset;
  Struct_VxWorks_20_slotOffsets [1] = (char*)&dummy4offset.prev - (char*)&dummy4offset;
  Struct_VxWorks_20_slotOffsets [2] = (char*)&dummy4offset.dirName - (char*)&dummy4offset;
  Struct_VxWorks_20_slotOffsets [3] = (char*)&dummy4offset.dirFd - (char*)&dummy4offset;
  Struct_VxWorks_20_slotOffsets [4] = (char*)&dummy4offset.fsId - (char*)&dummy4offset;
  Struct_VxWorks_20_slotOffsets [5] = (char*)&dummy4offset.volumeId - (char*)&dummy4offset;
  Struct_VxWorks_20_slotOffsets [6] = (char*)&dummy4offset.readOnly - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_20_struct,&Struct_VxWorks_20_type,&Struct_VxWorks_20_ptr );
 };
 {  // Compute Struct_VxWorks_21 structure offset
  struct Struct_VxWorks_21 dummy4offset;
  Struct_VxWorks_21_slotOffsets [0] = (char*)&dummy4offset.numMsgs - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [1] = (char*)&dummy4offset.numTasks - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [2] = (char*)&dummy4offset.sendTimeouts - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [3] = (char*)&dummy4offset.recvTimeouts - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [4] = (char*)&dummy4offset.options - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [5] = (char*)&dummy4offset.maxMsgs - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [6] = (char*)&dummy4offset.maxMsgLength - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [7] = (char*)&dummy4offset.taskIdListMax - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [8] = (char*)&dummy4offset.taskIdList - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [9] = (char*)&dummy4offset.msgListMax - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [10] = (char*)&dummy4offset.msgPtrList - (char*)&dummy4offset;
  Struct_VxWorks_21_slotOffsets [11] = (char*)&dummy4offset.msgLenList - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_21_struct,&Struct_VxWorks_21_type,&Struct_VxWorks_21_ptr );
 };
 {  // Compute Struct_VxWorks_22 structure offset
  struct Struct_VxWorks_22 dummy4offset;
  Struct_VxWorks_22_slotOffsets [0] = (char*)&dummy4offset.volumeId - (char*)&dummy4offset;
  Struct_VxWorks_22_slotOffsets [1] = (char*)&dummy4offset.fsId - (char*)&dummy4offset;
  Struct_VxWorks_22_slotOffsets [2] = (char*)&dummy4offset.inode - (char*)&dummy4offset;
  Struct_VxWorks_22_slotOffsets [3] = (char*)&dummy4offset.reserved - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_22_struct,&Struct_VxWorks_22_type,&Struct_VxWorks_22_ptr );
 };
 {  // Compute Struct_VxWorks_23 structure offset
  struct Struct_VxWorks_23 dummy4offset;
  Struct_VxWorks_23_slotOffsets [0] = (char*)&dummy4offset.nullCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [1] = (char*)&dummy4offset.getattrCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [2] = (char*)&dummy4offset.setattrCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [3] = (char*)&dummy4offset.rootCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [4] = (char*)&dummy4offset.lookupCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [5] = (char*)&dummy4offset.readlinkCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [6] = (char*)&dummy4offset.readCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [7] = (char*)&dummy4offset.writecacheCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [8] = (char*)&dummy4offset.writeCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [9] = (char*)&dummy4offset.createCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [10] = (char*)&dummy4offset.removeCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [11] = (char*)&dummy4offset.renameCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [12] = (char*)&dummy4offset.linkCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [13] = (char*)&dummy4offset.symlinkCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [14] = (char*)&dummy4offset.mkdirCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [15] = (char*)&dummy4offset.rmdirCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [16] = (char*)&dummy4offset.readdirCalls - (char*)&dummy4offset;
  Struct_VxWorks_23_slotOffsets [17] = (char*)&dummy4offset.statfsCalls - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_23_struct,&Struct_VxWorks_23_type,&Struct_VxWorks_23_ptr );
 };
 {  // Compute Struct_VxWorks_24 structure offset
  struct Struct_VxWorks_24 dummy4offset;
  Struct_VxWorks_24_slotOffsets [0] = (char*)&dummy4offset.hostName - (char*)&dummy4offset;
  Struct_VxWorks_24_slotOffsets [1] = (char*)&dummy4offset.remFileSys - (char*)&dummy4offset;
  Struct_VxWorks_24_slotOffsets [2] = (char*)&dummy4offset.locFileSys - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_24_struct,&Struct_VxWorks_24_type,&Struct_VxWorks_24_ptr );
 };
 {  // Compute Struct_VxWorks_25 structure offset
  struct Struct_VxWorks_25 dummy4offset;
  Struct_VxWorks_25_slotOffsets [0] = (char*)&dummy4offset.ifName - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [1] = (char*)&dummy4offset.attachRtn - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [2] = (char*)&dummy4offset.arg1 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [3] = (char*)&dummy4offset.arg2 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [4] = (char*)&dummy4offset.arg3 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [5] = (char*)&dummy4offset.arg4 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [6] = (char*)&dummy4offset.arg5 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [7] = (char*)&dummy4offset.arg6 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [8] = (char*)&dummy4offset.arg7 - (char*)&dummy4offset;
  Struct_VxWorks_25_slotOffsets [9] = (char*)&dummy4offset.arg8 - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_25_struct,&Struct_VxWorks_25_type,&Struct_VxWorks_25_ptr );
 };
 {  // Compute Struct_VxWorks_26 structure offset
  struct Struct_VxWorks_26 dummy4offset;
  Struct_VxWorks_26_slotOffsets [0] = (char*)&dummy4offset.td_id - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [1] = (char*)&dummy4offset.td_name - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [2] = (char*)&dummy4offset.td_priority - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [3] = (char*)&dummy4offset.td_status - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [4] = (char*)&dummy4offset.td_options - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [5] = (char*)&dummy4offset.td_entry - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [6] = (char*)&dummy4offset.td_sp - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [7] = (char*)&dummy4offset.td_pStackBase - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [8] = (char*)&dummy4offset.td_pStackLimit - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [9] = (char*)&dummy4offset.td_pStackEnd - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [10] = (char*)&dummy4offset.td_stackSize - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [11] = (char*)&dummy4offset.td_stackCurrent - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [12] = (char*)&dummy4offset.td_stackHigh - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [13] = (char*)&dummy4offset.td_stackMargin - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [14] = (char*)&dummy4offset.td_errorStatus - (char*)&dummy4offset;
  Struct_VxWorks_26_slotOffsets [15] = (char*)&dummy4offset.td_delay - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_26_struct,&Struct_VxWorks_26_type,&Struct_VxWorks_26_ptr );
 };
 {  // Compute taskVar structure offset
  struct taskVar dummy4offset;
  taskVar_slotOffsets [0] = (char*)&dummy4offset.next - (char*)&dummy4offset;
  taskVar_slotOffsets [1] = (char*)&dummy4offset.address - (char*)&dummy4offset;
  taskVar_slotOffsets [2] = (char*)&dummy4offset.value - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&taskVar_struct,&taskVar_type,&taskVar_ptr );
 };
 {  // Compute Struct_VxWorks_27 structure offset
  struct Struct_VxWorks_27 dummy4offset;
  Struct_VxWorks_27_slotOffsets [0] = (char*)&dummy4offset.lower - (char*)&dummy4offset;
  Struct_VxWorks_27_slotOffsets [1] = (char*)&dummy4offset.upper - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Struct_VxWorks_27_struct,&Struct_VxWorks_27_type,&Struct_VxWorks_27_ptr );
 };

 {  // Compute sigval Unions offset
  union sigval dummy4offset;
  sigval_slotOffsets [0] = (char*)&dummy4offset.sival_int - (char*)&dummy4offset;
  sigval_slotOffsets [1] = (char*)&dummy4offset.sival_ptr - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&sigval_union,&sigval_type,&sigval_ptr );
 };

 {  // Compute Union_VxWorks_0 Unions offset
  union Union_VxWorks_0 dummy4offset;
  Union_VxWorks_0_slotOffsets [0] = (char*)&dummy4offset.handler - (char*)&dummy4offset;
  Union_VxWorks_0_slotOffsets [1] = (char*)&dummy4offset.action - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Union_VxWorks_0_union,&Union_VxWorks_0_type,&Union_VxWorks_0_ptr );
 };

 {  // Compute Union_VxWorks_1 Unions offset
  union Union_VxWorks_1 dummy4offset;
  Union_VxWorks_1_slotOffsets [0] = (char*)&dummy4offset.mountproc_mnt_1_arg - (char*)&dummy4offset;
  Union_VxWorks_1_slotOffsets [1] = (char*)&dummy4offset.mountproc_umnt_1_arg - (char*)&dummy4offset;
  jWrapTypeRegister (&module,&Union_VxWorks_1_union,&Union_VxWorks_1_type,&Union_VxWorks_1_ptr );
 };
 
 /* *** Type Alias Section *** */
 jWrapTypeAlias (&module,"void_Ptr" ,"clockid_t");
 jWrapTypeAlias (&module,"void_Ptr" ,"timer_t");
 jWrapTypeAlias (&module,"void_Ptr" ,"MODULE_ID");
 jWrapTypeAlias (&module,"void_Ptr" ,"SYMTAB_ID");
 jWrapTypeAlias (&module,"char_Ptr" ,"dirpath");
 jWrapTypeAlias (&module,"Struct_VxWorks_0" ,"div_t");
 jWrapTypeAlias (&module,"void_Ptr" ,"vx_off_t");
 jWrapTypeAlias (&module,"void_Ptr" ,"vx_SigVect");
 jWrapTypeAlias (&module,"void_Ptr" ,"vx_AIO_SYS");
 jWrapTypeAlias (&module,"long" ,"sigset_t");
 jWrapTypeAlias (&module,"char" ,"sig_atomic_t");
 jWrapTypeAlias (&module,"siginfo" ,"siginfo_t");
 jWrapTypeAlias (&module,"node" ,"NODE");
 jWrapTypeAlias (&module,"Struct_VxWorks_1" ,"LIST");
 jWrapTypeAlias (&module,"Struct_VxWorks_2" ,"BOOT_PARAMS");
 jWrapTypeAlias (&module,"hostname_struct" ,"HOSTNAME");
 jWrapTypeAlias (&module,"Struct_VxWorks_3" ,"HOSTENTRY");
 jWrapTypeAlias (&module,"bootp_msg" ,"BOOTP_MSG");
 jWrapTypeAlias (&module,"Enum_VxWorks_0" ,"CACHE_TYPE");
 jWrapTypeAlias (&module,"UINT" ,"CACHE_MODE");
 jWrapTypeAlias (&module,"Struct_VxWorks_4" ,"CACHE_LIB");
 jWrapTypeAlias (&module,"Struct_VxWorks_5" ,"CACHE_FUNCS");
 jWrapTypeAlias (&module,"short" ,"event_t");
 jWrapTypeAlias (&module,"void_Ptr" ,"INSTR");
 jWrapTypeAlias (&module,"void_Ptr" ,"DIR");
 jWrapTypeAlias (&module,"slnode" ,"SL_NODE");
 jWrapTypeAlias (&module,"void_Ptr" ,"SL_LIST");
 jWrapTypeAlias (&module,"void_Ptr" ,"HASH_TBL");
 jWrapTypeAlias (&module,"SL_NODE" ,"HASH_NODE");
 jWrapTypeAlias (&module,"HASH_TBL_Ptr" ,"HASH_ID");
 jWrapTypeAlias (&module,"Struct_VxWorks_6" ,"H_NODE_INT");
 jWrapTypeAlias (&module,"Struct_VxWorks_7" ,"H_NODE_STRING");
 jWrapTypeAlias (&module,"dlnode" ,"DL_NODE");
 jWrapTypeAlias (&module,"void_Ptr" ,"DL_LIST");
 jWrapTypeAlias (&module,"DL_LIST" ,"Q_FIFO_HEAD");
 jWrapTypeAlias (&module,"DL_NODE" ,"Q_FIFO_NODE");
 jWrapTypeAlias (&module,"Struct_VxWorks_8" ,"DEV_HDR");
 jWrapTypeAlias (&module,"Enum_VxWorks_1" ,"SEM_B_STATE");
 jWrapTypeAlias (&module,"SEM_ID_Ptr" ,"semaphore");
 jWrapTypeAlias (&module,"void_Ptr" ,"BLK_DEV");
 jWrapTypeAlias (&module,"Struct_VxWorks_9" ,"DOS_PART_TBL");
 jWrapTypeAlias (&module,"Struct_VxWorks_10" ,"DOS_DISK_DIR_ENT");
 jWrapTypeAlias (&module,"Struct_VxWorks_11" ,"DOS_DISK_EDIR_ENT");
 jWrapTypeAlias (&module,"void_Ptr" ,"DOS_DIR_ENT");
 jWrapTypeAlias (&module,"Struct_VxWorks_12" ,"DOS_VOL_CONFIG");
 jWrapTypeAlias (&module,"Struct_VxWorks_13" ,"DOS_VOL_DESC");
 jWrapTypeAlias (&module,"Struct_VxWorks_14" ,"DOS_DATE_TIME");
 jWrapTypeAlias (&module,"excfaultTab" ,"EXC_FAULT_TAB");
 jWrapTypeAlias (&module,"Struct_VxWorks_15" ,"SEG_INFO");
 jWrapTypeAlias (&module,"PART_ID_Ptr" ,"mem_part");
 jWrapTypeAlias (&module,"Struct_VxWorks_16" ,"MEM_PART_STATS");
 jWrapTypeAlias (&module,"Struct_VxWorks_17" ,"SEGMENT");
 jWrapTypeAlias (&module,"SEGMENT_Ptr" ,"SEGMENT_ID");
 jWrapTypeAlias (&module,"Struct_VxWorks_18" ,"MODULE_SEG_INFO");
 jWrapTypeAlias (&module,"Struct_VxWorks_19" ,"MODULE_INFO");
 jWrapTypeAlias (&module,"Struct_VxWorks_20" ,"NFS_EXPORT_ENTRY");
 jWrapTypeAlias (&module,"Union_VxWorks_1" ,"MOUNTD_ARGUMENT");
 jWrapTypeAlias (&module,"void_Ptr" ,"mqd_t");
 jWrapTypeAlias (&module,"void_Ptr" ,"MSG_Q_ID");
 jWrapTypeAlias (&module,"Struct_VxWorks_21" ,"MSG_Q_INFO");
 jWrapTypeAlias (&module,"void_Ptr" ,"SM_MSG_Q_ID");
 jWrapTypeAlias (&module,"Struct_VxWorks_22" ,"NFS_FILE_HANDLE");
 jWrapTypeAlias (&module,"Struct_VxWorks_23" ,"NFS_SERVER_STATUS");
 jWrapTypeAlias (&module,"Struct_VxWorks_24" ,"NFS_DEV_INFO");
 jWrapTypeAlias (&module,"void_Ptr" ,"RING_ID");
 jWrapTypeAlias (&module,"void_Ptr" ,"SM_SEM_ID");
 jWrapTypeAlias (&module,"void_Ptr" ,"SM_PART_ID");
 jWrapTypeAlias (&module,"signed" ,"char");
 jWrapTypeAlias (&module,"void_Ptr" ,"SYMBOL");
 jWrapTypeAlias (&module,"Struct_VxWorks_25" ,"NETIF");
 jWrapTypeAlias (&module,"void_Ptr" ,"WIND_TCB_ID");
 jWrapTypeAlias (&module,"Struct_VxWorks_26" ,"TASK_DESC");
 jWrapTypeAlias (&module,"taskVar" ,"TASK_VAR");
 jWrapTypeAlias (&module,"Struct_VxWorks_27" ,"TICK");
 jWrapTypeAlias (&module,"void_Ptr" ,"WDOG_ID");

 /* --- Used Type Section --- */

 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [0],"Define_VxWorks",sizeof(Define_VxWorks));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [1],"CACHE_LIB",sizeof(CACHE_LIB));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [2],"CACHE_FUNCS",sizeof(CACHE_FUNCS));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [3],"void_Ptr",sizeof(void *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [4],"CACHE_MODE",sizeof(CACHE_MODE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [5],"int",sizeof(int));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [6],"char",sizeof(char));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [7],"Struct_VxWorks_0",sizeof(struct Struct_VxWorks_0));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [8],"aiocb",sizeof(struct aiocb));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [9],"vx_off_t",sizeof(vx_off_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [10],"size_t",sizeof(size_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [11],"vx_SigVect",sizeof(vx_SigVect));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [12],"vx_AIO_SYS",sizeof(vx_AIO_SYS));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [13],"utimbuf",sizeof(struct utimbuf));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [14],"long",sizeof(long));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [15],"tm",sizeof(struct tm));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [16],"vx_timespec",sizeof(struct vx_timespec));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [17],"itimerspec",sizeof(struct itimerspec));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [18],"sigevent",sizeof(struct sigevent));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [19],"sigval",sizeof(union sigval));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [20],"siginfo",sizeof(struct siginfo));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [21],"sigaction",sizeof(struct sigaction));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [22],"Union_VxWorks_0",sizeof(union Union_VxWorks_0));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [23],"sigset_t",sizeof(sigset_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [24],"node",sizeof(struct node));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [25],"node_Ptr",sizeof(struct node*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [26],"Struct_VxWorks_1",sizeof(struct Struct_VxWorks_1));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [27],"NODE",sizeof(NODE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [28],"Struct_VxWorks_2",sizeof(struct Struct_VxWorks_2));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [29],"in_addr",sizeof(struct in_addr));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [30],"u_long",sizeof(u_long));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [31],"sockaddr_in",sizeof(struct sockaddr_in));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [32],"short",sizeof(short));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [33],"u_short",sizeof(u_short));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [34],"hostname_struct",sizeof(struct hostname_struct));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [35],"hostname_struct_Ptr",sizeof(struct hostname_struct*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [36],"char_Ptr",sizeof(char*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [37],"Struct_VxWorks_3",sizeof(struct Struct_VxWorks_3));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [38],"HOSTNAME",sizeof(HOSTNAME));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [39],"bootp_msg",sizeof(struct bootp_msg));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [40],"Struct_VxWorks_4",sizeof(struct Struct_VxWorks_4));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [41],"Struct_VxWorks_5",sizeof(struct Struct_VxWorks_5));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [42],"dirent",sizeof(struct dirent));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [43],"slnode",sizeof(struct slnode));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [44],"slnode_Ptr",sizeof(struct slnode*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [45],"Struct_VxWorks_6",sizeof(struct Struct_VxWorks_6));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [46],"HASH_NODE",sizeof(HASH_NODE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [47],"Struct_VxWorks_7",sizeof(struct Struct_VxWorks_7));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [48],"dlnode",sizeof(struct dlnode));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [49],"dlnode_Ptr",sizeof(struct dlnode*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [50],"Struct_VxWorks_8",sizeof(struct Struct_VxWorks_8));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [51],"DL_NODE",sizeof(DL_NODE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [52],"Struct_VxWorks_9",sizeof(struct Struct_VxWorks_9));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [53],"UINT8",sizeof(UINT8));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [54],"ULONG",sizeof(ULONG));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [55],"Struct_VxWorks_10",sizeof(struct Struct_VxWorks_10));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [56],"USHORT",sizeof(USHORT));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [57],"Struct_VxWorks_11",sizeof(struct Struct_VxWorks_11));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [58],"Struct_VxWorks_12",sizeof(struct Struct_VxWorks_12));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [59],"UINT16",sizeof(UINT16));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [60],"UINT",sizeof(UINT));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [61],"Struct_VxWorks_13",sizeof(struct Struct_VxWorks_13));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [62],"DEV_HDR",sizeof(DEV_HDR));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [63],"SEM_ID",sizeof(SEM_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [64],"UINT8_Ptr",sizeof(UINT8*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [65],"DOS_DIR_ENT_Ptr",sizeof(DOS_DIR_ENT*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [66],"HASH_ID",sizeof(HASH_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [67],"Struct_VxWorks_14",sizeof(struct Struct_VxWorks_14));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [68],"buffers",sizeof(struct buffers));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [69],"excfaultTab",sizeof(struct excfaultTab));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [70],"Struct_VxWorks_15",sizeof(struct Struct_VxWorks_15));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [71],"Struct_VxWorks_16",sizeof(struct Struct_VxWorks_16));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [72],"Struct_VxWorks_17",sizeof(struct Struct_VxWorks_17));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [73],"Struct_VxWorks_18",sizeof(struct Struct_VxWorks_18));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [74],"Struct_VxWorks_19",sizeof(struct Struct_VxWorks_19));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [75],"MODULE_SEG_INFO",sizeof(MODULE_SEG_INFO));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [76],"Struct_VxWorks_20",sizeof(struct Struct_VxWorks_20));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [77],"Struct_VxWorks_21",sizeof(struct Struct_VxWorks_21));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [78],"int_Ptr",sizeof(int*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [79],"Struct_VxWorks_22",sizeof(struct Struct_VxWorks_22));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [80],"INT8",sizeof(INT8));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [81],"Struct_VxWorks_23",sizeof(struct Struct_VxWorks_23));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [82],"Struct_VxWorks_24",sizeof(struct Struct_VxWorks_24));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [83],"Struct_VxWorks_25",sizeof(struct Struct_VxWorks_25));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [84],"Struct_VxWorks_26",sizeof(struct Struct_VxWorks_26));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [85],"taskVar",sizeof(struct taskVar));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [86],"taskVar_Ptr",sizeof(struct taskVar*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [87],"Struct_VxWorks_27",sizeof(struct Struct_VxWorks_27));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [88],"Union_VxWorks_1",sizeof(union Union_VxWorks_1));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [89],"Enum_VxWorks_0",sizeof(enum Enum_VxWorks_0));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [90],"Enum_VxWorks_1",sizeof(enum Enum_VxWorks_1));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [91],"utimbuf_Ptr",sizeof(struct utimbuf *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [92],"sigset_t_Ptr",sizeof(sigset_t *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [93],"sigaction_Ptr",sizeof(struct sigaction *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [94],"siginfo_Ptr",sizeof(struct siginfo *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [95],"vx_timespec_Ptr",sizeof(struct vx_timespec *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [96],"tm_Ptr",sizeof(struct tm *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [97],"long_Ptr",sizeof(long *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [98],"double",sizeof(double));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [99],"clockid_t",sizeof(clockid_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [100],"sigevent_Ptr",sizeof(struct sigevent *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [101],"timer_t_Ptr",sizeof(timer_t *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [102],"timer_t",sizeof(timer_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [103],"itimerspec_Ptr",sizeof(struct itimerspec *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [104],"aiocb_Ptr",sizeof(struct aiocb *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [105],"aiocb_Ptr_Ptr",sizeof(struct aiocb **));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [106],"agiocb_Ptr",sizeof(struct agiocb *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [107],"FILE_Ptr",sizeof(FILE *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [108],"fpos_t_Ptr",sizeof(fpos_t *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [109],"div_t",sizeof(div_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [110],"in_addr_Ptr",sizeof(struct in_addr *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [111],"u_char_Ptr",sizeof(u_char *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [112],"BOOT_PARAMS_Ptr",sizeof(BOOT_PARAMS *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [113],"u_int",sizeof(u_int));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [114],"BOOTP_MSG_Ptr",sizeof(BOOTP_MSG *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [115],"NODE_Ptr",sizeof(NODE*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [116],"LIST_Ptr",sizeof(LIST *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [117],"CACHE_TYPE",sizeof(CACHE_TYPE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [118],"CACHE_FUNCS_Ptr",sizeof(CACHE_FUNCS *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [119],"INSTR_Ptr",sizeof(INSTR *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [120],"event_t",sizeof(event_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [121],"DIR_Ptr",sizeof(DIR*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [122],"dirent_Ptr",sizeof(struct dirent*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [123],"DOS_VOL_DESC_Ptr",sizeof(DOS_VOL_DESC *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [124],"DOS_VOL_CONFIG_Ptr",sizeof(DOS_VOL_CONFIG *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [125],"BLK_DEV_Ptr",sizeof(BLK_DEV *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [126],"UINT_Ptr",sizeof(UINT *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [127],"SL_LIST_Ptr",sizeof(SL_LIST*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [128],"SL_NODE_Ptr",sizeof(SL_NODE*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [129],"H_NODE_INT_Ptr",sizeof(H_NODE_INT *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [130],"H_NODE_STRING_Ptr",sizeof(H_NODE_STRING *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [131],"HASH_NODE_Ptr",sizeof(HASH_NODE*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [132],"HASH_TBL_Ptr",sizeof(HASH_TBL *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [133],"DEV_HDR_Ptr",sizeof(DEV_HDR*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [134],"DL_LIST_Ptr",sizeof(DL_LIST*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [135],"DL_NODE_Ptr",sizeof(DL_NODE*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [136],"Q_FIFO_HEAD_Ptr",sizeof(Q_FIFO_HEAD*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [137],"Q_FIFO_NODE_Ptr",sizeof(Q_FIFO_NODE*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [138],"SEM_B_STATE",sizeof(SEM_B_STATE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [139],"ifnet_Ptr",sizeof(struct ifnet *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [140],"ether_header_Ptr",sizeof(struct ether_header *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [141],"VOIDFUNCPTR",sizeof(VOIDFUNCPTR));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [142],"void_Ptr_Ptr",sizeof(void **));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [143],"MODULE_ID",sizeof(MODULE_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [144],"SYMTAB_ID",sizeof(SYMTAB_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [145],"SEG_INFO_Ptr",sizeof(SEG_INFO *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [146],"PART_ID",sizeof(PART_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [147],"MEM_PART_STATS_Ptr",sizeof(MEM_PART_STATS *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [148],"SEGMENT_ID",sizeof(SEGMENT_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [149],"MODULE_ID_Ptr",sizeof(MODULE_ID *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [150],"MODULE_INFO_Ptr",sizeof(MODULE_INFO *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [151],"NFS_EXPORT_ENTRY_Ptr",sizeof(NFS_EXPORT_ENTRY*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [152],"mqd_t",sizeof(mqd_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [153],"mq_attr_Ptr",sizeof(struct mq_attr *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [154],"MSG_Q_ID",sizeof(MSG_Q_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [155],"MSG_Q_INFO_Ptr",sizeof(MSG_Q_INFO *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [156],"NFS_SERVER_STATUS_Ptr",sizeof(NFS_SERVER_STATUS *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [157],"NFS_FILE_HANDLE_Ptr",sizeof(NFS_FILE_HANDLE *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [158],"fattr_Ptr",sizeof(struct fattr *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [159],"NFS_DEV_INFO_Ptr",sizeof(NFS_DEV_INFO *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [160],"sockaddr_in_Ptr",sizeof(struct sockaddr_in *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [161],"RING_ID",sizeof(RING_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [162],"sockaddr_Ptr",sizeof(struct sockaddr *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [163],"timeval_Ptr",sizeof(struct timeval *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [164],"msghdr_Ptr",sizeof(struct msghdr *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [165],"caddr_t",sizeof(caddr_t));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [166],"SYMBOL_Ptr",sizeof(SYMBOL*));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [167],"SYM_TYPE",sizeof(SYM_TYPE));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [168],"SYMBOL_Ptr_Ptr",sizeof(SYMBOL **));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [169],"SYM_TYPE_Ptr",sizeof(SYM_TYPE *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [170],"WIND_TCB_ID",sizeof(WIND_TCB_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [171],"TASK_DESC_Ptr",sizeof(TASK_DESC *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [172],"TASK_VAR_Ptr",sizeof(TASK_VAR *));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [173],"WDOG_ID",sizeof(WDOG_ID));
 tornadoTypeCheck ((TORNADO_infos*)module.info, &usedType [174],"Tcl_Interp_Ptr",sizeof(Tcl_Interp *));

 /* --- Static Variable registration --- */

 // WARNING: [cacheLib] var not mapped on this version
 // WARNING: [cacheNullFuncs] var not mapped on this version
 // WARNING: [cacheDmaFuncs] var not mapped on this version
 // WARNING: [cacheUserFuncs] var not mapped on this version
 // WARNING: [cacheDmaMallocRtn] var not mapped on this version
 // WARNING: [cacheDmaFreeRtn] var not mapped on this version
 // WARNING: [cacheDataMode] var not mapped on this version
 // WARNING: [cacheDataEnabled] var not mapped on this version
 // WARNING: [cacheMmuAvailable] var not mapped on this version
 // WARNING: [SYM_TYPE] var not mapped on this version

 /* --- Functions sub-section --- */

 // register utime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.utime", jTcl_utime_0  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register raise C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.raise", jTcl_raise_1  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register kill C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.kill", jTcl_kill_2  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigemptyset C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigemptyset", jTcl_sigemptyset_3  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigfillset C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigfillset", jTcl_sigfillset_4  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigaddset C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigaddset", jTcl_sigaddset_5  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigdelset C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigdelset", jTcl_sigdelset_6  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigismember C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigismember", jTcl_sigismember_7  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigaction C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigaction", jTcl_sigaction_8  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigprocmask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigprocmask", jTcl_sigprocmask_9  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigpending C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigpending", jTcl_sigpending_10  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigsuspend C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigsuspend", jTcl_sigsuspend_11  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigwait C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigwait", jTcl_sigwait_12  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigwaitinfo C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigwaitinfo", jTcl_sigwaitinfo_13  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigtimedwait C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigtimedwait", jTcl_sigtimedwait_14  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sigqueue C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sigqueue", jTcl_sigqueue_15  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register _clocks_per_sec C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks._clocks_per_sec", jTcl__clocks_per_sec_16  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register asctime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.asctime", jTcl_asctime_17  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register clock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.clock", jTcl_clock_18  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ctime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ctime", jTcl_ctime_19  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register difftime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.difftime", jTcl_difftime_20  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register gmtime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.gmtime", jTcl_gmtime_21  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register localtime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.localtime", jTcl_localtime_22  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mktime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mktime", jTcl_mktime_23  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strftime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strftime", jTcl_strftime_24  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register time C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.time", jTcl_time_25  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register clock_gettime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.clock_gettime", jTcl_clock_gettime_26  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register clock_settime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.clock_settime", jTcl_clock_settime_27  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register clock_getres C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.clock_getres", jTcl_clock_getres_28  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_create C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_create", jTcl_timer_create_29  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_delete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_delete", jTcl_timer_delete_30  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_gettime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_gettime", jTcl_timer_gettime_31  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_settime C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_settime", jTcl_timer_settime_32  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_getoverrun C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_getoverrun", jTcl_timer_getoverrun_33  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_connect C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_connect", jTcl_timer_connect_34  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_cancel C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_cancel", jTcl_timer_cancel_35  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timer_show C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timer_show", jTcl_timer_show_36  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nanosleep C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nanosleep", jTcl_nanosleep_37  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aio_read C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aio_read", jTcl_aio_read_38  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aio_write C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aio_write", jTcl_aio_write_39  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lio_listio C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lio_listio", jTcl_lio_listio_40  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aio_error C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aio_error", jTcl_aio_error_41  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aio_return C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aio_return", jTcl_aio_return_42  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aio_cancel C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aio_cancel", jTcl_aio_cancel_43  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aio_suspend C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aio_suspend", jTcl_aio_suspend_44  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aioPxLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aioPxLibInit", jTcl_aioPxLibInit_45  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register aioShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.aioShow", jTcl_aioShow_46  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register clearerr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.clearerr", jTcl_clearerr_47  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fclose C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fclose", jTcl_fclose_48  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register feof C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.feof", jTcl_feof_49  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ferror C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ferror", jTcl_ferror_50  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fflush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fflush", jTcl_fflush_51  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fgetc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fgetc", jTcl_fgetc_52  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fgetpos C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fgetpos", jTcl_fgetpos_53  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fgets C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fgets", jTcl_fgets_54  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fopen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fopen", jTcl_fopen_55  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fputc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fputc", jTcl_fputc_56  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fputs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fputs", jTcl_fputs_57  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fread C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fread", jTcl_fread_58  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register freopen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.freopen", jTcl_freopen_59  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fseek C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fseek", jTcl_fseek_60  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fsetpos C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fsetpos", jTcl_fsetpos_61  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftell C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftell", jTcl_ftell_62  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fwrite C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fwrite", jTcl_fwrite_63  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register getc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.getc", jTcl_getc_64  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register getchar C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.getchar", jTcl_getchar_65  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register gets C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.gets", jTcl_gets_66  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register perror C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.perror", jTcl_perror_67  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register putc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.putc", jTcl_putc_68  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register putchar C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.putchar", jTcl_putchar_69  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register puts C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.puts", jTcl_puts_70  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register remove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.remove", jTcl_remove_71  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rename C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rename", jTcl_rename_72  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rewind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rewind", jTcl_rewind_73  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register setbuf C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.setbuf", jTcl_setbuf_74  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register setvbuf C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.setvbuf", jTcl_setvbuf_75  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tmpfile C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tmpfile", jTcl_tmpfile_76  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tmpnam C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tmpnam", jTcl_tmpnam_77  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ungetc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ungetc", jTcl_ungetc_78  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register vfprintf C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.vfprintf", jTcl_vfprintf_79  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register vprintf C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.vprintf", jTcl_vprintf_80  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register vsprintf C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.vsprintf", jTcl_vsprintf_81  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fdopen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fdopen", jTcl_fdopen_82  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fileno C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fileno", jTcl_fileno_83  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register abort C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.abort", jTcl_abort_84  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register abs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.abs", jTcl_abs_85  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register atexit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.atexit", jTcl_atexit_86  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register atof C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.atof", jTcl_atof_87  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register atoi C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.atoi", jTcl_atoi_88  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register atol C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.atol", jTcl_atol_89  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bsearch C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bsearch", jTcl_bsearch_90  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register div C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.div", jTcl_div_91  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register labs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.labs", jTcl_labs_92  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ldiv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ldiv", jTcl_ldiv_93  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mblen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mblen", jTcl_mblen_94  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mbstowcs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mbstowcs", jTcl_mbstowcs_95  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mbtowc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mbtowc", jTcl_mbtowc_96  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rand C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rand", jTcl_rand_97  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register srand C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.srand", jTcl_srand_98  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register system C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.system", jTcl_system_99  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wcstombs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wcstombs", jTcl_wcstombs_100  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wctomb C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wctomb", jTcl_wctomb_101  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register calloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.calloc", jTcl_calloc_102  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register exit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.exit", jTcl_exit_103  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register free C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.free", jTcl_free_104  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register getenv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.getenv", jTcl_getenv_105  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register malloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.malloc", jTcl_malloc_106  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register realloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.realloc", jTcl_realloc_107  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memchr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memchr", jTcl_memchr_108  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memcmp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memcmp", jTcl_memcmp_109  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memcpy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memcpy", jTcl_memcpy_110  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memmove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memmove", jTcl_memmove_111  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memset C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memset", jTcl_memset_112  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strcat C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strcat", jTcl_strcat_113  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strchr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strchr", jTcl_strchr_114  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strcmp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strcmp", jTcl_strcmp_115  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strcoll C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strcoll", jTcl_strcoll_116  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strcpy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strcpy", jTcl_strcpy_117  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strcspn C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strcspn", jTcl_strcspn_118  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strlen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strlen", jTcl_strlen_119  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strncat C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strncat", jTcl_strncat_120  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strncmp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strncmp", jTcl_strncmp_121  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strncpy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strncpy", jTcl_strncpy_122  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strpbrk C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strpbrk", jTcl_strpbrk_123  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strrchr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strrchr", jTcl_strrchr_124  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strspn C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strspn", jTcl_strspn_125  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strstr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strstr", jTcl_strstr_126  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strtok C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strtok", jTcl_strtok_127  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strxfrm C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strxfrm", jTcl_strxfrm_128  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strerror C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strerror", jTcl_strerror_129  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register strerror_r C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.strerror_r", jTcl_strerror_r_130  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bcopy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bcopy", jTcl_bcopy_131  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bcopyBytes C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bcopyBytes", jTcl_bcopyBytes_132  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bcopyWords C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bcopyWords", jTcl_bcopyWords_133  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bcopyLongs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bcopyLongs", jTcl_bcopyLongs_134  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bfill C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bfill", jTcl_bfill_135  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bfillBytes C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bfillBytes", jTcl_bfillBytes_136  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bzero C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bzero", jTcl_bzero_137  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bcmp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bcmp", jTcl_bcmp_138  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register binvert C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.binvert", jTcl_binvert_139  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bswap C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bswap", jTcl_bswap_140  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register uswab C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.uswab", jTcl_uswab_141  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register swab C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.swab", jTcl_swab_142  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register index C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.index", jTcl_index_143  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rindex C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rindex", jTcl_rindex_144  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register arpAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.arpAdd", jTcl_arpAdd_145  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register arpDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.arpDelete", jTcl_arpDelete_146  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register arpCmd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.arpCmd", jTcl_arpCmd_147  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register arpFlush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.arpFlush", jTcl_arpFlush_148  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootNetmaskExtract C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootNetmaskExtract", jTcl_bootNetmaskExtract_149  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootStructToString C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootStructToString", jTcl_bootStructToString_150  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootStringToStruct C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootStringToStruct", jTcl_bootStringToStruct_151  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootParamsErrorPrint C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootParamsErrorPrint", jTcl_bootParamsErrorPrint_152  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootParamsPrompt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootParamsPrompt", jTcl_bootParamsPrompt_153  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootParamsShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootParamsShow", jTcl_bootParamsShow_154  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootpParamsGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootpParamsGet", jTcl_bootpParamsGet_155  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootpMsgSend C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootpMsgSend", jTcl_bootpMsgSend_156  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootpTagFind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootpTagFind", jTcl_bootpTagFind_157  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hostAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hostAdd", jTcl_hostAdd_158  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hostDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hostDelete", jTcl_hostDelete_159  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hostGetByAddr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hostGetByAddr", jTcl_hostGetByAddr_160  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register gethostname C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.gethostname", jTcl_gethostname_161  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hostGetByName C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hostGetByName", jTcl_hostGetByName_162  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sethostname C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sethostname", jTcl_sethostname_163  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hostTblInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hostTblInit", jTcl_hostTblInit_164  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register inet_addr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.inet_addr", jTcl_inet_addr_165  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register inet_ntoa C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.inet_ntoa", jTcl_inet_ntoa_166  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register inet_makeaddr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.inet_makeaddr", jTcl_inet_makeaddr_167  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register inet_network C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.inet_network", jTcl_inet_network_168  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstFirst C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstFirst", jTcl_lstFirst_169  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstGet", jTcl_lstGet_170  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstLast C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstLast", jTcl_lstLast_171  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstNStep C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstNStep", jTcl_lstNStep_172  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstNext C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstNext", jTcl_lstNext_173  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstNth C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstNth", jTcl_lstNth_174  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstPrevious C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstPrevious", jTcl_lstPrevious_175  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstCount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstCount", jTcl_lstCount_176  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstFind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstFind", jTcl_lstFind_177  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstAdd", jTcl_lstAdd_178  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstConcat C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstConcat", jTcl_lstConcat_179  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstDelete", jTcl_lstDelete_180  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstExtract C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstExtract", jTcl_lstExtract_181  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstFree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstFree", jTcl_lstFree_182  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstInit", jTcl_lstInit_183  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lstInsert C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lstInsert", jTcl_lstInsert_184  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheLibInit", jTcl_cacheLibInit_185  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheArchLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheArchLibInit", jTcl_cacheArchLibInit_186  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheEnable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheEnable", jTcl_cacheEnable_187  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDisable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDisable", jTcl_cacheDisable_188  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheLock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheLock", jTcl_cacheLock_189  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheUnlock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheUnlock", jTcl_cacheUnlock_190  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheFlush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheFlush", jTcl_cacheFlush_191  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheInvalidate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheInvalidate", jTcl_cacheInvalidate_192  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheClear C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheClear", jTcl_cacheClear_193  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheTextUpdate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheTextUpdate", jTcl_cacheTextUpdate_194  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cachePipeFlush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cachePipeFlush", jTcl_cachePipeFlush_195  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDmaMalloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDmaMalloc", jTcl_cacheDmaMalloc_196  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDmaFree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDmaFree", jTcl_cacheDmaFree_197  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDrvFlush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDrvFlush", jTcl_cacheDrvFlush_198  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDrvInvalidate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDrvInvalidate", jTcl_cacheDrvInvalidate_199  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDrvVirtToPhys C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDrvVirtToPhys", jTcl_cacheDrvVirtToPhys_200  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheDrvPhysToVirt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheDrvPhysToVirt", jTcl_cacheDrvPhysToVirt_201  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cacheFuncsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cacheFuncsSet", jTcl_cacheFuncsSet_202  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register c C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.c", jTcl_c_203  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register s C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.s", jTcl_s_204  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dbgHelp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dbgHelp", jTcl_dbgHelp_205  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dbgInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dbgInit", jTcl_dbgInit_206  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register b C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.b", jTcl_b_207  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register e C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.e", jTcl_e_208  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bd", jTcl_bd_209  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bdall C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bdall", jTcl_bdall_210  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cret C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cret", jTcl_cret_211  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register so C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.so", jTcl_so_212  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register l C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.l", jTcl_l_213  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tt", jTcl_tt_214  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dbgPrintCall C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dbgPrintCall", jTcl_dbgPrintCall_215  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dbgBrkExists C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dbgBrkExists", jTcl_dbgBrkExists_216  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dbgBreakNotifyInstall C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dbgBreakNotifyInstall", jTcl_dbgBreakNotifyInstall_217  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dbgStepQuiet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dbgStepQuiet", jTcl_dbgStepQuiet_218  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bdTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bdTask", jTcl_bdTask_219  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register opendir C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.opendir", jTcl_opendir_220  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register closedir C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.closedir", jTcl_closedir_221  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register readdir C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.readdir", jTcl_readdir_222  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rewinddir C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rewinddir", jTcl_rewinddir_223  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsConfigGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsConfigGet", jTcl_dosFsConfigGet_224  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsConfigInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsConfigInit", jTcl_dosFsConfigInit_225  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsConfigShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsConfigShow", jTcl_dosFsConfigShow_226  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsDateSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsDateSet", jTcl_dosFsDateSet_227  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsDateTimeInstall C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsDateTimeInstall", jTcl_dosFsDateTimeInstall_228  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsDevInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsDevInit", jTcl_dosFsDevInit_229  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsDevInitOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsDevInitOptionsSet", jTcl_dosFsDevInitOptionsSet_230  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsInit", jTcl_dosFsInit_231  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsMkfs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsMkfs", jTcl_dosFsMkfs_232  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsMkfsOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsMkfsOptionsSet", jTcl_dosFsMkfsOptionsSet_233  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsModeChange C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsModeChange", jTcl_dosFsModeChange_234  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsReadyChange C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsReadyChange", jTcl_dosFsReadyChange_235  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsTimeSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsTimeSet", jTcl_dosFsTimeSet_236  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsVolOptionsGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsVolOptionsGet", jTcl_dosFsVolOptionsGet_237  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsVolOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsVolOptionsSet", jTcl_dosFsVolOptionsSet_238  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dosFsVolUnmount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dosFsVolUnmount", jTcl_dosFsVolUnmount_239  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllCreate", jTcl_sllCreate_240  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllEach", jTcl_sllEach_241  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllGet", jTcl_sllGet_242  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllPrevious C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllPrevious", jTcl_sllPrevious_243  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllDelete", jTcl_sllDelete_244  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllInit", jTcl_sllInit_245  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllTerminate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllTerminate", jTcl_sllTerminate_246  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllCount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllCount", jTcl_sllCount_247  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllPutAtHead C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllPutAtHead", jTcl_sllPutAtHead_248  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllPutAtTail C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllPutAtTail", jTcl_sllPutAtTail_249  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sllRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sllRemove", jTcl_sllRemove_250  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashKeyCmp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashKeyCmp", jTcl_hashKeyCmp_251  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashKeyStrCmp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashKeyStrCmp", jTcl_hashKeyStrCmp_252  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblCreate", jTcl_hashTblCreate_253  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblEach", jTcl_hashTblEach_254  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblFind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblFind", jTcl_hashTblFind_255  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashLibInit", jTcl_hashLibInit_256  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblDelete", jTcl_hashTblDelete_257  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblDestroy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblDestroy", jTcl_hashTblDestroy_258  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblInit", jTcl_hashTblInit_259  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblPut C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblPut", jTcl_hashTblPut_260  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblRemove", jTcl_hashTblRemove_261  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashTblTerminate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashTblTerminate", jTcl_hashTblTerminate_262  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashFuncIterScale C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashFuncIterScale", jTcl_hashFuncIterScale_263  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashFuncModulo C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashFuncModulo", jTcl_hashFuncModulo_264  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hashFuncMultiply C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hashFuncMultiply", jTcl_hashFuncMultiply_265  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosInit", jTcl_iosInit_266  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosShowInit", jTcl_iosShowInit_267  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosFdDevFind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosFdDevFind", jTcl_iosFdDevFind_268  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosNextDevGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosNextDevGet", jTcl_iosNextDevGet_269  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosClose C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosClose", jTcl_iosClose_270  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDevAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDevAdd", jTcl_iosDevAdd_271  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDrvRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDrvRemove", jTcl_iosDrvRemove_272  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosCreate", jTcl_iosCreate_273  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDelete", jTcl_iosDelete_274  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDrvInstall C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDrvInstall", jTcl_iosDrvInstall_275  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosFdNew C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosFdNew", jTcl_iosFdNew_276  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosFdValue C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosFdValue", jTcl_iosFdValue_277  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosIoctl C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosIoctl", jTcl_iosIoctl_278  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosOpen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosOpen", jTcl_iosOpen_279  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosRead C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosRead", jTcl_iosRead_280  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosWrite C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosWrite", jTcl_iosWrite_281  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDevDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDevDelete", jTcl_iosDevDelete_282  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDevShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDevShow", jTcl_iosDevShow_283  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosDrvShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosDrvShow", jTcl_iosDrvShow_284  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosFdFree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosFdFree", jTcl_iosFdFree_285  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosFdSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosFdSet", jTcl_iosFdSet_286  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iosFdShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iosFdShow", jTcl_iosFdShow_287  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllCreate", jTcl_dllCreate_288  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllEach", jTcl_dllEach_289  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllGet", jTcl_dllGet_290  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllDelete", jTcl_dllDelete_291  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllInit", jTcl_dllInit_292  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllTerminate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllTerminate", jTcl_dllTerminate_293  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllCount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllCount", jTcl_dllCount_294  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllAdd", jTcl_dllAdd_295  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllInsert C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllInsert", jTcl_dllInsert_296  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register dllRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.dllRemove", jTcl_dllRemove_297  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoCreate", jTcl_qFifoCreate_298  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoGet", jTcl_qFifoGet_299  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoDelete", jTcl_qFifoDelete_300  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoInit", jTcl_qFifoInit_301  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoInfo C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoInfo", jTcl_qFifoInfo_302  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoPut C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoPut", jTcl_qFifoPut_303  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoRemove", jTcl_qFifoRemove_304  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register qFifoEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.qFifoEach", jTcl_qFifoEach_305  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semGive C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semGive", jTcl_semGive_306  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semTake C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semTake", jTcl_semTake_307  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semFlush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semFlush", jTcl_semFlush_308  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semDelete", jTcl_semDelete_309  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semInfo C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semInfo", jTcl_semInfo_310  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semBLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semBLibInit", jTcl_semBLibInit_311  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semBCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semBCreate", jTcl_semBCreate_312  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semCLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semCLibInit", jTcl_semCLibInit_313  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semCCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semCCreate", jTcl_semCCreate_314  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semMLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semMLibInit", jTcl_semMLibInit_315  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semMCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semMCreate", jTcl_semMCreate_316  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semMGiveForce C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semMGiveForce", jTcl_semMGiveForce_317  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semOLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semOLibInit", jTcl_semOLibInit_318  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semCreate", jTcl_semCreate_319  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semShowInit", jTcl_semShowInit_320  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semShow", jTcl_semShow_321  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register envLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.envLibInit", jTcl_envLibInit_322  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register envPrivateCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.envPrivateCreate", jTcl_envPrivateCreate_323  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register envPrivateDestroy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.envPrivateDestroy", jTcl_envPrivateDestroy_324  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register putenv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.putenv", jTcl_putenv_325  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register envShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.envShow", jTcl_envShow_326  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register errnoOfTaskSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.errnoOfTaskSet", jTcl_errnoOfTaskSet_327  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register errnoSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.errnoSet", jTcl_errnoSet_328  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register errnoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.errnoGet", jTcl_errnoGet_329  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register errnoOfTaskGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.errnoOfTaskGet", jTcl_errnoOfTaskGet_330  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register etherAddrResolve C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.etherAddrResolve", jTcl_etherAddrResolve_331  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register etherInputHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.etherInputHookAdd", jTcl_etherInputHookAdd_332  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register etherOutput C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.etherOutput", jTcl_etherOutput_333  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register etherOutputHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.etherOutputHookAdd", jTcl_etherOutputHookAdd_334  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register etherInputHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.etherInputHookDelete", jTcl_etherInputHookDelete_335  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register etherOutputHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.etherOutputHookDelete", jTcl_etherOutputHookDelete_336  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register evtBufferIsEmpty C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.evtBufferIsEmpty", jTcl_evtBufferIsEmpty_337  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register evtBufferAddress C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.evtBufferAddress", jTcl_evtBufferAddress_338  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register evtBufferToFile C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.evtBufferToFile", jTcl_evtBufferToFile_339  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register evtBufferUpLoad C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.evtBufferUpLoad", jTcl_evtBufferUpLoad_340  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register excVecInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.excVecInit", jTcl_excVecInit_341  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register excShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.excShowInit", jTcl_excShowInit_342  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register excInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.excInit", jTcl_excInit_343  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register excHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.excHookAdd", jTcl_excHookAdd_344  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register excTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.excTask", jTcl_excTask_345  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register excJobAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.excJobAdd", jTcl_excJobAdd_346  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpLogin C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpLogin", jTcl_ftpLogin_347  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpXfer C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpXfer", jTcl_ftpXfer_348  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpCommand C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpCommand", jTcl_ftpCommand_349  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpDataConnGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpDataConnGet", jTcl_ftpDataConnGet_350  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpDataConnInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpDataConnInit", jTcl_ftpDataConnInit_351  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpHookup C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpHookup", jTcl_ftpHookup_352  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpReplyGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpReplyGet", jTcl_ftpReplyGet_353  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpdInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpdInit", jTcl_ftpdInit_354  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpdTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpdTask", jTcl_ftpdTask_355  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ftpdDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ftpdDelete", jTcl_ftpdDelete_356  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifAddrSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifAddrSet", jTcl_ifAddrSet_357  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifAddrGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifAddrGet", jTcl_ifAddrGet_358  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifBroadcastSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifBroadcastSet", jTcl_ifBroadcastSet_359  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifBroadcastGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifBroadcastGet", jTcl_ifBroadcastGet_360  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifDstAddrSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifDstAddrSet", jTcl_ifDstAddrSet_361  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifDstAddrGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifDstAddrGet", jTcl_ifDstAddrGet_362  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifMaskSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifMaskSet", jTcl_ifMaskSet_363  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifMaskGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifMaskGet", jTcl_ifMaskGet_364  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifFlagChange C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifFlagChange", jTcl_ifFlagChange_365  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifFlagSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifFlagSet", jTcl_ifFlagSet_366  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifFlagGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifFlagGet", jTcl_ifFlagGet_367  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifMetricSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifMetricSet", jTcl_ifMetricSet_368  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifMetricGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifMetricGet", jTcl_ifMetricGet_369  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifRouteDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifRouteDelete", jTcl_ifRouteDelete_370  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifunit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifunit", jTcl_ifunit_371  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bpattach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bpattach", jTcl_bpattach_372  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bpInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bpInit", jTcl_bpInit_373  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bpShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bpShow", jTcl_bpShow_374  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register slipInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.slipInit", jTcl_slipInit_375  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register slipBaudSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.slipBaudSet", jTcl_slipBaudSet_376  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intConnect C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intConnect", jTcl_intConnect_377  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intHandlerCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intHandlerCreate", jTcl_intHandlerCreate_378  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intLockLevelSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intLockLevelSet", jTcl_intLockLevelSet_379  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intLockLevelGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intLockLevelGet", jTcl_intLockLevelGet_380  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intContext C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intContext", jTcl_intContext_381  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intCount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intCount", jTcl_intCount_382  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intVecBaseSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intVecBaseSet", jTcl_intVecBaseSet_383  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intVecBaseGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intVecBaseGet", jTcl_intVecBaseGet_384  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intVecSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intVecSet", jTcl_intVecSet_385  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intVecGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intVecGet", jTcl_intVecGet_386  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intLevelSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intLevelSet", jTcl_intLevelSet_387  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intLock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intLock", jTcl_intLock_388  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intUnlock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intUnlock", jTcl_intUnlock_389  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intVecTableWriteProtect C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intVecTableWriteProtect", jTcl_intVecTableWriteProtect_390  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intCRGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intCRGet", jTcl_intCRGet_391  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intCRSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intCRSet", jTcl_intCRSet_392  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intSRGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intSRGet", jTcl_intSRGet_393  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intSRSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intSRSet", jTcl_intSRSet_394  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intAckConfig C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intAckConfig", jTcl_intAckConfig_395  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intTBRSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intTBRSet", jTcl_intTBRSet_396  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intVecTableWriteEnable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intVecTableWriteEnable", jTcl_intVecTableWriteEnable_397  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intHandlerCreateAm29k C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intHandlerCreateAm29k", jTcl_intHandlerCreateAm29k_398  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register am29200Intr3DeMuxConnect C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.am29200Intr3DeMuxConnect", jTcl_am29200Intr3DeMuxConnect_399  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intDisable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intDisable", jTcl_intDisable_400  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register intEnable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.intEnable", jTcl_intEnable_401  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loadModule C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loadModule", jTcl_loadModule_402  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loadModuleGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loadModuleGet", jTcl_loadModuleGet_403  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register addSegNames C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.addSegNames", jTcl_addSegNames_404  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loadSegmentsAllocate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loadSegmentsAllocate", jTcl_loadSegmentsAllocate_405  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginDefaultEncrypt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginDefaultEncrypt", jTcl_loginDefaultEncrypt_406  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginPrompt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginPrompt", jTcl_loginPrompt_407  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginUserAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginUserAdd", jTcl_loginUserAdd_408  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginUserDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginUserDelete", jTcl_loginUserDelete_409  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginUserVerify C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginUserVerify", jTcl_loginUserVerify_410  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginEncryptInstall C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginEncryptInstall", jTcl_loginEncryptInstall_411  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginInit", jTcl_loginInit_412  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginStringSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginStringSet", jTcl_loginStringSet_413  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register loginUserShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.loginUserShow", jTcl_loginUserShow_414  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logFdAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logFdAdd", jTcl_logFdAdd_415  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logFdDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logFdDelete", jTcl_logFdDelete_416  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logInit", jTcl_logInit_417  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logMsg C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logMsg", jTcl_logMsg_418  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logFdSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logFdSet", jTcl_logFdSet_419  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logShow", jTcl_logShow_420  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logTask", jTcl_logTask_421  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memDrv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memDrv", jTcl_memDrv_422  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memDevCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memDevCreate", jTcl_memDevCreate_423  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memInit", jTcl_memInit_424  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartLibInit", jTcl_memPartLibInit_425  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartCreate", jTcl_memPartCreate_426  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartInit", jTcl_memPartInit_427  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartAddToPool C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartAddToPool", jTcl_memPartAddToPool_428  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memAddToPool C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memAddToPool", jTcl_memAddToPool_429  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartAlloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartAlloc", jTcl_memPartAlloc_430  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartAlignedAlloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartAlignedAlloc", jTcl_memPartAlignedAlloc_431  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memalign C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memalign", jTcl_memalign_432  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register valloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.valloc", jTcl_valloc_433  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartFree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartFree", jTcl_memPartFree_434  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartOptionsSet", jTcl_memPartOptionsSet_435  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memFindMax C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memFindMax", jTcl_memFindMax_436  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartFindMax C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartFindMax", jTcl_memPartFindMax_437  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartRealloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartRealloc", jTcl_memPartRealloc_438  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memOptionsSet", jTcl_memOptionsSet_439  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cfree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cfree", jTcl_cfree_440  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memShowInit", jTcl_memShowInit_441  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memShow", jTcl_memShow_442  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartShow", jTcl_memPartShow_443  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartInfoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartInfoGet", jTcl_memPartInfoGet_444  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleLibInit", jTcl_moduleLibInit_445  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleCreate", jTcl_moduleCreate_446  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleInit", jTcl_moduleInit_447  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleTerminate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleTerminate", jTcl_moduleTerminate_448  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleDelete", jTcl_moduleDelete_449  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleIdFigure C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleIdFigure", jTcl_moduleIdFigure_450  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleShow", jTcl_moduleShow_451  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleSegAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleSegAdd", jTcl_moduleSegAdd_452  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleSegGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleSegGet", jTcl_moduleSegGet_453  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleSegFirst C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleSegFirst", jTcl_moduleSegFirst_454  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleSegNext C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleSegNext", jTcl_moduleSegNext_455  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleSegEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleSegEach", jTcl_moduleSegEach_456  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleCreateHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleCreateHookAdd", jTcl_moduleCreateHookAdd_457  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleCreateHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleCreateHookDelete", jTcl_moduleCreateHookDelete_458  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleFindByName C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleFindByName", jTcl_moduleFindByName_459  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleFindByNameAndPath C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleFindByNameAndPath", jTcl_moduleFindByNameAndPath_460  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleFindByGroup C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleFindByGroup", jTcl_moduleFindByGroup_461  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleEach", jTcl_moduleEach_462  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleIdListGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleIdListGet", jTcl_moduleIdListGet_463  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleInfoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleInfoGet", jTcl_moduleInfoGet_464  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleNameGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleNameGet", jTcl_moduleNameGet_465  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleFlagsGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleFlagsGet", jTcl_moduleFlagsGet_466  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register moduleCheck C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.moduleCheck", jTcl_moduleCheck_467  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mountdInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mountdInit", jTcl_mountdInit_468  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mountd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mountd", jTcl_mountd_469  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsExport C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsExport", jTcl_nfsExport_470  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsUnexport C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsUnexport", jTcl_nfsUnexport_471  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsExportFindByName C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsExportFindByName", jTcl_nfsExportFindByName_472  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsExportFindById C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsExportFindById", jTcl_nfsExportFindById_473  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register fdToInode C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.fdToInode", jTcl_fdToInode_474  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nameToInode C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nameToInode", jTcl_nameToInode_475  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_close C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_close", jTcl_mq_close_476  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_unlink C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_unlink", jTcl_mq_unlink_477  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_send C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_send", jTcl_mq_send_478  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_receive C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_receive", jTcl_mq_receive_479  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_notify C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_notify", jTcl_mq_notify_480  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_setattr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_setattr", jTcl_mq_setattr_481  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mq_getattr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mq_getattr", jTcl_mq_getattr_482  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQLibInit", jTcl_msgQLibInit_483  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQCreate", jTcl_msgQCreate_484  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQDelete", jTcl_msgQDelete_485  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQSend C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQSend", jTcl_msgQSend_486  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQReceive C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQReceive", jTcl_msgQReceive_487  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQInfoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQInfoGet", jTcl_msgQInfoGet_488  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQNumMsgs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQNumMsgs", jTcl_msgQNumMsgs_489  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQShowInit", jTcl_msgQShowInit_490  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQShow", jTcl_msgQShow_491  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQSmCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQSmCreate", jTcl_msgQSmCreate_492  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register msgQSmShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.msgQSmShowInit", jTcl_msgQSmShowInit_493  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register arptabShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.arptabShow", jTcl_arptabShow_494  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register arpShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.arpShow", jTcl_arpShow_495  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register icmpstatShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.icmpstatShow", jTcl_icmpstatShow_496  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ifShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ifShow", jTcl_ifShow_497  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register inetstatShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.inetstatShow", jTcl_inetstatShow_498  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ipstatShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ipstatShow", jTcl_ipstatShow_499  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mbufShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mbufShow", jTcl_mbufShow_500  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register netShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.netShowInit", jTcl_netShowInit_501  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tcpDebugShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tcpDebugShow", jTcl_tcpDebugShow_502  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tcpstatShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tcpstatShow", jTcl_tcpstatShow_503  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register udpstatShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.udpstatShow", jTcl_udpstatShow_504  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register routeShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.routeShow", jTcl_routeShow_505  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register hostShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.hostShow", jTcl_hostShow_506  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdInit", jTcl_nfsdInit_507  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdRequestProcess C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdRequestProcess", jTcl_nfsdRequestProcess_508  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsd", jTcl_nfsd_509  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdStatusGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdStatusGet", jTcl_nfsdStatusGet_510  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdStatusShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdStatusShow", jTcl_nfsdStatusShow_511  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdFhCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdFhCreate", jTcl_nfsdFhCreate_512  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdFhToName C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdFhToName", jTcl_nfsdFhToName_513  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdFattrGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdFattrGet", jTcl_nfsdFattrGet_514  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdFhHton C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdFhHton", jTcl_nfsdFhHton_515  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsdFhNtoh C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsdFhNtoh", jTcl_nfsdFhNtoh_516  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsExportShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsExportShow", jTcl_nfsExportShow_517  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsAuthUnixGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsAuthUnixGet", jTcl_nfsAuthUnixGet_518  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsAuthUnixSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsAuthUnixSet", jTcl_nfsAuthUnixSet_519  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsAuthUnixPrompt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsAuthUnixPrompt", jTcl_nfsAuthUnixPrompt_520  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsAuthUnixShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsAuthUnixShow", jTcl_nfsAuthUnixShow_521  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsHelp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsHelp", jTcl_nfsHelp_522  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsIdSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsIdSet", jTcl_nfsIdSet_523  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsDrv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsDrv", jTcl_nfsDrv_524  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsMount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsMount", jTcl_nfsMount_525  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsMountAll C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsMountAll", jTcl_nfsMountAll_526  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsDevShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsDevShow", jTcl_nfsDevShow_527  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsUnmount C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsUnmount", jTcl_nfsUnmount_528  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsDevListGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsDevListGet", jTcl_nfsDevListGet_529  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register nfsDevInfoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.nfsDevInfoGet", jTcl_nfsDevInfoGet_530  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register pingLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.pingLibInit", jTcl_pingLibInit_531  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ping C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ping", jTcl_ping_532  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register pipeDevCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.pipeDevCreate", jTcl_pipeDevCreate_533  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register pipeDrv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.pipeDrv", jTcl_pipeDrv_534  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyArpLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyArpLibInit", jTcl_proxyArpLibInit_535  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyPortShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyPortShow", jTcl_proxyPortShow_536  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyPortFwdOn C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyPortFwdOn", jTcl_proxyPortFwdOn_537  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyPortFwdOff C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyPortFwdOff", jTcl_proxyPortFwdOff_538  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyNetCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyNetCreate", jTcl_proxyNetCreate_539  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyNetDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyNetDelete", jTcl_proxyNetDelete_540  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyClientAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyClientAdd", jTcl_proxyClientAdd_541  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyClientDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyClientDelete", jTcl_proxyClientDelete_542  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyReg C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyReg", jTcl_proxyReg_543  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register proxyUnreg C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.proxyUnreg", jTcl_proxyUnreg_544  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ramDrv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ramDrv", jTcl_ramDrv_545  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ramDevCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ramDevCreate", jTcl_ramDevCreate_546  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rebootHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rebootHookAdd", jTcl_rebootHookAdd_547  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register reboot C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.reboot", jTcl_reboot_548  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bindresvport C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bindresvport", jTcl_bindresvport_549  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register iam C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.iam", jTcl_iam_550  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register remCurIdSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.remCurIdSet", jTcl_remCurIdSet_551  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rcmd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rcmd", jTcl_rcmd_552  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rresvport C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rresvport", jTcl_rresvport_553  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register remCurIdGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.remCurIdGet", jTcl_remCurIdGet_554  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register whoami C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.whoami", jTcl_whoami_555  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rlogInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rlogInit", jTcl_rlogInit_556  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rlogin C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rlogin", jTcl_rlogin_557  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rlogChildTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rlogChildTask", jTcl_rlogChildTask_558  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rlogInTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rlogInTask", jTcl_rlogInTask_559  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rlogOutTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rlogOutTask", jTcl_rlogOutTask_560  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rlogind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rlogind", jTcl_rlogind_561  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngIsEmpty C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngIsEmpty", jTcl_rngIsEmpty_562  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngIsFull C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngIsFull", jTcl_rngIsFull_563  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngCreate", jTcl_rngCreate_564  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngBufGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngBufGet", jTcl_rngBufGet_565  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngBufPut C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngBufPut", jTcl_rngBufPut_566  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngFreeBytes C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngFreeBytes", jTcl_rngFreeBytes_567  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngNBytes C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngNBytes", jTcl_rngNBytes_568  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngDelete", jTcl_rngDelete_569  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngFlush C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngFlush", jTcl_rngFlush_570  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngMoveAhead C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngMoveAhead", jTcl_rngMoveAhead_571  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rngPutAhead C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rngPutAhead", jTcl_rngPutAhead_572  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register routeAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.routeAdd", jTcl_routeAdd_573  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register routeDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.routeDelete", jTcl_routeDelete_574  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register routeNetAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.routeNetAdd", jTcl_routeNetAdd_575  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register routeCmd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.routeCmd", jTcl_routeCmd_576  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semBSmCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semBSmCreate", jTcl_semBSmCreate_577  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semCSmCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semCSmCreate", jTcl_semCSmCreate_578  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register semSmShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.semSmShowInit", jTcl_semSmShowInit_579  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register memPartSmCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.memPartSmCreate", jTcl_memPartSmCreate_580  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemFree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemFree", jTcl_smMemFree_581  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemFindMax C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemFindMax", jTcl_smMemFindMax_582  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemMalloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemMalloc", jTcl_smMemMalloc_583  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemCalloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemCalloc", jTcl_smMemCalloc_584  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemRealloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemRealloc", jTcl_smMemRealloc_585  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemAddToPool C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemAddToPool", jTcl_smMemAddToPool_586  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemOptionsSet", jTcl_smMemOptionsSet_587  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemShowInit", jTcl_smMemShowInit_588  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smMemShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smMemShow", jTcl_smMemShow_589  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smNameAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smNameAdd", jTcl_smNameAdd_590  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smNameFind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smNameFind", jTcl_smNameFind_591  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smNameFindByValue C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smNameFindByValue", jTcl_smNameFindByValue_592  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smNameRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smNameRemove", jTcl_smNameRemove_593  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smNameShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smNameShowInit", jTcl_smNameShowInit_594  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smNameShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smNameShow", jTcl_smNameShow_595  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smObjLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smObjLibInit", jTcl_smObjLibInit_596  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smObjLocalToGlobal C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smObjLocalToGlobal", jTcl_smObjLocalToGlobal_597  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smObjGlobalToLocal C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smObjGlobalToLocal", jTcl_smObjGlobalToLocal_598  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smObjTimeoutLogEnable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smObjTimeoutLogEnable", jTcl_smObjTimeoutLogEnable_599  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smObjShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smObjShowInit", jTcl_smObjShowInit_600  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register smObjShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.smObjShow", jTcl_smObjShow_601  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sockLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sockLibInit", jTcl_sockLibInit_602  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sockLibAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sockLibAdd", jTcl_sockLibAdd_603  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bind C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bind", jTcl_bind_604  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register connect C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.connect", jTcl_connect_605  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register connectWithTimeout C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.connectWithTimeout", jTcl_connectWithTimeout_606  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register getpeername C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.getpeername", jTcl_getpeername_607  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register getsockname C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.getsockname", jTcl_getsockname_608  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register getsockopt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.getsockopt", jTcl_getsockopt_609  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register listen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.listen", jTcl_listen_610  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register setsockopt C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.setsockopt", jTcl_setsockopt_611  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register shutdown C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.shutdown", jTcl_shutdown_612  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register accept C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.accept", jTcl_accept_613  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register recv C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.recv", jTcl_recv_614  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register recvfrom C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.recvfrom", jTcl_recvfrom_615  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register recvmsg C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.recvmsg", jTcl_recvmsg_616  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register send C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.send", jTcl_send_617  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sendmsg C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sendmsg", jTcl_sendmsg_618  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sendto C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sendto", jTcl_sendto_619  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register socket C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.socket", jTcl_socket_620  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyLibInit", jTcl_spyLibInit_621  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyClkStartCommon C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyClkStartCommon", jTcl_spyClkStartCommon_622  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyCommon C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyCommon", jTcl_spyCommon_623  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyClkStopCommon C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyClkStopCommon", jTcl_spyClkStopCommon_624  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyReportCommon C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyReportCommon", jTcl_spyReportCommon_625  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyStopCommon C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyStopCommon", jTcl_spyStopCommon_626  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyComTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyComTask", jTcl_spyComTask_627  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symLibInit", jTcl_symLibInit_628  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symEach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symEach", jTcl_symEach_629  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symName C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symName", jTcl_symName_630  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symShowInit", jTcl_symShowInit_631  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symShow", jTcl_symShow_632  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblDelete", jTcl_symTblDelete_633  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblTerminate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblTerminate", jTcl_symTblTerminate_634  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblDestroy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblDestroy", jTcl_symTblDestroy_635  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symFree C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symFree", jTcl_symFree_636  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symSAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symSAdd", jTcl_symSAdd_637  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symAdd", jTcl_symAdd_638  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblAdd", jTcl_symTblAdd_639  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symRemove", jTcl_symRemove_640  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblRemove C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblRemove", jTcl_symTblRemove_641  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symInit", jTcl_symInit_642  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symAlloc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symAlloc", jTcl_symAlloc_643  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblInit", jTcl_symTblInit_644  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symTblCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symTblCreate", jTcl_symTblCreate_645  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symFindSymbol C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symFindSymbol", jTcl_symFindSymbol_646  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symFindByValue C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symFindByValue", jTcl_symFindByValue_647  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register symFindByValueAndType C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.symFindByValueAndType", jTcl_symFindByValueAndType_648  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysModel C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysModel", jTcl_sysModel_649  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysBspRev C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysBspRev", jTcl_sysBspRev_650  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysMemTop C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysMemTop", jTcl_sysMemTop_651  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysPhysMemTop C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysPhysMemTop", jTcl_sysPhysMemTop_652  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysToMonitor C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysToMonitor", jTcl_sysToMonitor_653  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysProcNumGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysProcNumGet", jTcl_sysProcNumGet_654  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysProcNumSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysProcNumSet", jTcl_sysProcNumSet_655  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysBusTas C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysBusTas", jTcl_sysBusTas_656  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysNvRamGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysNvRamGet", jTcl_sysNvRamGet_657  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysNvRamSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysNvRamSet", jTcl_sysNvRamSet_658  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysSerialReset C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysSerialReset", jTcl_sysSerialReset_659  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysBusIntAck C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysBusIntAck", jTcl_sysBusIntAck_660  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysBusIntGen C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysBusIntGen", jTcl_sysBusIntGen_661  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysMailboxConnect C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysMailboxConnect", jTcl_sysMailboxConnect_662  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysMailboxEnable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysMailboxEnable", jTcl_sysMailboxEnable_663  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskHookInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskHookInit", jTcl_taskHookInit_664  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskCreateHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskCreateHookAdd", jTcl_taskCreateHookAdd_665  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskCreateHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskCreateHookDelete", jTcl_taskCreateHookDelete_666  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskDeleteHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskDeleteHookAdd", jTcl_taskDeleteHookAdd_667  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskDeleteHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskDeleteHookDelete", jTcl_taskDeleteHookDelete_668  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwapHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwapHookAdd", jTcl_taskSwapHookAdd_669  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwapHookAttach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwapHookAttach", jTcl_taskSwapHookAttach_670  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwapHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwapHookDelete", jTcl_taskSwapHookDelete_671  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwapHookDetach C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwapHookDetach", jTcl_taskSwapHookDetach_672  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwitchHookAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwitchHookAdd", jTcl_taskSwitchHookAdd_673  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwitchHookDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwitchHookDelete", jTcl_taskSwitchHookDelete_674  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskHookShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskHookShowInit", jTcl_taskHookShowInit_675  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskCreateHookShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskCreateHookShow", jTcl_taskCreateHookShow_676  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskDeleteHookShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskDeleteHookShow", jTcl_taskDeleteHookShow_677  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwapHookShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwapHookShow", jTcl_taskSwapHookShow_678  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSwitchHookShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSwitchHookShow", jTcl_taskSwitchHookShow_679  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSpawn C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSpawn", jTcl_taskSpawn_680  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskInit", jTcl_taskInit_681  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskActivate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskActivate", jTcl_taskActivate_682  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskDelete", jTcl_taskDelete_683  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskDeleteForce C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskDeleteForce", jTcl_taskDeleteForce_684  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSuspend C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSuspend", jTcl_taskSuspend_685  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskResume C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskResume", jTcl_taskResume_686  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskRestart C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskRestart", jTcl_taskRestart_687  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskPrioritySet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskPrioritySet", jTcl_taskPrioritySet_688  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskPriorityGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskPriorityGet", jTcl_taskPriorityGet_689  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskLock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskLock", jTcl_taskLock_690  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskUnlock C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskUnlock", jTcl_taskUnlock_691  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskSafe C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskSafe", jTcl_taskSafe_692  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskUnsafe C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskUnsafe", jTcl_taskUnsafe_693  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskDelay C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskDelay", jTcl_taskDelay_694  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskOptionsSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskOptionsSet", jTcl_taskOptionsSet_695  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskOptionsGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskOptionsGet", jTcl_taskOptionsGet_696  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskName C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskName", jTcl_taskName_697  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskNameToId C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskNameToId", jTcl_taskNameToId_698  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIdVerify C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIdVerify", jTcl_taskIdVerify_699  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIdSelf C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIdSelf", jTcl_taskIdSelf_700  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIdDefault C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIdDefault", jTcl_taskIdDefault_701  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIsReady C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIsReady", jTcl_taskIsReady_702  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIsSuspended C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIsSuspended", jTcl_taskIsSuspended_703  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskTcb C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskTcb", jTcl_taskTcb_704  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIdListGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIdListGet", jTcl_taskIdListGet_705  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskInfoGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskInfoGet", jTcl_taskInfoGet_706  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskStatusString C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskStatusString", jTcl_taskStatusString_707  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskOptionsString C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskOptionsString", jTcl_taskOptionsString_708  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskRegsShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskRegsShow", jTcl_taskRegsShow_709  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskStackAllot C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskStackAllot", jTcl_taskStackAllot_710  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskShowInit", jTcl_taskShowInit_711  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskShow", jTcl_taskShow_712  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskVarAdd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskVarAdd", jTcl_taskVarAdd_713  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskVarDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskVarDelete", jTcl_taskVarDelete_714  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskVarInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskVarInit", jTcl_taskVarInit_715  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskVarSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskVarSet", jTcl_taskVarSet_716  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskVarGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskVarGet", jTcl_taskVarGet_717  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskVarInfo C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskVarInfo", jTcl_taskVarInfo_718  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tickAnnounce C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tickAnnounce", jTcl_tickAnnounce_719  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tickSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tickSet", jTcl_tickSet_720  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tickGet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tickGet", jTcl_tickGet_721  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timex C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timex", jTcl_timex_722  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexClear C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexClear", jTcl_timexClear_723  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexFunc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexFunc", jTcl_timexFunc_724  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexHelp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexHelp", jTcl_timexHelp_725  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexInit", jTcl_timexInit_726  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexN C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexN", jTcl_timexN_727  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexPost C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexPost", jTcl_timexPost_728  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexPre C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexPre", jTcl_timexPre_729  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register timexShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.timexShow", jTcl_timexShow_730  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register unld C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.unld", jTcl_unld_731  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register unldByNameAndPath C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.unldByNameAndPath", jTcl_unldByNameAndPath_732  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register unldByGroup C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.unldByGroup", jTcl_unldByGroup_733  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register unldByModuleId C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.unldByModuleId", jTcl_unldByModuleId_734  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register reld C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.reld", jTcl_reld_735  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register help C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.help", jTcl_help_736  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register netHelp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.netHelp", jTcl_netHelp_737  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register bootChange C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.bootChange", jTcl_bootChange_738  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register periodRun C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.periodRun", jTcl_periodRun_739  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register period C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.period", jTcl_period_740  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register repeatRun C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.repeatRun", jTcl_repeatRun_741  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register repeat C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.repeat", jTcl_repeat_742  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sp", jTcl_sp_743  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register taskIdFigure C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.taskIdFigure", jTcl_taskIdFigure_744  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register checkStack C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.checkStack", jTcl_checkStack_745  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register i C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.i", jTcl_i_746  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ts C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ts", jTcl_ts_747  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register tr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.tr", jTcl_tr_748  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register td C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.td", jTcl_td_749  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ti C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ti", jTcl_ti_750  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register version C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.version", jTcl_version_751  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register m C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.m", jTcl_m_752  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register d C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.d", jTcl_d_753  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register cd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.cd", jTcl_cd_754  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register pwd C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.pwd", jTcl_pwd_755  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register copy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.copy", jTcl_copy_756  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register copyStreams C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.copyStreams", jTcl_copyStreams_757  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register diskFormat C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.diskFormat", jTcl_diskFormat_758  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register diskInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.diskInit", jTcl_diskInit_759  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register squeeze C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.squeeze", jTcl_squeeze_760  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ld C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ld", jTcl_ld_761  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ls C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ls", jTcl_ls_762  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register ll C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.ll", jTcl_ll_763  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lsOld C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lsOld", jTcl_lsOld_764  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register rm C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.rm", jTcl_rm_765  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register devs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.devs", jTcl_devs_766  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lkup C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lkup", jTcl_lkup_767  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register lkAddr C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.lkAddr", jTcl_lkAddr_768  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register mRegs C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.mRegs", jTcl_mRegs_769  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register printErrno C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.printErrno", jTcl_printErrno_770  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register printLogo C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.printLogo", jTcl_printLogo_771  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register logout C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.logout", jTcl_logout_772  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register h C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.h", jTcl_h_773  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register pc C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.pc", jTcl_pc_774  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register show C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.show", jTcl_show_775  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyClkStart C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyClkStart", jTcl_spyClkStart_776  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyClkStop C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyClkStop", jTcl_spyClkStop_777  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spy C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spy", jTcl_spy_778  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyStop C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyStop", jTcl_spyStop_779  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyHelp C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyHelp", jTcl_spyHelp_780  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyReport C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyReport", jTcl_spyReport_781  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register spyTask C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.spyTask", jTcl_spyTask_782  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register sysMemProbe C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.sysMemProbe", jTcl_sysMemProbe_783  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register vxMemProbe C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.vxMemProbe", jTcl_vxMemProbe_784  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register vxTas C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.vxTas", jTcl_vxTas_785  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdLibInit", jTcl_wdLibInit_786  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdCreate C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdCreate", jTcl_wdCreate_787  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdDelete C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdDelete", jTcl_wdDelete_788  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdStart C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdStart", jTcl_wdStart_789  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdCancel C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdCancel", jTcl_wdCancel_790  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdShowInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdShowInit", jTcl_wdShowInit_791  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wdShow C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wdShow", jTcl_wdShow_792  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvEvtLogEnable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvEvtLogEnable", jTcl_wvEvtLogEnable_793  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvEvtLogDisable C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvEvtLogDisable", jTcl_wvEvtLogDisable_794  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvOn C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvOn", jTcl_wvOn_795  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvOff C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvOff", jTcl_wvOff_796  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvEvtLogStop C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvEvtLogStop", jTcl_wvEvtLogStop_797  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvEvtTaskInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvEvtTaskInit", jTcl_wvEvtTaskInit_798  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvInstInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvInstInit", jTcl_wvInstInit_799  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvLibInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvLibInit", jTcl_wvLibInit_800  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvObjInstModeSet C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvObjInstModeSet", jTcl_wvObjInstModeSet_801  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvObjInst C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvObjInst", jTcl_wvObjInst_802  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvSigInst C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvSigInst", jTcl_wvSigInst_803  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvHostInfoInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvHostInfoInit", jTcl_wvHostInfoInit_804  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register wvServerInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.wvServerInit", jTcl_wvServerInit_805  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);

 // register customInit C/C++ entry point as  Tcl command
 Tcl_CreateObjCommand (interp,"VxWorks.customInit", jTcl_customInit_806  , (ClientData)NULL, (Tcl_CmdDeleteProc*) NULL);
 return TCL_OK;
} // end function VxWorks_Init
#ifdef __cplusplus
}
#endif

// ------------------ end cmdVxWorksTornado_wpr.c ----------------------
